// https://unpkg.com/prettier@1.13.0/standalone.js
// compressed with: https://jscompress.com/
!function (e, t) { "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : e.prettier = t() }(this, function () { "use strict"; var name = "prettier", version$1 = "1.13.0", description = "Prettier is an opinionated code formatter", bin = { prettier: "./bin/prettier.js" }, repository = "prettier/prettier", homepage = "https://prettier.io", author = "James Long", license = "MIT", main = "./index.js", engines = { node: ">=6" }, dependencies = { "@babel/code-frame": "7.0.0-beta.49", "@babel/parser": "7.0.0-beta.49", "@glimmer/syntax": "0.30.3", camelcase: "4.1.0", chalk: "2.1.0", "cjk-regex": "1.0.2", cosmiconfig: "3.1.0", dashify: "0.2.2", dedent: "0.7.0", diff: "3.2.0", editorconfig: "0.15.0", "editorconfig-to-prettier": "0.0.6", "emoji-regex": "6.5.1", "escape-string-regexp": "1.0.5", esutils: "2.0.2", "find-parent-dir": "0.3.0", "find-project-root": "1.1.1", "flow-parser": "0.73.0", "get-stream": "3.0.0", globby: "6.1.0", graphql: "0.13.2", "html-tag-names": "1.1.2", ignore: "3.3.7", "jest-docblock": "22.2.2", "json-stable-stringify": "1.0.1", leven: "2.1.0", "lodash.uniqby": "4.7.0", mem: "1.1.0", minimatch: "3.0.4", minimist: "1.2.0", parse5: "3.0.3", "postcss-less": "1.1.5", "postcss-media-query-parser": "0.2.3", "postcss-scss": "1.0.5", "postcss-selector-parser": "2.2.3", "postcss-values-parser": "1.5.0", "remark-parse": "5.0.0", resolve: "1.5.0", semver: "5.4.1", "string-width": "2.1.1", typescript: "2.9.0-dev.20180421", "typescript-eslint-parser": "eslint/typescript-eslint-parser#2960b002746c01fb9cb15bb5f4c1e7e925c6519a", "unicode-regex": "1.0.1", unified: "6.1.6" }, devDependencies = { "@babel/cli": "7.0.0-beta.49", "@babel/core": "7.0.0-beta.49", "@babel/preset-env": "7.0.0-beta.49", "builtin-modules": "2.0.0", codecov: "2.2.0", "cross-env": "5.0.5", eslint: "4.18.2", "eslint-config-prettier": "2.9.0", "eslint-friendly-formatter": "3.0.0", "eslint-plugin-import": "2.9.0", "eslint-plugin-prettier": "2.6.0", "eslint-plugin-react": "7.7.0", jest: "21.1.0", mkdirp: "0.5.1", prettier: "1.12.1", prettylint: "1.0.0", rimraf: "2.6.2", rollup: "0.47.6", "rollup-plugin-babel": "4.0.0-beta.4", "rollup-plugin-commonjs": "8.2.6", "rollup-plugin-json": "2.1.1", "rollup-plugin-node-builtins": "2.0.0", "rollup-plugin-node-globals": "1.1.0", "rollup-plugin-node-resolve": "2.0.0", "rollup-plugin-replace": "1.2.1", "rollup-plugin-uglify": "3.0.0", shelljs: "0.8.1", "snapshot-diff": "0.2.2", "strip-ansi": "4.0.0", tempy: "0.2.1", webpack: "2.6.1" }, scripts = { prepublishOnly: 'echo "Error: must publish from dist/" && exit 1', "prepare-release": "yarn && yarn build && yarn test:dist", test: "jest", "test:dist": "node ./scripts/test-dist.js", "test-integration": "jest tests_integration", lint: "cross-env EFF_NO_LINK_RULES=true eslint . --format node_modules/eslint-friendly-formatter", "lint-docs": "prettylint {.,docs,website,website/blog}/*.md", build: "node ./scripts/build/build.js", "build-docs": "node ./scripts/old-build/build-docs.js", "check-deps": "node ./scripts/check-deps.js" }, _package = { name: name, version: version$1, description: description, bin: bin, repository: repository, homepage: homepage, author: author, license: license, main: main, engines: engines, dependencies: dependencies, devDependencies: devDependencies, scripts: scripts }, _package$1 = Object.freeze({ name: name, version: version$1, description: description, bin: bin, repository: repository, homepage: homepage, author: author, license: license, main: main, engines: engines, dependencies: dependencies, devDependencies: devDependencies, scripts: scripts, default: _package }), commonjsGlobal = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}; function unwrapExports(e) { return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e } function createCommonjsModule(e, t) { return e(t = { exports: {} }, t.exports), t.exports } var base = createCommonjsModule(function (e, t) { function n() { } function g(e, t, n, r, a) { for (var u = 0, o = t.length, i = 0, s = 0; u < o; u++) { var c = t[u]; if (c.removed) { if (c.value = e.join(r.slice(s, s + c.count)), s += c.count, u && t[u - 1].added) { var l = t[u - 1]; t[u - 1] = t[u], t[u] = l } } else { if (!c.added && a) { var p = n.slice(i, i + c.count); p = p.map(function (e, t) { var n = r[s + t]; return n.length > e.length ? n : e }), c.value = e.join(p) } else c.value = e.join(n.slice(i, i + c.count)); i += c.count, c.added || (s += c.count) } } var d = t[o - 1]; return 1 < o && (d.added || d.removed) && e.equals("", d.value) && (t[o - 2].value += d.value, t.pop()), t } t.__esModule = !0, (t.default = n).prototype = { diff: function (s, c, e) { var t = arguments.length <= 2 || void 0 === e ? {} : e, n = t.callback; "function" == typeof t && (n = t, t = {}), this.options = t; var l = this; function p(e) { return n ? (setTimeout(function () { n(void 0, e) }, 0), !0) : e } s = this.castInput(s), c = this.castInput(c), s = this.removeEmpty(this.tokenize(s)); var d = (c = this.removeEmpty(this.tokenize(c))).length, m = s.length, f = 1, r = d + m, D = [{ newPos: -1, components: [] }], a = this.extractCommon(D[0], c, s, 0); if (D[0].newPos + 1 >= d && m <= a + 1) return p([{ value: this.join(c), count: c.length }]); function u() { for (var e = -1 * f; e <= f; e += 2) { var t = void 0, n = D[e - 1], r = D[e + 1], a = (r ? r.newPos : 0) - e; n && (D[e - 1] = void 0); var u = n && n.newPos + 1 < d, o = r && 0 <= a && a < m; if (u || o) { if (!u || o && n.newPos < r.newPos ? (t = { newPos: (i = r).newPos, components: i.components.slice(0) }, l.pushComponent(t.components, void 0, !0)) : ((t = n).newPos++ , l.pushComponent(t.components, !0, void 0)), a = l.extractCommon(t, c, s, e), t.newPos + 1 >= d && m <= a + 1) return p(g(l, t.components, c, s, l.useLongestToken)); D[e] = t } else D[e] = void 0 } var i; f++ } if (n) !function e() { setTimeout(function () { if (r < f) return n(); u() || e() }, 0) }(); else for (; f <= r;) { var o = u(); if (o) return o } }, pushComponent: function (e, t, n) { var r = e[e.length - 1]; r && r.added === t && r.removed === n ? e[e.length - 1] = { count: r.count + 1, added: t, removed: n } : e.push({ count: 1, added: t, removed: n }) }, extractCommon: function (e, t, n, r) { for (var a = t.length, u = n.length, o = e.newPos, i = o - r, s = 0; o + 1 < a && i + 1 < u && this.equals(t[o + 1], n[i + 1]);)o++ , i++ , s++; return s && e.components.push({ count: s }), e.newPos = o, i }, equals: function (e, t) { return e === t }, removeEmpty: function (e) { for (var t = [], n = 0; n < e.length; n++)e[n] && t.push(e[n]); return t }, castInput: function (e) { return e }, tokenize: function (e) { return e.split("") }, join: function (e) { return e.join("") } } }); unwrapExports(base); var character = createCommonjsModule(function (e, t) { t.__esModule = !0, t.characterDiff = void 0, t.diffChars = function (e, t, n) { return a.diff(e, t, n) }; var n, r = (n = base) && n.__esModule ? n : { default: n }; var a = t.characterDiff = new r.default }); unwrapExports(character); var params = createCommonjsModule(function (e, t) { t.__esModule = !0, t.generateOptions = function (e, t) { if ("function" == typeof e) t.callback = e; else if (e) for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]); return t } }); unwrapExports(params); var word = createCommonjsModule(function (e, t) { t.__esModule = !0, t.wordDiff = void 0, t.diffWords = function (e, t, n) { var r = (0, params.generateOptions)(n, { ignoreWhitespace: !0 }); return o.diff(e, t, r) }, t.diffWordsWithSpace = function (e, t, n) { return o.diff(e, t, n) }; var n, r = (n = base) && n.__esModule ? n : { default: n }; var a = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/, u = /\S/, o = t.wordDiff = new r.default; o.equals = function (e, t) { return e === t || this.options.ignoreWhitespace && !u.test(e) && !u.test(t) }, o.tokenize = function (e) { for (var t = e.split(/(\s+|\b)/), n = 0; n < t.length - 1; n++)!t[n + 1] && t[n + 2] && a.test(t[n]) && a.test(t[n + 2]) && (t[n] += t[n + 2], t.splice(n + 1, 2), n--); return t } }); unwrapExports(word); var line = createCommonjsModule(function (e, t) { t.__esModule = !0, t.lineDiff = void 0, t.diffLines = function (e, t, n) { return a.diff(e, t, n) }, t.diffTrimmedLines = function (e, t, n) { var r = (0, params.generateOptions)(n, { ignoreWhitespace: !0 }); return a.diff(e, t, r) }; var n, r = (n = base) && n.__esModule ? n : { default: n }; var a = t.lineDiff = new r.default; a.tokenize = function (e) { var t = [], n = e.split(/(\n|\r\n)/); n[n.length - 1] || n.pop(); for (var r = 0; r < n.length; r++) { var a = n[r]; r % 2 && !this.options.newlineIsToken ? t[t.length - 1] += a : (this.options.ignoreWhitespace && (a = a.trim()), t.push(a)) } return t } }); unwrapExports(line); var sentence = createCommonjsModule(function (e, t) { t.__esModule = !0, t.sentenceDiff = void 0, t.diffSentences = function (e, t, n) { return a.diff(e, t, n) }; var n, r = (n = base) && n.__esModule ? n : { default: n }; var a = t.sentenceDiff = new r.default; a.tokenize = function (e) { return e.split(/(\S.+?[.!?])(?=\s+|$)/) } }); unwrapExports(sentence); var css = createCommonjsModule(function (e, t) { t.__esModule = !0, t.cssDiff = void 0, t.diffCss = function (e, t, n) { return a.diff(e, t, n) }; var n, r = (n = base) && n.__esModule ? n : { default: n }; var a = t.cssDiff = new r.default; a.tokenize = function (e) { return e.split(/([{}:;,]|\s+)/) } }); function _typeof(e) { return (_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e })(e) } function _classCallCheck(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") } function _defineProperty(e, t, n) { return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e } function _inherits(e, t) { if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function"); e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && _setPrototypeOf(e, t) } function _getPrototypeOf(e) { return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) { return e.__proto__ || Object.getPrototypeOf(e) })(e) } function _setPrototypeOf(e, t) { return (_setPrototypeOf = Object.setPrototypeOf || function (e, t) { return e.__proto__ = t, e })(e, t) } function isNativeReflectConstruct() { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], function () { })), !0 } catch (e) { return !1 } } function _construct(e, t, n) { return (_construct = isNativeReflectConstruct() ? Reflect.construct : function (e, t, n) { var r = [null]; r.push.apply(r, t); var a = new (Function.bind.apply(e, r)); return n && _setPrototypeOf(a, n.prototype), a }).apply(null, arguments) } function _wrapNativeSuper(e) { var n = "function" == typeof Map ? new Map : void 0; return (_wrapNativeSuper = function (e) { if (null === e) return null; if ("function" != typeof e) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== n) { if (n.has(e)) return n.get(e); n.set(e, t) } function t() { return _construct(e, arguments, _getPrototypeOf(this).constructor) } return t.prototype = Object.create(e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(t, e) })(e) } function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e } function _possibleConstructorReturn(e, t) { return !t || "object" != typeof t && "function" != typeof t ? _assertThisInitialized(e) : t } function _taggedTemplateLiteral(e, t) { return t = t || e.slice(0), Object.freeze(Object.defineProperties(e, { raw: { value: Object.freeze(t) } })) } function _slicedToArray(e, t) { return _arrayWithHoles(e) || _iterableToArrayLimit(e, t) || _nonIterableRest() } function _arrayWithHoles(e) { if (Array.isArray(e)) return e } function _iterableToArrayLimit(e, t) { var n = [], r = !0, a = !1, u = void 0; try { for (var o, i = e[Symbol.iterator](); !(r = (o = i.next()).done) && (n.push(o.value), !t || n.length !== t); r = !0); } catch (e) { a = !0, u = e } finally { try { r || null == i.return || i.return() } finally { if (a) throw u } } return n } function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance") } unwrapExports(css); var json = createCommonjsModule(function (e, t) { t.__esModule = !0, t.jsonDiff = void 0; var i = "function" == typeof Symbol && "symbol" === _typeof(Symbol.iterator) ? function (e) { return _typeof(e) } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol ? "symbol" : _typeof(e) }; t.diffJson = function (e, t, n) { return a.diff(e, t, n) }, t.canonicalize = c; var n, r = (n = base) && n.__esModule ? n : { default: n }; var s = Object.prototype.toString, a = t.jsonDiff = new r.default; function c(e, t, n) { t = t || [], n = n || []; var r = void 0; for (r = 0; r < t.length; r += 1)if (t[r] === e) return n[r]; var a = void 0; if ("[object Array]" === s.call(e)) { for (t.push(e), a = new Array(e.length), n.push(a), r = 0; r < e.length; r += 1)a[r] = c(e[r], t, n); return t.pop(), n.pop(), a } if (e && e.toJSON && (e = e.toJSON()), "object" === (void 0 === e ? "undefined" : i(e)) && null !== e) { t.push(e), a = {}, n.push(a); var u = [], o = void 0; for (o in e) e.hasOwnProperty(o) && u.push(o); for (u.sort(), r = 0; r < u.length; r += 1)a[o = u[r]] = c(e[o], t, n); t.pop(), n.pop() } else a = e; return a } a.useLongestToken = !0, a.tokenize = line.lineDiff.tokenize, a.castInput = function (e) { var n = this.options.undefinedReplacement; return "string" == typeof e ? e : JSON.stringify(c(e), function (e, t) { return void 0 === t ? n : t }, "  ") }, a.equals = function (e, t) { return r.default.prototype.equals(e.replace(/,([\r\n])/g, "$1"), t.replace(/,([\r\n])/g, "$1")) } }); unwrapExports(json); var array = createCommonjsModule(function (e, t) { t.__esModule = !0, t.arrayDiff = void 0, t.diffArrays = function (e, t, n) { return a.diff(e, t, n) }; var n, r = (n = base) && n.__esModule ? n : { default: n }; var a = t.arrayDiff = new r.default; a.tokenize = a.join = function (e) { return e.slice() } }); unwrapExports(array); var parse = createCommonjsModule(function (e, t) { t.__esModule = !0, t.parsePatch = function (e) { var o = arguments.length <= 1 || void 0 === arguments[1] ? {} : arguments[1], i = e.split(/\r\n|[\n\v\f\r\x85]/), s = e.match(/\r\n|[\n\v\f\r\x85]/g) || [], a = [], c = 0; function t() { var e = {}; for (a.push(e); c < i.length;) { var t = i[c]; if (/^(\-\-\-|\+\+\+|@@)\s/.test(t)) break; var n = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(t); n && (e.index = n[1]), c++ } for (u(e), u(e), e.hunks = []; c < i.length;) { var r = i[c]; if (/^(Index:|diff|\-\-\-|\+\+\+)\s/.test(r)) break; if (/^@@/.test(r)) e.hunks.push(l()); else { if (r && o.strict) throw new Error("Unknown line " + (c + 1) + " " + JSON.stringify(r)); c++ } } } function u(e) { var t = /^(---|\+\+\+)\s+([\S ]*)(?:\t(.*?)\s*)?$/.exec(i[c]); if (t) { var n = "---" === t[1] ? "old" : "new"; e[n + "FileName"] = t[2], e[n + "Header"] = t[3], c++ } } function l() { for (var e = c, t = i[c++].split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/), n = { oldStart: +t[1], oldLines: +t[2] || 1, newStart: +t[3], newLines: +t[4] || 1, lines: [], linedelimiters: [] }, r = 0, a = 0; c < i.length && !(0 === i[c].indexOf("--- ") && c + 2 < i.length && 0 === i[c + 1].indexOf("+++ ") && 0 === i[c + 2].indexOf("@@")); c++) { var u = i[c][0]; if ("+" !== u && "-" !== u && " " !== u && "\\" !== u) break; n.lines.push(i[c]), n.linedelimiters.push(s[c] || "\n"), "+" === u ? r++ : "-" === u ? a++ : " " === u && (r++ , a++) } if (r || 1 !== n.newLines || (n.newLines = 0), a || 1 !== n.oldLines || (n.oldLines = 0), o.strict) { if (r !== n.newLines) throw new Error("Added line count did not match for hunk at line " + (e + 1)); if (a !== n.oldLines) throw new Error("Removed line count did not match for hunk at line " + (e + 1)) } return n } for (; c < i.length;)t(); return a } }); unwrapExports(parse); var distanceIterator = createCommonjsModule(function (e, t) { t.__esModule = !0, t.default = function (t, n, r) { var a = !0, u = !1, o = !1, i = 1; return function e() { if (a && !o) { if (u ? i++ : a = !1, t + i <= r) return i; o = !0 } if (!u) return o || (a = !0), n <= t - i ? -i++ : (u = !0, e()) } } }); unwrapExports(distanceIterator); var apply = createCommonjsModule(function (e, t) { t.__esModule = !0, t.applyPatch = o, t.applyPatches = function (e, u) { "string" == typeof e && (e = (0, parse.parsePatch)(e)); var t = 0; !function r() { var a = e[t++]; if (!a) return u.complete(); u.loadFile(a, function (e, t) { if (e) return u.complete(e); var n = o(t, a, u); u.patched(a, n, function (e) { if (e) return u.complete(e); r() }) }) }() }; var n, N = (n = distanceIterator) && n.__esModule ? n : { default: n }; function o(e, t) { var n = arguments.length <= 2 || void 0 === arguments[2] ? {} : arguments[2]; if ("string" == typeof t && (t = (0, parse.parsePatch)(t)), Array.isArray(t)) { if (1 < t.length) throw new Error("applyPatch only works with a single input."); t = t[0] } var o = e.split(/\r\n|[\n\v\f\r\x85]/), r = e.match(/\r\n|[\n\v\f\r\x85]/g) || [], a = t.hunks, i = n.compareLine || function (e, t, n, r) { return t === r }, s = 0, c = n.fuzzFactor || 0, u = 0, l = 0, p = void 0, d = void 0; function m(e, t) { for (var n = 0; n < e.lines.length; n++) { var r = e.lines[n], a = r[0], u = r.substr(1); if (" " === a || "-" === a) { if (!i(t + 1, o[t], a, u) && c < ++s) return !1; t++ } } return !0 } for (var f = 0; f < a.length; f++) { for (var D = a[f], g = o.length - D.oldLines, h = 0, y = l + D.oldStart - 1, C = (0, N.default)(y, u, g); void 0 !== h; h = C())if (m(D, y + h)) { D.offset = l += h; break } if (void 0 === h) return !1; u = D.offset + D.oldStart + D.oldLines } for (var $ = 0; $ < a.length; $++) { var E = a[$], A = E.offset + E.newStart - 1; 0 == E.newLines && A++; for (var v = 0; v < E.lines.length; v++) { var F = E.lines[v], b = F[0], x = F.substr(1), S = E.linedelimiters[v]; if (" " === b) A++; else if ("-" === b) o.splice(A, 1), r.splice(A, 1); else if ("+" === b) o.splice(A, 0, x), r.splice(A, 0, S), A++; else if ("\\" === b) { var B = E.lines[v - 1] ? E.lines[v - 1][0] : null; "+" === B ? p = !0 : "-" === B && (d = !0) } } } if (p) for (; !o[o.length - 1];)o.pop(), r.pop(); else d && (o.push(""), r.push("\n")); for (var T = 0; T < o.length - 1; T++)o[T] = o[T] + r[T]; return o.join("") } }); unwrapExports(apply); var create = createCommonjsModule(function (e, t) { function A(e) { if (Array.isArray(e)) { for (var t = 0, n = Array(e.length); t < e.length; t++)n[t] = e[t]; return n } return Array.from(e) } function p(e, t, p, d, n, r, m) { void 0 === (m = m || {}).context && (m.context = 4); var f = (0, line.diffLines)(p, d, m); function D(e) { return e.map(function (e) { return " " + e }) } f.push({ value: "", lines: [] }); for (var g = [], h = 0, y = 0, C = [], $ = 1, E = 1, a = function (e) { var t = f[e], n = t.lines || t.value.replace(/\n$/, "").split("\n"); if (t.lines = n, t.added || t.removed) { var r; if (!h) { var a = f[e - 1]; h = $, y = E, a && (C = 0 < m.context ? D(a.lines.slice(-m.context)) : [], h -= C.length, y -= C.length) } (r = C).push.apply(r, A(n.map(function (e) { return (t.added ? "+" : "-") + e }))), t.added ? E += n.length : $ += n.length } else { if (h) if (n.length <= 2 * m.context && e < f.length - 2) { var u; (u = C).push.apply(u, A(D(n))) } else { var o, i = Math.min(n.length, m.context); (o = C).push.apply(o, A(D(n.slice(0, i)))); var s = { oldStart: h, oldLines: $ - h + i, newStart: y, newLines: E - y + i, lines: C }; if (e >= f.length - 2 && n.length <= m.context) { var c = /\n$/.test(p), l = /\n$/.test(d); 0 != n.length || c ? c && l || C.push("\\ No newline at end of file") : C.splice(s.oldLines, 0, "\\ No newline at end of file") } g.push(s), y = h = 0, C = [] } $ += n.length, E += n.length } }, u = 0; u < f.length; u++)a(u); return { oldFileName: e, newFileName: t, oldHeader: n, newHeader: r, hunks: g } } function o(e, t, n, r, a, u, o) { var i = p(e, t, n, r, a, u, o), s = []; e == t && s.push("Index: " + e), s.push("==================================================================="), s.push("--- " + i.oldFileName + (void 0 === i.oldHeader ? "" : "\t" + i.oldHeader)), s.push("+++ " + i.newFileName + (void 0 === i.newHeader ? "" : "\t" + i.newHeader)); for (var c = 0; c < i.hunks.length; c++) { var l = i.hunks[c]; s.push("@@ -" + l.oldStart + "," + l.oldLines + " +" + l.newStart + "," + l.newLines + " @@"), s.push.apply(s, l.lines) } return s.join("\n") + "\n" } t.__esModule = !0, t.structuredPatch = p, t.createTwoFilesPatch = o, t.createPatch = function (e, t, n, r, a, u) { return o(e, e, t, n, r, a, u) } }); unwrapExports(create); var dmp = createCommonjsModule(function (e, t) { t.__esModule = !0, t.convertChangesToDMP = function (e) { for (var t = [], n = void 0, r = void 0, a = 0; a < e.length; a++)n = e[a], r = n.added ? 1 : n.removed ? -1 : 0, t.push([r, n.value]); return t } }); unwrapExports(dmp); var xml = createCommonjsModule(function (e, t) { function a(e) { var t = e; return t = (t = (t = (t = t.replace(/&/g, "&amp;")).replace(/</g, "&lt;")).replace(/>/g, "&gt;")).replace(/"/g, "&quot;") } t.__esModule = !0, t.convertChangesToXML = function (e) { for (var t = [], n = 0; n < e.length; n++) { var r = e[n]; r.added ? t.push("<ins>") : r.removed && t.push("<del>"), t.push(a(r.value)), r.added ? t.push("</ins>") : r.removed && t.push("</del>") } return t.join("") } }); unwrapExports(xml); var lib = createCommonjsModule(function (e, t) { t.__esModule = !0, t.canonicalize = t.convertChangesToXML = t.convertChangesToDMP = t.parsePatch = t.applyPatches = t.applyPatch = t.createPatch = t.createTwoFilesPatch = t.structuredPatch = t.diffArrays = t.diffJson = t.diffCss = t.diffSentences = t.diffTrimmedLines = t.diffLines = t.diffWordsWithSpace = t.diffWords = t.diffChars = t.Diff = void 0; var n, r = (n = base) && n.__esModule ? n : { default: n }; t.Diff = r.default, t.diffChars = character.diffChars, t.diffWords = word.diffWords, t.diffWordsWithSpace = word.diffWordsWithSpace, t.diffLines = line.diffLines, t.diffTrimmedLines = line.diffTrimmedLines, t.diffSentences = sentence.diffSentences, t.diffCss = css.diffCss, t.diffJson = json.diffJson, t.diffArrays = array.diffArrays, t.structuredPatch = create.structuredPatch, t.createTwoFilesPatch = create.createTwoFilesPatch, t.createPatch = create.createPatch, t.applyPatch = apply.applyPatch, t.applyPatches = apply.applyPatches, t.parsePatch = parse.parsePatch, t.convertChangesToDMP = dmp.convertChangesToDMP, t.convertChangesToXML = xml.convertChangesToXML, t.canonicalize = json.canonicalize }); unwrapExports(lib); var ConfigError = function () { function e() { return _classCallCheck(this, e), _possibleConstructorReturn(this, _getPrototypeOf(e).apply(this, arguments)) } return _inherits(e, _wrapNativeSuper(Error)), e }(), DebugError = function () { function e() { return _classCallCheck(this, e), _possibleConstructorReturn(this, _getPrototypeOf(e).apply(this, arguments)) } return _inherits(e, _wrapNativeSuper(Error)), e }(), UndefinedParserError$1 = function () { function e() { return _classCallCheck(this, e), _possibleConstructorReturn(this, _getPrototypeOf(e).apply(this, arguments)) } return _inherits(e, _wrapNativeSuper(Error)), e }(), errors = { ConfigError: ConfigError, DebugError: DebugError, UndefinedParserError: UndefinedParserError$1 }, global$1 = "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}; function defaultSetTimout() { throw new Error("setTimeout has not been defined") } function defaultClearTimeout() { throw new Error("clearTimeout has not been defined") } var cachedSetTimeout = defaultSetTimout, cachedClearTimeout = defaultClearTimeout; function runTimeout(t) { if (cachedSetTimeout === setTimeout) return setTimeout(t, 0); if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) return cachedSetTimeout = setTimeout, setTimeout(t, 0); try { return cachedSetTimeout(t, 0) } catch (e) { try { return cachedSetTimeout.call(null, t, 0) } catch (e) { return cachedSetTimeout.call(this, t, 0) } } } function runClearTimeout(t) { if (cachedClearTimeout === clearTimeout) return clearTimeout(t); if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) return cachedClearTimeout = clearTimeout, clearTimeout(t); try { return cachedClearTimeout(t) } catch (e) { try { return cachedClearTimeout.call(null, t) } catch (e) { return cachedClearTimeout.call(this, t) } } } "function" == typeof global$1.setTimeout && (cachedSetTimeout = setTimeout), "function" == typeof global$1.clearTimeout && (cachedClearTimeout = clearTimeout); var queue = [], draining = !1, currentQueue, queueIndex = -1; function cleanUpNextTick() { draining && currentQueue && (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, queue.length && drainQueue()) } function drainQueue() { if (!draining) { var e = runTimeout(cleanUpNextTick); draining = !0; for (var t = queue.length; t;) { for (currentQueue = queue, queue = []; ++queueIndex < t;)currentQueue && currentQueue[queueIndex].run(); queueIndex = -1, t = queue.length } currentQueue = null, draining = !1, runClearTimeout(e) } } function nextTick(e) { var t = new Array(arguments.length - 1); if (1 < arguments.length) for (var n = 1; n < arguments.length; n++)t[n - 1] = arguments[n]; queue.push(new Item(e, t)), 1 !== queue.length || draining || runTimeout(drainQueue) } function Item(e, t) { this.fun = e, this.array = t } Item.prototype.run = function () { this.fun.apply(null, this.array) }; var title = "browser", platform = "browser", browser = !0, env = {}, argv = [], version$2 = "", versions = {}, release = {}, config = {}; function noop() { } var on = noop, addListener = noop, once = noop, off = noop, removeListener = noop, removeAllListeners = noop, emit = noop; function binding(e) { throw new Error("process.binding is not supported") } function cwd() { return "/" } function chdir(e) { throw new Error("process.chdir is not supported") } function umask() { return 0 } var performance = global$1.performance || {}, performanceNow = performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow || function () { return (new Date).getTime() }; function hrtime(e) { var t = .001 * performanceNow.call(performance), n = Math.floor(t), r = Math.floor(t % 1 * 1e9); return e && (n -= e[0], (r -= e[1]) < 0 && (n-- , r += 1e9)), [n, r] } var startTime = new Date; function uptime() { return (new Date - startTime) / 1e3 } var process = { nextTick: nextTick, title: title, browser: browser, env: env, argv: argv, version: version$2, versions: versions, on: on, addListener: addListener, once: once, off: off, removeListener: removeListener, removeAllListeners: removeAllListeners, emit: emit, binding: binding, cwd: cwd, chdir: chdir, umask: umask, hrtime: hrtime, platform: platform, release: release, config: config, uptime: uptime }, semver = createCommonjsModule(function (e, r) { var l; r = e.exports = U, l = "object" === _typeof(process) && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? function () { var e = Array.prototype.slice.call(arguments, 0); e.unshift("SEMVER"), console.log.apply(console, e) } : function () { }, r.SEMVER_SPEC_VERSION = "2.0.0"; var a = 256, u = Number.MAX_SAFE_INTEGER || 9007199254740991, i = r.re = [], t = r.src = [], n = 0, o = n++; t[o] = "0|[1-9]\\d*"; var s = n++; t[s] = "[0-9]+"; var c = n++; t[c] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*"; var p = n++; t[p] = "(" + t[o] + ")\\.(" + t[o] + ")\\.(" + t[o] + ")"; var d = n++; t[d] = "(" + t[s] + ")\\.(" + t[s] + ")\\.(" + t[s] + ")"; var m = n++; t[m] = "(?:" + t[o] + "|" + t[c] + ")"; var f = n++; t[f] = "(?:" + t[s] + "|" + t[c] + ")"; var D = n++; t[D] = "(?:-(" + t[m] + "(?:\\." + t[m] + ")*))"; var g = n++; t[g] = "(?:-?(" + t[f] + "(?:\\." + t[f] + ")*))"; var h = n++; t[h] = "[0-9A-Za-z-]+"; var y = n++; t[y] = "(?:\\+(" + t[h] + "(?:\\." + t[h] + ")*))"; var C = n++, $ = "v?" + t[p] + t[D] + "?" + t[y] + "?"; t[C] = "^" + $ + "$"; var E = "[v=\\s]*" + t[d] + t[g] + "?" + t[y] + "?", A = n++; t[A] = "^" + E + "$"; var v = n++; t[v] = "((?:<|>)?=?)"; var F = n++; t[F] = t[s] + "|x|X|\\*"; var b = n++; t[b] = t[o] + "|x|X|\\*"; var x = n++; t[x] = "[v=\\s]*(" + t[b] + ")(?:\\.(" + t[b] + ")(?:\\.(" + t[b] + ")(?:" + t[D] + ")?" + t[y] + "?)?)?"; var S = n++; t[S] = "[v=\\s]*(" + t[F] + ")(?:\\.(" + t[F] + ")(?:\\.(" + t[F] + ")(?:" + t[g] + ")?" + t[y] + "?)?)?"; var B = n++; t[B] = "^" + t[v] + "\\s*" + t[x] + "$"; var T = n++; t[T] = "^" + t[v] + "\\s*" + t[S] + "$"; var N = n++; t[N] = "(?:~>?)"; var w = n++; t[w] = "(\\s*)" + t[N] + "\\s+", i[w] = new RegExp(t[w], "g"); var P = n++; t[P] = "^" + t[N] + t[x] + "$"; var k = n++; t[k] = "^" + t[N] + t[S] + "$"; var O = n++; t[O] = "(?:\\^)"; var j = n++; t[j] = "(\\s*)" + t[O] + "\\s+", i[j] = new RegExp(t[j], "g"); var L = n++; t[L] = "^" + t[O] + t[x] + "$"; var _ = n++; t[_] = "^" + t[O] + t[S] + "$"; var M = n++; t[M] = "^" + t[v] + "\\s*(" + E + ")$|^$"; var I = n++; t[I] = "^" + t[v] + "\\s*(" + $ + ")$|^$"; var R = n++; t[R] = "(\\s*)" + t[v] + "\\s*(" + E + "|" + t[x] + ")", i[R] = new RegExp(t[R], "g"); var q = n++; t[q] = "^\\s*(" + t[x] + ")\\s+-\\s+(" + t[x] + ")\\s*$"; var V = n++; t[V] = "^\\s*(" + t[S] + ")\\s+-\\s+(" + t[S] + ")\\s*$"; var W = n++; t[W] = "(<|>)?=?\\s*\\*"; for (var J = 0; J < 34; J++)l(J, t[J]), i[J] || (i[J] = new RegExp(t[J])); function G(e, t) { if (e instanceof U) return e; if ("string" != typeof e) return null; if (e.length > a) return null; if (!(t ? i[A] : i[C]).test(e)) return null; try { return new U(e, t) } catch (e) { return null } } function U(e, t) { if (e instanceof U) { if (e.loose === t) return e; e = e.version } else if ("string" != typeof e) throw new TypeError("Invalid Version: " + e); if (e.length > a) throw new TypeError("version is longer than " + a + " characters"); if (!(this instanceof U)) return new U(e, t); l("SemVer", e, t), this.loose = t; var n = e.trim().match(t ? i[A] : i[C]); if (!n) throw new TypeError("Invalid Version: " + e); if (this.raw = e, this.major = +n[1], this.minor = +n[2], this.patch = +n[3], this.major > u || this.major < 0) throw new TypeError("Invalid major version"); if (this.minor > u || this.minor < 0) throw new TypeError("Invalid minor version"); if (this.patch > u || this.patch < 0) throw new TypeError("Invalid patch version"); n[4] ? this.prerelease = n[4].split(".").map(function (e) { if (/^[0-9]+$/.test(e)) { var t = +e; if (0 <= t && t < u) return t } return e }) : this.prerelease = [], this.build = n[5] ? n[5].split(".") : [], this.format() } r.parse = G, r.valid = function (e, t) { var n = G(e, t); return n ? n.version : null }, r.clean = function (e, t) { var n = G(e.trim().replace(/^[=v]+/, ""), t); return n ? n.version : null }, (r.SemVer = U).prototype.format = function () { return this.version = this.major + "." + this.minor + "." + this.patch, this.prerelease.length && (this.version += "-" + this.prerelease.join(".")), this.version }, U.prototype.toString = function () { return this.version }, U.prototype.compare = function (e) { return l("SemVer.compare", this.version, this.loose, e), e instanceof U || (e = new U(e, this.loose)), this.compareMain(e) || this.comparePre(e) }, U.prototype.compareMain = function (e) { return e instanceof U || (e = new U(e, this.loose)), X(this.major, e.major) || X(this.minor, e.minor) || X(this.patch, e.patch) }, U.prototype.comparePre = function (e) { if (e instanceof U || (e = new U(e, this.loose)), this.prerelease.length && !e.prerelease.length) return -1; if (!this.prerelease.length && e.prerelease.length) return 1; if (!this.prerelease.length && !e.prerelease.length) return 0; var t = 0; do { var n = this.prerelease[t], r = e.prerelease[t]; if (l("prerelease compare", t, n, r), void 0 === n && void 0 === r) return 0; if (void 0 === r) return 1; if (void 0 === n) return -1; if (n !== r) return X(n, r) } while (++t) }, U.prototype.inc = function (e, t) { switch (e) { case "premajor": this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++ , this.inc("pre", t); break; case "preminor": this.prerelease.length = 0, this.patch = 0, this.minor++ , this.inc("pre", t); break; case "prepatch": this.prerelease.length = 0, this.inc("patch", t), this.inc("pre", t); break; case "prerelease": 0 === this.prerelease.length && this.inc("patch", t), this.inc("pre", t); break; case "major": 0 === this.minor && 0 === this.patch && 0 !== this.prerelease.length || this.major++ , this.minor = 0, this.patch = 0, this.prerelease = []; break; case "minor": 0 === this.patch && 0 !== this.prerelease.length || this.minor++ , this.patch = 0, this.prerelease = []; break; case "patch": 0 === this.prerelease.length && this.patch++ , this.prerelease = []; break; case "pre": if (0 === this.prerelease.length) this.prerelease = [0]; else { for (var n = this.prerelease.length; 0 <= --n;)"number" == typeof this.prerelease[n] && (this.prerelease[n]++ , n = -2); -1 === n && this.prerelease.push(0) } t && (this.prerelease[0] === t ? isNaN(this.prerelease[1]) && (this.prerelease = [t, 0]) : this.prerelease = [t, 0]); break; default: throw new Error("invalid increment argument: " + e) }return this.format(), this.raw = this.version, this }, r.inc = function (e, t, n, r) { "string" == typeof n && (r = n, n = void 0); try { return new U(e, n).inc(t, r).version } catch (e) { return null } }, r.diff = function (e, t) { { if (Q(e, t)) return null; var n = G(e), r = G(t); if (n.prerelease.length || r.prerelease.length) { for (var a in n) if (("major" === a || "minor" === a || "patch" === a) && n[a] !== r[a]) return "pre" + a; return "prerelease" } for (var a in n) if (("major" === a || "minor" === a || "patch" === a) && n[a] !== r[a]) return a } }, r.compareIdentifiers = X; var K = /^[0-9]+$/; function X(e, t) { var n = K.test(e), r = K.test(t); return n && r && (e = +e, t = +t), n && !r ? -1 : r && !n ? 1 : e < t ? -1 : t < e ? 1 : 0 } function z(e, t, n) { return new U(e, n).compare(new U(t, n)) } function H(e, t, n) { return 0 < z(e, t, n) } function Y(e, t, n) { return z(e, t, n) < 0 } function Q(e, t, n) { return 0 === z(e, t, n) } function Z(e, t, n) { return 0 !== z(e, t, n) } function ee(e, t, n) { return 0 <= z(e, t, n) } function te(e, t, n) { return z(e, t, n) <= 0 } function ne(e, t, n, r) { var a; switch (t) { case "===": "object" === _typeof(e) && (e = e.version), "object" === _typeof(n) && (n = n.version), a = e === n; break; case "!==": "object" === _typeof(e) && (e = e.version), "object" === _typeof(n) && (n = n.version), a = e !== n; break; case "": case "=": case "==": a = Q(e, n, r); break; case "!=": a = Z(e, n, r); break; case ">": a = H(e, n, r); break; case ">=": a = ee(e, n, r); break; case "<": a = Y(e, n, r); break; case "<=": a = te(e, n, r); break; default: throw new TypeError("Invalid operator: " + t) }return a } function re(e, t) { if (e instanceof re) { if (e.loose === t) return e; e = e.value } if (!(this instanceof re)) return new re(e, t); l("comparator", e, t), this.loose = t, this.parse(e), this.semver === ae ? this.value = "" : this.value = this.operator + this.semver.version, l("comp", this) } r.rcompareIdentifiers = function (e, t) { return X(t, e) }, r.major = function (e, t) { return new U(e, t).major }, r.minor = function (e, t) { return new U(e, t).minor }, r.patch = function (e, t) { return new U(e, t).patch }, r.compare = z, r.compareLoose = function (e, t) { return z(e, t, !0) }, r.rcompare = function (e, t, n) { return z(t, e, n) }, r.sort = function (e, n) { return e.sort(function (e, t) { return r.compare(e, t, n) }) }, r.rsort = function (e, n) { return e.sort(function (e, t) { return r.rcompare(e, t, n) }) }, r.gt = H, r.lt = Y, r.eq = Q, r.neq = Z, r.gte = ee, r.lte = te, r.cmp = ne, r.Comparator = re; var ae = {}; function ue(e, t) { if (e instanceof ue) return e.loose === t ? e : new ue(e.raw, t); if (e instanceof re) return new ue(e.value, t); if (!(this instanceof ue)) return new ue(e, t); if (this.loose = t, this.raw = e, this.set = e.split(/\s*\|\|\s*/).map(function (e) { return this.parseRange(e.trim()) }, this).filter(function (e) { return e.length }), !this.set.length) throw new TypeError("Invalid SemVer Range: " + e); this.format() } function oe(e) { return !e || "x" === e.toLowerCase() || "*" === e } function ie(e, t, n, r, a, u, o, i, s, c, l, p, d) { return ((t = oe(n) ? "" : oe(r) ? ">=" + n + ".0.0" : oe(a) ? ">=" + n + "." + r + ".0" : ">=" + t) + " " + (i = oe(s) ? "" : oe(c) ? "<" + (+s + 1) + ".0.0" : oe(l) ? "<" + s + "." + (+c + 1) + ".0" : p ? "<=" + s + "." + c + "." + l + "-" + p : "<=" + i)).trim() } function se(e, t) { for (var n = 0; n < e.length; n++)if (!e[n].test(t)) return !1; if (t.prerelease.length) { for (n = 0; n < e.length; n++)if (l(e[n].semver), e[n].semver !== ae && 0 < e[n].semver.prerelease.length) { var r = e[n].semver; if (r.major === t.major && r.minor === t.minor && r.patch === t.patch) return !0 } return !1 } return !0 } function ce(e, t, n) { try { t = new ue(t, n) } catch (e) { return !1 } return t.test(e) } function le(e, t, n, r) { var a, u, o, i, s; switch (e = new U(e, r), t = new ue(t, r), n) { case ">": a = H, u = te, o = Y, i = ">", s = ">="; break; case "<": a = Y, u = ee, o = H, i = "<", s = "<="; break; default: throw new TypeError('Must provide a hilo val of "<" or ">"') }if (ce(e, t, r)) return !1; for (var c = 0; c < t.set.length; ++c) { var l = t.set[c], p = null, d = null; if (l.forEach(function (e) { e.semver === ae && (e = new re(">=0.0.0")), p = p || e, d = d || e, a(e.semver, p.semver, r) ? p = e : o(e.semver, d.semver, r) && (d = e) }), p.operator === i || p.operator === s) return !1; if ((!d.operator || d.operator === i) && u(e, d.semver)) return !1; if (d.operator === s && o(e, d.semver)) return !1 } return !0 } re.prototype.parse = function (e) { var t = this.loose ? i[M] : i[I], n = e.match(t); if (!n) throw new TypeError("Invalid comparator: " + e); this.operator = n[1], "=" === this.operator && (this.operator = ""), n[2] ? this.semver = new U(n[2], this.loose) : this.semver = ae }, re.prototype.toString = function () { return this.value }, re.prototype.test = function (e) { return l("Comparator.test", e, this.loose), this.semver === ae || ("string" == typeof e && (e = new U(e, this.loose)), ne(e, this.operator, this.semver, this.loose)) }, re.prototype.intersects = function (e, t) { if (!(e instanceof re)) throw new TypeError("a Comparator is required"); var n; if ("" === this.operator) return n = new ue(e.value, t), ce(this.value, n, t); if ("" === e.operator) return n = new ue(this.value, t), ce(e.semver, n, t); var r = !(">=" !== this.operator && ">" !== this.operator || ">=" !== e.operator && ">" !== e.operator), a = !("<=" !== this.operator && "<" !== this.operator || "<=" !== e.operator && "<" !== e.operator), u = this.semver.version === e.semver.version, o = !(">=" !== this.operator && "<=" !== this.operator || ">=" !== e.operator && "<=" !== e.operator), i = ne(this.semver, "<", e.semver, t) && (">=" === this.operator || ">" === this.operator) && ("<=" === e.operator || "<" === e.operator), s = ne(this.semver, ">", e.semver, t) && ("<=" === this.operator || "<" === this.operator) && (">=" === e.operator || ">" === e.operator); return r || a || u && o || i || s }, (r.Range = ue).prototype.format = function () { return this.range = this.set.map(function (e) { return e.join(" ").trim() }).join("||").trim(), this.range }, ue.prototype.toString = function () { return this.range }, ue.prototype.parseRange = function (e) { var t = this.loose; e = e.trim(), l("range", e, t); var n = t ? i[V] : i[q]; e = e.replace(n, ie), l("hyphen replace", e), e = e.replace(i[R], "$1$2$3"), l("comparator trim", e, i[R]), e = (e = (e = e.replace(i[w], "$1~")).replace(i[j], "$1^")).split(/\s+/).join(" "); var r = t ? i[M] : i[I], a = e.split(" ").map(function (e) { return function (e, t) { return l("comp", e), e = function (e, t) { return e.trim().split(/\s+/).map(function (e) { return function (o, e) { l("caret", o, e); var t = e ? i[_] : i[L]; return o.replace(t, function (e, t, n, r, a) { var u; return l("caret", o, e, t, n, r, a), u = oe(t) ? "" : oe(n) ? ">=" + t + ".0.0 <" + (+t + 1) + ".0.0" : oe(r) ? "0" === t ? ">=" + t + "." + n + ".0 <" + t + "." + (+n + 1) + ".0" : ">=" + t + "." + n + ".0 <" + (+t + 1) + ".0.0" : a ? (l("replaceCaret pr", a), "-" !== a.charAt(0) && (a = "-" + a), "0" === t ? "0" === n ? ">=" + t + "." + n + "." + r + a + " <" + t + "." + n + "." + (+r + 1) : ">=" + t + "." + n + "." + r + a + " <" + t + "." + (+n + 1) + ".0" : ">=" + t + "." + n + "." + r + a + " <" + (+t + 1) + ".0.0") : (l("no pr"), "0" === t ? "0" === n ? ">=" + t + "." + n + "." + r + " <" + t + "." + n + "." + (+r + 1) : ">=" + t + "." + n + "." + r + " <" + t + "." + (+n + 1) + ".0" : ">=" + t + "." + n + "." + r + " <" + (+t + 1) + ".0.0"), l("caret return", u), u }) }(e, t) }).join(" ") }(e, t), l("caret", e), e = function (e, t) { return e.trim().split(/\s+/).map(function (e) { return function (o, e) { var t = e ? i[k] : i[P]; return o.replace(t, function (e, t, n, r, a) { var u; return l("tilde", o, e, t, n, r, a), u = oe(t) ? "" : oe(n) ? ">=" + t + ".0.0 <" + (+t + 1) + ".0.0" : oe(r) ? ">=" + t + "." + n + ".0 <" + t + "." + (+n + 1) + ".0" : a ? (l("replaceTilde pr", a), "-" !== a.charAt(0) && (a = "-" + a), ">=" + t + "." + n + "." + r + a + " <" + t + "." + (+n + 1) + ".0") : ">=" + t + "." + n + "." + r + " <" + t + "." + (+n + 1) + ".0", l("tilde return", u), u }) }(e, t) }).join(" ") }(e, t), l("tildes", e), e = function (e, t) { return l("replaceXRanges", e, t), e.split(/\s+/).map(function (e) { return function (c, e) { c = c.trim(); var t = e ? i[T] : i[B]; return c.replace(t, function (e, t, n, r, a, u) { l("xRange", c, e, t, n, r, a, u); var o = oe(n), i = o || oe(r), s = i || oe(a); return "=" === t && s && (t = ""), o ? e = ">" === t || "<" === t ? "<0.0.0" : "*" : t && s ? (i && (r = 0), s && (a = 0), ">" === t ? (t = ">=", i ? (n = +n + 1, a = r = 0) : s && (r = +r + 1, a = 0)) : "<=" === t && (t = "<", i ? n = +n + 1 : r = +r + 1), e = t + n + "." + r + "." + a) : i ? e = ">=" + n + ".0.0 <" + (+n + 1) + ".0.0" : s && (e = ">=" + n + "." + r + ".0 <" + n + "." + (+r + 1) + ".0"), l("xRange return", e), e }) }(e, t) }).join(" ") }(e, t), l("xrange", e), e = function (e, t) { return l("replaceStars", e, t), e.trim().replace(i[W], "") }(e, t), l("stars", e), e }(e, t) }).join(" ").split(/\s+/); return this.loose && (a = a.filter(function (e) { return !!e.match(r) })), a = a.map(function (e) { return new re(e, t) }) }, ue.prototype.intersects = function (n, r) { if (!(n instanceof ue)) throw new TypeError("a Range is required"); return this.set.some(function (e) { return e.every(function (t) { return n.set.some(function (e) { return e.every(function (e) { return t.intersects(e, r) }) }) }) }) }, r.toComparators = function (e, t) { return new ue(e, t).set.map(function (e) { return e.map(function (e) { return e.value }).join(" ").trim().split(" ") }) }, ue.prototype.test = function (e) { if (!e) return !1; "string" == typeof e && (e = new U(e, this.loose)); for (var t = 0; t < this.set.length; t++)if (se(this.set[t], e)) return !0; return !1 }, r.satisfies = ce, r.maxSatisfying = function (e, t, n) { var r = null, a = null; try { var u = new ue(t, n) } catch (e) { return null } return e.forEach(function (e) { u.test(e) && (r && -1 !== a.compare(e) || (a = new U(r = e, n))) }), r }, r.minSatisfying = function (e, t, n) { var r = null, a = null; try { var u = new ue(t, n) } catch (e) { return null } return e.forEach(function (e) { u.test(e) && (r && 1 !== a.compare(e) || (a = new U(r = e, n))) }), r }, r.validRange = function (e, t) { try { return new ue(e, t).range || "*" } catch (e) { return null } }, r.ltr = function (e, t, n) { return le(e, t, "<", n) }, r.gtr = function (e, t, n) { return le(e, t, ">", n) }, r.outside = le, r.prerelease = function (e, t) { var n = G(e, t); return n && n.prerelease.length ? n.prerelease : null }, r.intersects = function (e, t, n) { return e = new ue(e, n), t = new ue(t, n), e.intersects(t) } }), arrayify = function (n, r) { return Object.keys(n).reduce(function (e, t) { return e.concat(Object.assign(_defineProperty({}, r, t), n[t])) }, []) }, dedent_1 = createCommonjsModule(function (e) { e.exports = function (e) { var t = void 0; t = "string" == typeof e ? [e] : e.raw; for (var n = "", r = 0; r < t.length; r++)n += t[r].replace(/\\\n[ \t]*/g, "").replace(/\\`/g, "`"), r < (arguments.length <= 1 ? 0 : arguments.length - 1) && (n += arguments.length <= r + 1 ? void 0 : arguments[r + 1]); var a = n.split("\n"), u = null; return a.forEach(function (e) { var t = e.match(/^(\s+)\S+/); if (t) { var n = t[1].length; u = u ? Math.min(u, n) : n } }), null !== u && (n = a.map(function (e) { return " " === e[0] ? e.slice(u) : e }).join("\n")), (n = n.trim()).replace(/\\n/g, "\n") } }); function _templateObject5() { var e = _taggedTemplateLiteral(["\n      Require either '@prettier' or '@format' to be present in the file's first docblock comment\n      in order for it to be formatted.\n    "]); return _templateObject5 = function () { return e }, e } function _templateObject4() { var e = _taggedTemplateLiteral(["\n      Format code starting at a given character offset.\n      The range will extend backwards to the start of the first line containing the selected statement.\n      This option cannot be used with --cursor-offset.\n    "]); return _templateObject4 = function () { return e }, e } function _templateObject3() { var e = _taggedTemplateLiteral(["\n      Format code ending at a given character offset (exclusive).\n      The range will extend forwards to the end of the selected statement.\n      This option cannot be used with --cursor-offset.\n    "]); return _templateObject3 = function () { return e }, e } function _templateObject2() { var e = _taggedTemplateLiteral(["\n      Custom directory that contains prettier plugins in node_modules subdirectory.\n      Overrides default behavior when plugins are searched relatively to the location of Prettier.\n      Multiple values are accepted.\n    "]); return _templateObject2 = function () { return e }, e } function _templateObject() { var e = _taggedTemplateLiteral(["\n      Print (to stderr) where a cursor at the given position would move to after formatting.\n      This option cannot be used with --range-start and --range-end.\n    "]); return _templateObject = function () { return e }, e } var CATEGORY_CONFIG = "Config", CATEGORY_EDITOR = "Editor", CATEGORY_FORMAT = "Format", CATEGORY_OTHER = "Other", CATEGORY_OUTPUT = "Output", CATEGORY_GLOBAL = "Global", CATEGORY_SPECIAL = "Special", options$2 = { cursorOffset: { since: "1.4.0", category: CATEGORY_SPECIAL, type: "int", default: -1, range: { start: -1, end: 1 / 0, step: 1 }, description: dedent_1(_templateObject()), cliCategory: CATEGORY_EDITOR }, filepath: { since: "1.4.0", category: CATEGORY_SPECIAL, type: "path", default: void 0, description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: CATEGORY_OTHER, cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { since: "1.8.0", category: CATEGORY_SPECIAL, type: "boolean", default: !1, description: "Insert @format pragma into file's first docblock comment.", cliCategory: CATEGORY_OTHER }, parser: { since: "0.0.10", category: CATEGORY_GLOBAL, type: "choice", default: [{ since: "0.0.10", value: "babylon" }, { since: "1.13.0", value: void 0 }], description: "Which parser to use.", exception: function (e) { return "string" == typeof e || "function" == typeof e }, choices: [{ value: "flow", description: "Flow" }, { value: "babylon", description: "JavaScript" }, { value: "typescript", since: "1.4.0", description: "TypeScript" }, { value: "css", since: "1.7.1", description: "CSS" }, { value: "postcss", since: "1.4.0", description: "CSS/Less/SCSS", deprecated: "1.7.1", redirect: "css" }, { value: "less", since: "1.7.1", description: "Less" }, { value: "scss", since: "1.7.1", description: "SCSS" }, { value: "json", since: "1.5.0", description: "JSON" }, { value: "json5", since: "1.13.0", description: "JSON5" }, { value: "json-stringify", since: "1.13.0", description: "JSON.stringify" }, { value: "graphql", since: "1.5.0", description: "GraphQL" }, { value: "markdown", since: "1.8.0", description: "Markdown" }, { value: "vue", since: "1.10.0", description: "Vue" }] }, plugins: { since: "1.10.0", type: "path", array: !0, default: [{ value: [] }], category: CATEGORY_GLOBAL, description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: function (e) { return "string" == typeof e || "object" === _typeof(e) }, cliName: "plugin", cliCategory: CATEGORY_CONFIG }, pluginSearchDirs: { since: "1.13.0", type: "path", array: !0, default: [{ value: [] }], category: CATEGORY_GLOBAL, description: dedent_1(_templateObject2()), exception: function (e) { return "string" == typeof e || "object" === _typeof(e) }, cliName: "plugin-search-dir", cliCategory: CATEGORY_CONFIG }, printWidth: { since: "0.0.0", category: CATEGORY_GLOBAL, type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: 1 / 0, step: 1 } }, rangeEnd: { since: "1.4.0", category: CATEGORY_SPECIAL, type: "int", default: 1 / 0, range: { start: 0, end: 1 / 0, step: 1 }, description: dedent_1(_templateObject3()), cliCategory: CATEGORY_EDITOR }, rangeStart: { since: "1.4.0", category: CATEGORY_SPECIAL, type: "int", default: 0, range: { start: 0, end: 1 / 0, step: 1 }, description: dedent_1(_templateObject4()), cliCategory: CATEGORY_EDITOR }, requirePragma: { since: "1.7.0", category: CATEGORY_SPECIAL, type: "boolean", default: !1, description: dedent_1(_templateObject5()), cliCategory: CATEGORY_OTHER }, tabWidth: { type: "int", category: CATEGORY_GLOBAL, default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: 1 / 0, step: 1 } }, useFlowParser: { since: "0.0.0", category: CATEGORY_GLOBAL, type: "boolean", default: !1, deprecated: "0.0.10", description: "Use flow parser.", redirect: { option: "parser", value: "flow" }, cliName: "flow-parser" }, useTabs: { since: "1.0.0", category: CATEGORY_GLOBAL, type: "boolean", default: !1, description: "Indent with tabs instead of spaces." } }, coreOptions$1 = { CATEGORY_CONFIG: CATEGORY_CONFIG, CATEGORY_EDITOR: CATEGORY_EDITOR, CATEGORY_FORMAT: CATEGORY_FORMAT, CATEGORY_OTHER: CATEGORY_OTHER, CATEGORY_OUTPUT: CATEGORY_OUTPUT, CATEGORY_GLOBAL: CATEGORY_GLOBAL, CATEGORY_SPECIAL: CATEGORY_SPECIAL, options: options$2 }, require$$0 = _package$1 && _package || _package$1, currentVersion = require$$0.version, coreOptions = coreOptions$1.options; function getSupportInfo$2(t, n) { n = Object.assign({ plugins: [], showUnreleased: !1, showDeprecated: !1, showInternal: !1 }, n), t = t || currentVersion; var r = n.plugins, e = arrayify(Object.assign(r.reduce(function (e, t) { return Object.assign(e, t.options) }, {}), coreOptions), "name").sort(function (e, t) { return e.name === t.name ? 0 : e.name < t.name ? -1 : 1 }).filter(u).filter(o).map(i).map(function (e) { if (n.showInternal) return e; var t = Object.assign({}, e); return delete t.cliName, delete t.cliCategory, delete t.cliDescription, t }).map(function (e) { var t = Object.assign({}, e); return Array.isArray(t.default) && (t.default = 1 === t.default.length ? t.default[0].value : t.default.filter(u).sort(function (e, t) { return semver.compare(t.since, e.since) })[0].value), Array.isArray(t.choices) && (t.choices = t.choices.filter(u).filter(o).map(i)), t }).map(function (n) { var e = r.filter(function (e) { return e.defaultOptions && e.defaultOptions[n.name] }).reduce(function (e, t) { return e[t.name] = t.defaultOptions[n.name], e }, {}); return Object.assign(n, { pluginDefaults: e }) }), a = semver.lt(t, "1.7.1"); return { languages: r.reduce(function (e, t) { return e.concat(t.languages || []) }, []).filter(function (e) { return e.since ? semver.gte(t, e.since) : null !== e.since }).map(function (e) { return "Markdown" === e.name ? Object.assign({}, e, { parsers: ["markdown"] }) : "TypeScript" === e.name ? Object.assign({}, e, { parsers: ["typescript"] }) : a && "CSS" === e.group ? Object.assign({}, e, { parsers: ["postcss"] }) : e }), options: e }; function u(e) { return n.showUnreleased || !("since" in e) || e.since && semver.gte(t, e.since) } function o(e) { return n.showDeprecated || !("deprecated" in e) || e.deprecated && semver.lt(t, e.deprecated) } function i(e) { if (!e.deprecated || n.showDeprecated) return e; var t = Object.assign({}, e); return delete t.deprecated, delete t.redirect, t } } var support = { getSupportInfo: getSupportInfo$2 }, arr = [], charCodeCache = [], leven = function (e, t) { if (e === t) return 0; var n = e; e.length > t.length && (e = t, t = n); var r = e.length, a = t.length; if (0 === r) return a; if (0 === a) return r; for (; 0 < r && e.charCodeAt(~-r) === t.charCodeAt(~-a);)r-- , a--; if (0 === r) return a; for (var u, o, i, s, c = 0; c < r && e.charCodeAt(c) === t.charCodeAt(c);)c++; if (a -= c, 0 === (r -= c)) return a; for (var l = 0, p = 0; l < r;)charCodeCache[c + l] = e.charCodeAt(c + l), arr[l] = ++l; for (; p < a;)for (u = t.charCodeAt(c + p), i = p++ , o = p, l = 0; l < r; l++)s = u === charCodeCache[c + l] ? i : i + 1, i = arr[l], o = arr[l] = o < i ? o < s ? o + 1 : s : i < s ? i + 1 : s; return o }; function apiDescriptor(e, t) { return 1 === arguments.length ? JSON.stringify(e) : "`{ ".concat(apiDescriptor(e), ": ").concat(JSON.stringify(t), " }`") } function cliDescriptor(e, t) { return !1 === t ? "`--no-".concat(e, "`") : !0 === t || 1 === arguments.length ? "`--".concat(e, "`") : "" === t ? "`--".concat(e, "` without an argument") : "`--".concat(e, "=").concat(t, "`") } var optionsDescriptor = { apiDescriptor: apiDescriptor, cliDescriptor: cliDescriptor }; function validateOption(t, n, e) { var r = (e = e || {}).descriptor || optionsDescriptor.apiDescriptor; if ("function" != typeof n.exception || !n.exception(t)) try { validateOptionType(t, n) } catch (e) { throw new Error("Invalid `".concat(r(n.name), "` value. ").concat(e.message, ", but received `").concat(JSON.stringify(t), "`.")) } } function validateOptionType(e, t) { if (t.array) { if (!Array.isArray(e)) throw new Error("Expected an array"); e.forEach(function (e) { return validateOptionType(e, Object.assign({}, t, { array: !1 })) }) } else switch (t.type) { case "int": validateIntOption(e); break; case "boolean": validateBooleanOption(e); break; case "choice": validateChoiceOption(e, t.choices) } } function validateBooleanOption(e) { if ("boolean" != typeof e) throw new Error("Expected a boolean") } function validateIntOption(e) { if (!("number" == typeof e && Math.floor(e) === e && 0 <= e && e !== 1 / 0)) throw new Error("Expected an integer") } function validateChoiceOption(t, e) { if (!e.some(function (e) { return e.value === t })) { var n = e.filter(function (e) { return !e.deprecated }).map(function (e) { return JSON.stringify(e.value) }).sort(), r = n.slice(0, -2), a = n.slice(-2); throw new Error("Expected ".concat(r.concat(a.join(" or ")).join(", "))) } } var optionsValidator = { validateOption: validateOption }; function normalizeOptions$1(o, i, e) { var s = !1 === (e = e || {}).logger ? { warn: function () { } } : void 0 !== e.logger ? e.logger : console, c = e.descriptor || optionsDescriptor.apiDescriptor, l = e.passThrough || [], p = i.reduce(function (e, t) { return Object.assign(e, _defineProperty({}, t.name, t)) }, {}); return Object.keys(o).reduce(function (e, t) { var n = p[t], r = t, a = o[t]; if (!n) return !0 === l || -1 !== l.indexOf(r) ? e[r] = a : s.warn(createUnknownOptionMessage(r, a, i, c)), e; if (n.deprecated ? "string" == typeof n.redirect ? (s.warn(createRedirectOptionMessage(n, c)), r = n.redirect) : a && (s.warn(createRedirectOptionMessage(n, c)), a = n.redirect.value, r = n.redirect.option) : a = normalizeOption(a, n), n.choices) { var u = n.choices.find(function (e) { return e.value === a }); u && u.deprecated && (s.warn(createRedirectChoiceMessage(n, u, c)), a = u.redirect) } return n.array && !Array.isArray(a) && (a = [a]), a !== n.default && optionsValidator.validateOption(a, p[r], { descriptor: c }), e[r] = a, e }, {}) } function normalizeOption(e, t) { return "int" === t.type ? Number(e) : e } function createUnknownOptionMessage(t, e, n, r) { var a = ["Ignored unknown option ".concat(r(t, e), ".")], u = n.find(function (e) { return leven(e.name, t) < 3 }); return u && a.push("Did you mean ".concat(JSON.stringify(u.name), "?")), a.join(" ") } function createRedirectOptionMessage(e, t) { return "".concat(t(e.name), " is deprecated. Prettier now treats it as ").concat("string" == typeof e.redirect ? t(e.redirect) : t(e.redirect.option, e.redirect.value), ".") } function createRedirectChoiceMessage(e, t, n) { return "".concat(n(e.name, t.value), " is deprecated. Prettier now treats it as ").concat(n(e.name, t.redirect), ".") } function normalizeApiOptions(e, t, n) { return normalizeOptions$1(e, t, Object.assign({ descriptor: optionsDescriptor.apiDescriptor }, n)) } function normalizeCliOptions(n, e, t) { var r = n._ || [], a = normalizeOptions$1(Object.keys(n).reduce(function (e, t) { return Object.assign(e, 1 === t.length ? null : _defineProperty({}, t, n[t])) }, {}), e, Object.assign({ descriptor: optionsDescriptor.cliDescriptor }, t)); return a._ = r, a } var optionsNormalizer = { normalizeApiOptions: normalizeApiOptions, normalizeCliOptions: normalizeCliOptions }, getLast = function (e) { return 0 < e.length ? e[e.length - 1] : null }; function locStart$1(e) { return e.declaration && e.declaration.decorators && 0 < e.declaration.decorators.length ? locStart$1(e.declaration.decorators[0]) : e.decorators && 0 < e.decorators.length ? locStart$1(e.decorators[0]) : e.__location ? e.__location.startOffset : e.range ? e.range[0] : "number" == typeof e.start ? e.start : e.loc ? e.loc.start : null } function locEnd$1(e) { var t = e.nodes && getLast(e.nodes); if (t && e.source && !e.source.end && (e = t), e.__location) return e.__location.endOffset; var n = e.range ? e.range[1] : "number" == typeof e.end ? e.end : null; return e.typeAnnotation ? Math.max(n, locEnd$1(e.typeAnnotation)) : e.loc && !n ? e.loc.end : n } var loc = { locStart: locStart$1, locEnd: locEnd$1 }, jsTokens = createCommonjsModule(function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyu]{1,5}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g, t.matchToToken = function (e) { var t = { type: "invalid", value: e[0] }; return e[1] ? (t.type = "string", t.closed = !(!e[3] && !e[4])) : e[5] ? t.type = "comment" : e[6] ? (t.type = "comment", t.closed = !!e[7]) : e[8] ? t.type = "regex" : e[9] ? t.type = "number" : e[10] ? t.type = "name" : e[11] ? t.type = "punctuator" : e[12] && (t.type = "whitespace"), t } }); unwrapExports(jsTokens); var ast = createCommonjsModule(function (e) { function t(e) { if (null == e) return !1; switch (e.type) { case "BlockStatement": case "BreakStatement": case "ContinueStatement": case "DebuggerStatement": case "DoWhileStatement": case "EmptyStatement": case "ExpressionStatement": case "ForInStatement": case "ForStatement": case "IfStatement": case "LabeledStatement": case "ReturnStatement": case "SwitchStatement": case "ThrowStatement": case "TryStatement": case "VariableDeclaration": case "WhileStatement": case "WithStatement": return !0 }return !1 } function n(e) { switch (e.type) { case "IfStatement": return null != e.alternate ? e.alternate : e.consequent; case "LabeledStatement": case "ForStatement": case "ForInStatement": case "WhileStatement": case "WithStatement": return e.body }return null } e.exports = { isExpression: function (e) { if (null == e) return !1; switch (e.type) { case "ArrayExpression": case "AssignmentExpression": case "BinaryExpression": case "CallExpression": case "ConditionalExpression": case "FunctionExpression": case "Identifier": case "Literal": case "LogicalExpression": case "MemberExpression": case "NewExpression": case "ObjectExpression": case "SequenceExpression": case "ThisExpression": case "UnaryExpression": case "UpdateExpression": return !0 }return !1 }, isStatement: t, isIterationStatement: function (e) { if (null == e) return !1; switch (e.type) { case "DoWhileStatement": case "ForInStatement": case "ForStatement": case "WhileStatement": return !0 }return !1 }, isSourceElement: function (e) { return t(e) || null != e && "FunctionDeclaration" === e.type }, isProblematicIfStatement: function (e) { var t; if ("IfStatement" !== e.type) return !1; if (null == e.alternate) return !1; t = e.consequent; do { if ("IfStatement" === t.type && null == t.alternate) return !0; t = n(t) } while (t); return !1 }, trailingStatement: n } }), code = createCommonjsModule(function (i) { !function () { var t, n, r, a, u, e; function o(e) { return e <= 65535 ? String.fromCharCode(e) : String.fromCharCode(Math.floor((e - 65536) / 1024) + 55296) + String.fromCharCode((e - 65536) % 1024 + 56320) } for (n = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/, NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/ }, t = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDE00-\uDE11\uDE13-\uDE2B\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDE00-\uDE2F\uDE44\uDE80-\uDEAA]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]/, NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDD0-\uDDDA\uDE00-\uDE11\uDE13-\uDE37\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF01-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/ }, r = [5760, 6158, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279], a = new Array(128), e = 0; e < 128; ++e)a[e] = 97 <= e && e <= 122 || 65 <= e && e <= 90 || 36 === e || 95 === e; for (u = new Array(128), e = 0; e < 128; ++e)u[e] = 97 <= e && e <= 122 || 65 <= e && e <= 90 || 48 <= e && e <= 57 || 36 === e || 95 === e; i.exports = { isDecimalDigit: function (e) { return 48 <= e && e <= 57 }, isHexDigit: function (e) { return 48 <= e && e <= 57 || 97 <= e && e <= 102 || 65 <= e && e <= 70 }, isOctalDigit: function (e) { return 48 <= e && e <= 55 }, isWhiteSpace: function (e) { return 32 === e || 9 === e || 11 === e || 12 === e || 160 === e || 5760 <= e && 0 <= r.indexOf(e) }, isLineTerminator: function (e) { return 10 === e || 13 === e || 8232 === e || 8233 === e }, isIdentifierStartES5: function (e) { return e < 128 ? a[e] : n.NonAsciiIdentifierStart.test(o(e)) }, isIdentifierPartES5: function (e) { return e < 128 ? u[e] : n.NonAsciiIdentifierPart.test(o(e)) }, isIdentifierStartES6: function (e) { return e < 128 ? a[e] : t.NonAsciiIdentifierStart.test(o(e)) }, isIdentifierPartES6: function (e) { return e < 128 ? u[e] : t.NonAsciiIdentifierPart.test(o(e)) } } }() }), keyword = createCommonjsModule(function (e) { function n(e, t) { return !(!t && "yield" === e) && r(e, t) } function r(e, t) { if (t && function (e) { switch (e) { case "implements": case "interface": case "package": case "private": case "protected": case "public": case "static": case "let": return !0; default: return !1 } }(e)) return !0; switch (e.length) { case 2: return "if" === e || "in" === e || "do" === e; case 3: return "var" === e || "for" === e || "new" === e || "try" === e; case 4: return "this" === e || "else" === e || "case" === e || "void" === e || "with" === e || "enum" === e; case 5: return "while" === e || "break" === e || "catch" === e || "throw" === e || "const" === e || "yield" === e || "class" === e || "super" === e; case 6: return "return" === e || "typeof" === e || "delete" === e || "switch" === e || "export" === e || "import" === e; case 7: return "default" === e || "finally" === e || "extends" === e; case 8: return "function" === e || "continue" === e || "debugger" === e; case 10: return "instanceof" === e; default: return !1 } } function a(e, t) { return "null" === e || "true" === e || "false" === e || n(e, t) } function u(e, t) { return "null" === e || "true" === e || "false" === e || r(e, t) } function o(e) { var t, n, r; if (0 === e.length) return !1; if (r = e.charCodeAt(0), !s.isIdentifierStartES5(r)) return !1; for (t = 1, n = e.length; t < n; ++t)if (r = e.charCodeAt(t), !s.isIdentifierPartES5(r)) return !1; return !0 } function i(e) { var t, n, r, a, u; if (0 === e.length) return !1; for (u = s.isIdentifierStartES6, t = 0, n = e.length; t < n; ++t) { if (55296 <= (r = e.charCodeAt(t)) && r <= 56319) { if (n <= ++t) return !1; if (!(56320 <= (a = e.charCodeAt(t)) && a <= 57343)) return !1; r = 1024 * (r - 55296) + (a - 56320) + 65536 } if (!u(r)) return !1; u = s.isIdentifierPartES6 } return !0 } var s; s = code, e.exports = { isKeywordES5: n, isKeywordES6: r, isReservedWordES5: a, isReservedWordES6: u, isRestrictedWord: function (e) { return "eval" === e || "arguments" === e }, isIdentifierNameES5: o, isIdentifierNameES6: i, isIdentifierES5: function (e, t) { return o(e) && !a(e, t) }, isIdentifierES6: function (e, t) { return i(e) && !u(e, t) } } }), utils = createCommonjsModule(function (e, t) { t.ast = ast, t.code = code, t.keyword = keyword }), matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g, escapeStringRegexp = function (e) { if ("string" != typeof e) throw new TypeError("Expected a string"); return e.replace(matchOperatorsRe, "\\$&") }, colorName = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] }, conversions = createCommonjsModule(function (e) { var c = {}; for (var t in colorName) colorName.hasOwnProperty(t) && (c[colorName[t]] = t); var o = e.exports = { rgb: { channels: 3, labels: "rgb" }, hsl: { channels: 3, labels: "hsl" }, hsv: { channels: 3, labels: "hsv" }, hwb: { channels: 3, labels: "hwb" }, cmyk: { channels: 4, labels: "cmyk" }, xyz: { channels: 3, labels: "xyz" }, lab: { channels: 3, labels: "lab" }, lch: { channels: 3, labels: "lch" }, hex: { channels: 1, labels: ["hex"] }, keyword: { channels: 1, labels: ["keyword"] }, ansi16: { channels: 1, labels: ["ansi16"] }, ansi256: { channels: 1, labels: ["ansi256"] }, hcg: { channels: 3, labels: ["h", "c", "g"] }, apple: { channels: 3, labels: ["r16", "g16", "b16"] }, gray: { channels: 1, labels: ["gray"] } }; for (var n in o) if (o.hasOwnProperty(n)) { if (!("channels" in o[n])) throw new Error("missing channels property: " + n); if (!("labels" in o[n])) throw new Error("missing channel labels property: " + n); if (o[n].labels.length !== o[n].channels) throw new Error("channel and label counts mismatch: " + n); var r = o[n].channels, a = o[n].labels; delete o[n].channels, delete o[n].labels, Object.defineProperty(o[n], "channels", { value: r }), Object.defineProperty(o[n], "labels", { value: a }) } o.rgb.hsl = function (e) { var t, n, r = e[0] / 255, a = e[1] / 255, u = e[2] / 255, o = Math.min(r, a, u), i = Math.max(r, a, u), s = i - o; return i === o ? t = 0 : r === i ? t = (a - u) / s : a === i ? t = 2 + (u - r) / s : u === i && (t = 4 + (r - a) / s), (t = Math.min(60 * t, 360)) < 0 && (t += 360), n = (o + i) / 2, [t, 100 * (i === o ? 0 : n <= .5 ? s / (i + o) : s / (2 - i - o)), 100 * n] }, o.rgb.hsv = function (e) { var t, n, r = e[0], a = e[1], u = e[2], o = Math.min(r, a, u), i = Math.max(r, a, u), s = i - o; return n = 0 === i ? 0 : s / i * 1e3 / 10, i === o ? t = 0 : r === i ? t = (a - u) / s : a === i ? t = 2 + (u - r) / s : u === i && (t = 4 + (r - a) / s), (t = Math.min(60 * t, 360)) < 0 && (t += 360), [t, n, i / 255 * 1e3 / 10] }, o.rgb.hwb = function (e) { var t = e[0], n = e[1], r = e[2]; return [o.rgb.hsl(e)[0], 100 * (1 / 255 * Math.min(t, Math.min(n, r))), 100 * (r = 1 - 1 / 255 * Math.max(t, Math.max(n, r)))] }, o.rgb.cmyk = function (e) { var t, n = e[0] / 255, r = e[1] / 255, a = e[2] / 255; return [100 * ((1 - n - (t = Math.min(1 - n, 1 - r, 1 - a))) / (1 - t) || 0), 100 * ((1 - r - t) / (1 - t) || 0), 100 * ((1 - a - t) / (1 - t) || 0), 100 * t] }, o.rgb.keyword = function (e) { var t = c[e]; if (t) return t; var n, r, a, u = 1 / 0; for (var o in colorName) if (colorName.hasOwnProperty(o)) { var i = colorName[o], s = (r = e, a = i, Math.pow(r[0] - a[0], 2) + Math.pow(r[1] - a[1], 2) + Math.pow(r[2] - a[2], 2)); s < u && (u = s, n = o) } return n }, o.keyword.rgb = function (e) { return colorName[e] }, o.rgb.xyz = function (e) { var t = e[0] / 255, n = e[1] / 255, r = e[2] / 255; return [100 * (.4124 * (t = .04045 < t ? Math.pow((t + .055) / 1.055, 2.4) : t / 12.92) + .3576 * (n = .04045 < n ? Math.pow((n + .055) / 1.055, 2.4) : n / 12.92) + .1805 * (r = .04045 < r ? Math.pow((r + .055) / 1.055, 2.4) : r / 12.92)), 100 * (.2126 * t + .7152 * n + .0722 * r), 100 * (.0193 * t + .1192 * n + .9505 * r)] }, o.rgb.lab = function (e) { var t = o.rgb.xyz(e), n = t[0], r = t[1], a = t[2]; return r /= 100, a /= 108.883, n = .008856 < (n /= 95.047) ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116, [116 * (r = .008856 < r ? Math.pow(r, 1 / 3) : 7.787 * r + 16 / 116) - 16, 500 * (n - r), 200 * (r - (a = .008856 < a ? Math.pow(a, 1 / 3) : 7.787 * a + 16 / 116))] }, o.hsl.rgb = function (e) { var t, n, r, a, u, o = e[0] / 360, i = e[1] / 100, s = e[2] / 100; if (0 == i) return [u = 255 * s, u, u]; t = 2 * s - (n = s < .5 ? s * (1 + i) : s + i - s * i), a = [0, 0, 0]; for (var c = 0; c < 3; c++)(r = o + 1 / 3 * -(c - 1)) < 0 && r++ , 1 < r && r-- , u = 6 * r < 1 ? t + 6 * (n - t) * r : 2 * r < 1 ? n : 3 * r < 2 ? t + (n - t) * (2 / 3 - r) * 6 : t, a[c] = 255 * u; return a }, o.hsl.hsv = function (e) { var t = e[0], n = e[1] / 100, r = e[2] / 100, a = n, u = Math.max(r, .01); return n *= (r *= 2) <= 1 ? r : 2 - r, a *= u <= 1 ? u : 2 - u, [t, 100 * (0 === r ? 2 * a / (u + a) : 2 * n / (r + n)), 100 * ((r + n) / 2)] }, o.hsv.rgb = function (e) { var t = e[0] / 60, n = e[1] / 100, r = e[2] / 100, a = Math.floor(t) % 6, u = t - Math.floor(t), o = 255 * r * (1 - n), i = 255 * r * (1 - n * u), s = 255 * r * (1 - n * (1 - u)); switch (r *= 255, a) { case 0: return [r, s, o]; case 1: return [i, r, o]; case 2: return [o, r, s]; case 3: return [o, i, r]; case 4: return [s, o, r]; case 5: return [r, o, i] } }, o.hsv.hsl = function (e) { var t, n, r, a = e[0], u = e[1] / 100, o = e[2] / 100, i = Math.max(o, .01); return r = (2 - u) * o, n = u * i, [a, 100 * (n = (n /= (t = (2 - u) * i) <= 1 ? t : 2 - t) || 0), 100 * (r /= 2)] }, o.hwb.rgb = function (e) { var t, n, r, a, u, o, i, s = e[0] / 360, c = e[1] / 100, l = e[2] / 100, p = c + l; switch (1 < p && (c /= p, l /= p), r = 6 * s - (t = Math.floor(6 * s)), 0 != (1 & t) && (r = 1 - r), a = c + r * ((n = 1 - l) - c), t) { default: case 6: case 0: u = n, o = a, i = c; break; case 1: u = a, o = n, i = c; break; case 2: u = c, o = n, i = a; break; case 3: u = c, o = a, i = n; break; case 4: u = a, o = c, i = n; break; case 5: u = n, o = c, i = a }return [255 * u, 255 * o, 255 * i] }, o.cmyk.rgb = function (e) { var t = e[0] / 100, n = e[1] / 100, r = e[2] / 100, a = e[3] / 100; return [255 * (1 - Math.min(1, t * (1 - a) + a)), 255 * (1 - Math.min(1, n * (1 - a) + a)), 255 * (1 - Math.min(1, r * (1 - a) + a))] }, o.xyz.rgb = function (e) { var t, n, r, a = e[0] / 100, u = e[1] / 100, o = e[2] / 100; return n = -.9689 * a + 1.8758 * u + .0415 * o, r = .0557 * a + -.204 * u + 1.057 * o, t = .0031308 < (t = 3.2406 * a + -1.5372 * u + -.4986 * o) ? 1.055 * Math.pow(t, 1 / 2.4) - .055 : 12.92 * t, n = .0031308 < n ? 1.055 * Math.pow(n, 1 / 2.4) - .055 : 12.92 * n, r = .0031308 < r ? 1.055 * Math.pow(r, 1 / 2.4) - .055 : 12.92 * r, [255 * (t = Math.min(Math.max(0, t), 1)), 255 * (n = Math.min(Math.max(0, n), 1)), 255 * (r = Math.min(Math.max(0, r), 1))] }, o.xyz.lab = function (e) { var t = e[0], n = e[1], r = e[2]; return n /= 100, r /= 108.883, t = .008856 < (t /= 95.047) ? Math.pow(t, 1 / 3) : 7.787 * t + 16 / 116, [116 * (n = .008856 < n ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116) - 16, 500 * (t - n), 200 * (n - (r = .008856 < r ? Math.pow(r, 1 / 3) : 7.787 * r + 16 / 116))] }, o.lab.xyz = function (e) { var t, n, r, a = e[0]; t = e[1] / 500 + (n = (a + 16) / 116), r = n - e[2] / 200; var u = Math.pow(n, 3), o = Math.pow(t, 3), i = Math.pow(r, 3); return n = .008856 < u ? u : (n - 16 / 116) / 7.787, t = .008856 < o ? o : (t - 16 / 116) / 7.787, r = .008856 < i ? i : (r - 16 / 116) / 7.787, [t *= 95.047, n *= 100, r *= 108.883] }, o.lab.lch = function (e) { var t, n = e[0], r = e[1], a = e[2]; return (t = 360 * Math.atan2(a, r) / 2 / Math.PI) < 0 && (t += 360), [n, Math.sqrt(r * r + a * a), t] }, o.lch.lab = function (e) { var t, n = e[0], r = e[1]; return t = e[2] / 360 * 2 * Math.PI, [n, r * Math.cos(t), r * Math.sin(t)] }, o.rgb.ansi16 = function (e) { var t = e[0], n = e[1], r = e[2], a = 1 in arguments ? arguments[1] : o.rgb.hsv(e)[2]; if (0 === (a = Math.round(a / 50))) return 30; var u = 30 + (Math.round(r / 255) << 2 | Math.round(n / 255) << 1 | Math.round(t / 255)); return 2 === a && (u += 60), u }, o.hsv.ansi16 = function (e) { return o.rgb.ansi16(o.hsv.rgb(e), e[2]) }, o.rgb.ansi256 = function (e) { var t = e[0], n = e[1], r = e[2]; return t === n && n === r ? t < 8 ? 16 : 248 < t ? 231 : Math.round((t - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(t / 255 * 5) + 6 * Math.round(n / 255 * 5) + Math.round(r / 255 * 5) }, o.ansi16.rgb = function (e) { var t = e % 10; if (0 === t || 7 === t) return 50 < e && (t += 3.5), [t = t / 10.5 * 255, t, t]; var n = .5 * (1 + ~~(50 < e)); return [(1 & t) * n * 255, (t >> 1 & 1) * n * 255, (t >> 2 & 1) * n * 255] }, o.ansi256.rgb = function (e) { if (232 <= e) { var t = 10 * (e - 232) + 8; return [t, t, t] } var n; return e -= 16, [Math.floor(e / 36) / 5 * 255, Math.floor((n = e % 36) / 6) / 5 * 255, n % 6 / 5 * 255] }, o.rgb.hex = function (e) { var t = (((255 & Math.round(e[0])) << 16) + ((255 & Math.round(e[1])) << 8) + (255 & Math.round(e[2]))).toString(16).toUpperCase(); return "000000".substring(t.length) + t }, o.hex.rgb = function (e) { var t = e.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i); if (!t) return [0, 0, 0]; var n = t[0]; 3 === t[0].length && (n = n.split("").map(function (e) { return e + e }).join("")); var r = parseInt(n, 16); return [r >> 16 & 255, r >> 8 & 255, 255 & r] }, o.rgb.hcg = function (e) { var t, n = e[0] / 255, r = e[1] / 255, a = e[2] / 255, u = Math.max(Math.max(n, r), a), o = Math.min(Math.min(n, r), a), i = u - o; return t = i <= 0 ? 0 : u === n ? (r - a) / i % 6 : u === r ? 2 + (a - n) / i : 4 + (n - r) / i + 4, t /= 6, [360 * (t %= 1), 100 * i, 100 * (i < 1 ? o / (1 - i) : 0)] }, o.hsl.hcg = function (e) { var t = e[1] / 100, n = e[2] / 100, r = 1, a = 0; return (r = n < .5 ? 2 * t * n : 2 * t * (1 - n)) < 1 && (a = (n - .5 * r) / (1 - r)), [e[0], 100 * r, 100 * a] }, o.hsv.hcg = function (e) { var t = e[1] / 100, n = e[2] / 100, r = t * n, a = 0; return r < 1 && (a = (n - r) / (1 - r)), [e[0], 100 * r, 100 * a] }, o.hcg.rgb = function (e) { var t = e[0] / 360, n = e[1] / 100, r = e[2] / 100; if (0 == n) return [255 * r, 255 * r, 255 * r]; var a, u = [0, 0, 0], o = t % 1 * 6, i = o % 1, s = 1 - i; switch (Math.floor(o)) { case 0: u[0] = 1, u[1] = i, u[2] = 0; break; case 1: u[0] = s, u[1] = 1, u[2] = 0; break; case 2: u[0] = 0, u[1] = 1, u[2] = i; break; case 3: u[0] = 0, u[1] = s, u[2] = 1; break; case 4: u[0] = i, u[1] = 0, u[2] = 1; break; default: u[0] = 1, u[1] = 0, u[2] = s }return a = (1 - n) * r, [255 * (n * u[0] + a), 255 * (n * u[1] + a), 255 * (n * u[2] + a)] }, o.hcg.hsv = function (e) { var t = e[1] / 100, n = t + e[2] / 100 * (1 - t), r = 0; return 0 < n && (r = t / n), [e[0], 100 * r, 100 * n] }, o.hcg.hsl = function (e) { var t = e[1] / 100, n = e[2] / 100 * (1 - t) + .5 * t, r = 0; return 0 < n && n < .5 ? r = t / (2 * n) : .5 <= n && n < 1 && (r = t / (2 * (1 - n))), [e[0], 100 * r, 100 * n] }, o.hcg.hwb = function (e) { var t = e[1] / 100, n = t + e[2] / 100 * (1 - t); return [e[0], 100 * (n - t), 100 * (1 - n)] }, o.hwb.hcg = function (e) { var t = e[1] / 100, n = 1 - e[2] / 100, r = n - t, a = 0; return r < 1 && (a = (n - r) / (1 - r)), [e[0], 100 * r, 100 * a] }, o.apple.rgb = function (e) { return [e[0] / 65535 * 255, e[1] / 65535 * 255, e[2] / 65535 * 255] }, o.rgb.apple = function (e) { return [e[0] / 255 * 65535, e[1] / 255 * 65535, e[2] / 255 * 65535] }, o.gray.rgb = function (e) { return [e[0] / 100 * 255, e[0] / 100 * 255, e[0] / 100 * 255] }, o.gray.hsl = o.gray.hsv = function (e) { return [0, 0, e[0]] }, o.gray.hwb = function (e) { return [0, 100, e[0]] }, o.gray.cmyk = function (e) { return [0, 0, 0, e[0]] }, o.gray.lab = function (e) { return [e[0], 0, 0] }, o.gray.hex = function (e) { var t = 255 & Math.round(e[0] / 100 * 255), n = ((t << 16) + (t << 8) + t).toString(16).toUpperCase(); return "000000".substring(n.length) + n }, o.rgb.gray = function (e) { return [(e[0] + e[1] + e[2]) / 3 / 255 * 100] } }), models$1 = Object.keys(conversions); function buildGraph() { for (var e = {}, t = models$1.length, n = 0; n < t; n++)e[models$1[n]] = { distance: -1, parent: null }; return e } function deriveBFS(e) { var t = buildGraph(), n = [e]; for (t[e].distance = 0; n.length;)for (var r = n.pop(), a = Object.keys(conversions[r]), u = a.length, o = 0; o < u; o++) { var i = a[o], s = t[i]; -1 === s.distance && (s.distance = t[r].distance + 1, s.parent = r, n.unshift(i)) } return t } function link(t, n) { return function (e) { return n(t(e)) } } function wrapConversion(e, t) { for (var n = [t[e].parent, e], r = conversions[t[e].parent][e], a = t[e].parent; t[a].parent;)n.unshift(t[a].parent), r = link(conversions[t[a].parent][a], r), a = t[a].parent; return r.conversion = n, r } var route = function (e) { for (var t = deriveBFS(e), n = {}, r = Object.keys(t), a = r.length, u = 0; u < a; u++) { var o = r[u]; null !== t[o].parent && (n[o] = wrapConversion(o, t)) } return n }, convert = {}, models = Object.keys(conversions); function wrapRaw(t) { function e(e) { return null == e ? e : (1 < arguments.length && (e = Array.prototype.slice.call(arguments)), t(e)) } return "conversion" in t && (e.conversion = t.conversion), e } function wrapRounded(a) { function e(e) { if (null == e) return e; 1 < arguments.length && (e = Array.prototype.slice.call(arguments)); var t = a(e); if ("object" === _typeof(t)) for (var n = t.length, r = 0; r < n; r++)t[r] = Math.round(t[r]); return t } return "conversion" in a && (e.conversion = a.conversion), e } models.forEach(function (n) { convert[n] = {}, Object.defineProperty(convert[n], "channels", { value: conversions[n].channels }), Object.defineProperty(convert[n], "labels", { value: conversions[n].labels }); var r = route(n); Object.keys(r).forEach(function (e) { var t = r[e]; convert[n][e] = wrapRounded(t), convert[n][e].raw = wrapRaw(t) }) }); var colorConvert = convert, ansiStyles = createCommonjsModule(function (e) { function o(t, n) { return function () { var e = t.apply(colorConvert, arguments); return "[".concat(e + n, "m") } } function i(t, n) { return function () { var e = t.apply(colorConvert, arguments); return "[".concat(38 + n, ";5;").concat(e, "m") } } function s(t, n) { return function () { var e = t.apply(colorConvert, arguments); return "[".concat(38 + n, ";2;").concat(e[0], ";").concat(e[1], ";").concat(e[2], "m") } } Object.defineProperty(e, "exports", { enumerable: !0, get: function () { var r = { modifier: { reset: [0, 0], bold: [1, 22], dim: [2, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], hidden: [8, 28], strikethrough: [9, 29] }, color: { black: [30, 39], red: [31, 39], green: [32, 39], yellow: [33, 39], blue: [34, 39], magenta: [35, 39], cyan: [36, 39], white: [37, 39], gray: [90, 39], redBright: [91, 39], greenBright: [92, 39], yellowBright: [93, 39], blueBright: [94, 39], magentaBright: [95, 39], cyanBright: [96, 39], whiteBright: [97, 39] }, bgColor: { bgBlack: [40, 49], bgRed: [41, 49], bgGreen: [42, 49], bgYellow: [43, 49], bgBlue: [44, 49], bgMagenta: [45, 49], bgCyan: [46, 49], bgWhite: [47, 49], bgBlackBright: [100, 49], bgRedBright: [101, 49], bgGreenBright: [102, 49], bgYellowBright: [103, 49], bgBlueBright: [104, 49], bgMagentaBright: [105, 49], bgCyanBright: [106, 49], bgWhiteBright: [107, 49] } }; function e(e, t, n) { return [e, t, n] } r.color.grey = r.color.gray, Object.keys(r).forEach(function (e) { var n = r[e]; Object.keys(n).forEach(function (e) { var t = n[e]; r[e] = { open: "[".concat(t[0], "m"), close: "[".concat(t[1], "m") }, n[e] = r[e] }), Object.defineProperty(r, e, { value: n, enumerable: !1 }) }), r.color.close = "[39m", r.bgColor.close = "[49m", r.color.ansi = {}, r.color.ansi256 = {}, r.color.ansi16m = { rgb: s(e, 0) }, r.bgColor.ansi = {}, r.bgColor.ansi256 = {}, r.bgColor.ansi16m = { rgb: s(e, 10) }; for (var t = Object.keys(colorConvert), n = 0; n < t.length; n++) { var a = t[n]; if ("object" === _typeof(colorConvert[a])) { var u = colorConvert[a]; "ansi16" in u && (r.color.ansi[a] = o(u.ansi16, 0), r.bgColor.ansi[a] = o(u.ansi16, 10)), "ansi256" in u && (r.color.ansi256[a] = i(u.ansi256, 0), r.bgColor.ansi256[a] = i(u.ansi256, 10)), "rgb" in u && (r.color.ansi16m[a] = s(u.rgb, 0), r.bgColor.ansi16m[a] = s(u.rgb, 10)) } } return r } }) }), hasFlag = function (e, t) { var n = (t = t || process.argv).indexOf("--"), r = /^-{1,2}/.test(e) ? "" : "--", a = t.indexOf(r + e); return -1 !== a && (-1 === n || a < n) }, os$3 = {}, os$5 = Object.freeze({ default: os$3, __moduleExports: os$3 }), os$2 = os$5 && os$3 || os$5, supportsColor = createCommonjsModule(function (e) { var t, n = process.env, r = function () { if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) return 0; if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) return 3; if (hasFlag("color=256")) return 2; if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) return 1; if (process.stdout && !process.stdout.isTTY) return 0; if ("win32" === process.platform) { var e = os$2.release().split("."); return 8 <= Number(process.version.split(".")[0]) && 10 <= Number(e[0]) && 10586 <= Number(e[2]) ? 2 : 1 } if ("CI" in n) return "TRAVIS" in n || "Travis" === n.CI || "CIRCLECI" in n ? 1 : 0; if ("TEAMCITY_VERSION" in n) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(n.TEAMCITY_VERSION) ? 1 : 0; if ("TERM_PROGRAM" in n) { var t = parseInt((n.TERM_PROGRAM_VERSION || "").split(".")[0], 10); switch (n.TERM_PROGRAM) { case "iTerm.app": return 3 <= t ? 3 : 2; case "Hyper": return 3; case "Apple_Terminal": return 2 } } return /^(screen|xterm)-256(?:color)?/.test(n.TERM) ? 2 : /^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(n.TERM) ? 1 : "COLORTERM" in n ? 1 : (n.TERM, 0) }(); "FORCE_COLOR" in n && (r = 0 === parseInt(n.FORCE_COLOR, 10) ? 0 : r || 1), e.exports = process && (0 !== (t = r) && { level: t, hasBasic: !0, has256: 2 <= t, has16m: 3 <= t }) }), templates = createCommonjsModule(function (e) { var n = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, p = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, d = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, m = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi, t = new Map([["n", "\n"], ["r", "\r"], ["t", "\t"], ["b", "\b"], ["f", "\f"], ["v", "\v"], ["0", "\0"], ["\\", "\\"], ["e", ""], ["a", ""]]); function f(e) { return "u" === e[0] && 5 === e.length || "x" === e[0] && 3 === e.length ? String.fromCharCode(parseInt(e.slice(1), 16)) : t.get(e) || e } function D(e, t) { var n, r = [], a = t.trim().split(/\s*,\s*/g), u = !0, o = !1, i = void 0; try { for (var s, c = a[Symbol.iterator](); !(u = (s = c.next()).done); u = !0) { var l = s.value; if (isNaN(l)) { if (!(n = l.match(d))) throw new Error("Invalid Chalk template style argument: ".concat(l, " (in style '").concat(e, "')")); r.push(n[2].replace(m, function (e, t, n) { return t ? f(t) : n })) } else r.push(Number(l)) } } catch (e) { o = !0, i = e } finally { try { u || null == c.return || c.return() } finally { if (o) throw i } } return r } function g(e, t) { var n = {}, r = !0, a = !1, u = void 0; try { for (var o, i = t[Symbol.iterator](); !(r = (o = i.next()).done); r = !0) { var s = o.value, c = !0, l = !1, p = void 0; try { for (var d, m = s.styles[Symbol.iterator](); !(c = (d = m.next()).done); c = !0) { var f = d.value; n[f[0]] = s.inverse ? null : f.slice(1) } } catch (e) { l = !0, p = e } finally { try { c || null == m.return || m.return() } finally { if (l) throw p } } } } catch (e) { a = !0, u = e } finally { try { r || null == i.return || i.return() } finally { if (a) throw u } } for (var D = e, g = Object.keys(n), h = 0; h < g.length; h++) { var y = g[h]; if (Array.isArray(n[y])) { if (!(y in D)) throw new Error("Unknown Chalk style: ".concat(y)); D = 0 < n[y].length ? D[y].apply(D, n[y]) : D[y] } } return D } e.exports = function (i, e) { var s = [], c = [], l = []; if (e.replace(n, function (e, t, n, r, a, u) { if (t) l.push(f(t)); else if (r) { var o = l.join(""); l = [], c.push(0 === s.length ? o : g(i, s)(o)), s.push({ inverse: n, styles: function (e) { p.lastIndex = 0; for (var t, n = []; null !== (t = p.exec(e));) { var r = t[1]; if (t[2]) { var a = D(r, t[2]); n.push([r].concat(a)) } else n.push([r]) } return n }(r) }) } else if (a) { if (0 === s.length) throw new Error("Found extraneous } in Chalk template literal"); c.push(g(i, s)(l.join(""))), l = [], s.pop() } else l.push(u) }), c.push(l.join("")), 0 < s.length) { var t = "Chalk template literal is missing ".concat(s.length, " closing bracket").concat(1 === s.length ? "" : "s", " (`}`)"); throw new Error(t) } return c.join("") } }), chalk = createCommonjsModule(function (e) { var p = "win32" === process.platform && !(process.env.TERM || "").toLowerCase().startsWith("xterm"), r = ["ansi", "ansi", "ansi256", "ansi16m"], t = new Set(["gray"]), a = Object.create(null); function n(e, t) { t = t || {}; var n = supportsColor ? supportsColor.level : 0; e.level = void 0 === t.level ? n : t.level, e.enabled = "enabled" in t ? t.enabled : 0 < e.level } function u(e) { if (!this || !(this instanceof u) || this.template) { var t = {}; return n(t, e), t.template = function () { var e = [].slice.call(arguments); return function (e, t) { if (!Array.isArray(t)) return [].slice.call(arguments, 1).join(" "); for (var n = [].slice.call(arguments, 2), r = [t.raw[0]], a = 1; a < t.length; a++)r.push(String(n[a - 1]).replace(/[{}\\]/g, "\\$&")), r.push(String(t.raw[a])); return templates(e, r.join("")) }.apply(null, [t.template].concat(e)) }, Object.setPrototypeOf(t, u.prototype), Object.setPrototypeOf(t.template, t), t.template.constructor = u, t.template } n(this, e) } p && (ansiStyles.blue.open = "[94m"); for (var o = Object.keys(ansiStyles), i = function () { var t = o[s]; ansiStyles[t].closeRe = new RegExp(escapeStringRegexp(ansiStyles[t].close), "g"), a[t] = { get: function () { var e = ansiStyles[t]; return h.call(this, this._styles ? this._styles.concat(e) : [e], this._empty, t) } } }, s = 0; s < o.length; s++)i(); a.visible = { get: function () { return h.call(this, this._styles || [], !0, "visible") } }, ansiStyles.color.closeRe = new RegExp(escapeStringRegexp(ansiStyles.color.close), "g"); for (var c = Object.keys(ansiStyles.color.ansi), l = function () { var n = c[d]; if (t.has(n)) return "continue"; a[n] = { get: function () { var t = this.level; return function () { var e = { open: ansiStyles.color[r[t]][n].apply(null, arguments), close: ansiStyles.color.close, closeRe: ansiStyles.color.closeRe }; return h.call(this, this._styles ? this._styles.concat(e) : [e], this._empty, n) } } } }, d = 0; d < c.length; d++)l(); ansiStyles.bgColor.closeRe = new RegExp(escapeStringRegexp(ansiStyles.bgColor.close), "g"); for (var m = Object.keys(ansiStyles.bgColor.ansi), f = function () { var n = m[D]; if (t.has(n)) return "continue"; var e = "bg" + n[0].toUpperCase() + n.slice(1); a[e] = { get: function () { var t = this.level; return function () { var e = { open: ansiStyles.bgColor[r[t]][n].apply(null, arguments), close: ansiStyles.bgColor.close, closeRe: ansiStyles.bgColor.closeRe }; return h.call(this, this._styles ? this._styles.concat(e) : [e], this._empty, n) } } } }, D = 0; D < m.length; D++)f(); var g = Object.defineProperties(function () { }, a); function h(e, t, n) { function r() { return function () { var e = arguments, t = e.length, n = String(arguments[0]); if (0 === t) return ""; if (1 < t) for (var r = 1; r < t; r++)n += " " + e[r]; if (!this.enabled || this.level <= 0 || !n) return this._empty ? "" : n; var a = ansiStyles.dim.open; p && this.hasGrey && (ansiStyles.dim.open = ""); var u = !0, o = !1, i = void 0; try { for (var s, c = this._styles.slice().reverse()[Symbol.iterator](); !(u = (s = c.next()).done); u = !0) { var l = s.value; n = (n = l.open + n.replace(l.closeRe, l.open) + l.close).replace(/\r?\n/g, "".concat(l.close, "$&").concat(l.open)) } } catch (e) { o = !0, i = e } finally { try { u || null == c.return || c.return() } finally { if (o) throw i } } return ansiStyles.dim.open = a, n }.apply(r, arguments) } r._styles = e, r._empty = t; var a = this; return Object.defineProperty(r, "level", { enumerable: !0, get: function () { return a.level }, set: function (e) { a.level = e } }), Object.defineProperty(r, "enabled", { enumerable: !0, get: function () { return a.enabled }, set: function (e) { a.enabled = e } }), r.hasGrey = this.hasGrey || "gray" === n || "grey" === n, r.__proto__ = g, r } Object.defineProperties(u.prototype, a), e.exports = u(), e.exports.supportsColor = supportsColor, e.exports.default = e.exports }), lib$2 = createCommonjsModule(function (e, t) { function o() { var e = function (e) { { if (e && e.__esModule) return e; var t = {}; if (null != e) for (var n in e) if (Object.prototype.hasOwnProperty.call(e, n)) { var r = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(e, n) : {}; r.get || r.set ? Object.defineProperty(t, n, r) : t[n] = e[n] } return t.default = e, t } }(jsTokens); return o = function () { return e }, e } function i() { var e = r(utils); return i = function () { return e }, e } function n() { var e = r(chalk); return n = function () { return e }, e } function r(e) { return e && e.__esModule ? e : { default: e } } Object.defineProperty(t, "__esModule", { value: !0 }), t.shouldHighlight = a, t.getChalk = u, t.default = function (e) { var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {}; { return a(t) ? function (u, e) { return e.replace(o().default, function () { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; var r = function (e) { var t = _slicedToArray(e.slice(-2), 2), n = t[0], r = t[1], a = (0, o().matchToToken)(e); if ("name" === a.type) { if (i().default.keyword.isReservedWordES6(a.value)) return "keyword"; if (c.test(a.value) && ("<" === r[n - 1] || "</" == r.substr(n - 2, 2))) return "jsx_tag"; if (a.value[0] !== a.value[0].toLowerCase()) return "capitalized" } if ("punctuator" === a.type && l.test(a.value)) return "bracket"; return "invalid" !== a.type || "@" !== a.value && "#" !== a.value ? a.type : "punctuator" }(t), a = u[r]; return a ? t[0].split(s).map(function (e) { return a(e) }).join("\n") : t[0] }) }(function (e) { return { keyword: e.cyan, capitalized: e.yellow, jsx_tag: e.yellow, punctuator: e.yellow, number: e.magenta, string: e.green, regex: e.magenta, comment: e.grey, invalid: e.white.bgRed.bold } }(u(t)), e) : e } }; var s = /\r\n|[\n\r\u2028\u2029]/, c = /^[a-z][\w-]*$/i, l = /^[()[\]{}]$/; function a(e) { return n().default.supportsColor || e.forceColor } function u(e) { var t = n().default; return e.forceColor && (t = new (n().default.constructor)({ enabled: !0, level: 1 })), t } }); unwrapExports(lib$2); var lib$1 = createCommonjsModule(function (e, t) { function c() { var e = function (e) { { if (e && e.__esModule) return e; var t = {}; if (null != e) for (var n in e) if (Object.prototype.hasOwnProperty.call(e, n)) { var r = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(e, n) : {}; r.get || r.set ? Object.defineProperty(t, n, r) : t[n] = e[n] } return t.default = e, t } }(lib$2); return c = function () { return e }, e } Object.defineProperty(t, "__esModule", { value: !0 }), t.codeFrameColumns = o; var u = !(t.default = function (e, t, n) { var r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : {}; if (!u) { u = !0; var a = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`."; if (process.emitWarning) process.emitWarning(a, "DeprecationWarning"); else new Error(a).name = "DeprecationWarning", console.warn(new Error(a)) } return n = Math.max(n, 0), o(e, { start: { column: n, line: t } }, r) }); var g = /\r\n|[\n\r\u2028\u2029]/; function o(e, t) { function l(e, t) { return n ? e(t) : t } var p = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : {}, n = (p.highlightCode || p.forceColor) && (0, c().shouldHighlight)(p), r = (0, c().getChalk)(p), d = function (e) { return { gutter: e.grey, marker: e.red.bold, message: e.red.bold } }(r); n && (e = (0, c().default)(e, p)); var a = e.split(g), u = function (e, t, n) { var r = Object.assign({ column: 0, line: -1 }, e.start), a = Object.assign({}, r, e.end), u = n || {}, o = u.linesAbove, i = void 0 === o ? 2 : o, s = u.linesBelow, c = void 0 === s ? 3 : s, l = r.line, p = r.column, d = a.line, m = a.column, f = Math.max(l - (i + 1), 0), D = Math.min(t.length, d + c); -1 === l && (f = 0), -1 === d && (D = t.length); var g = d - l, h = {}; if (g) for (var y = 0; y <= g; y++) { var C = y + l; if (p) if (0 === y) { var $ = t[C - 1].length; h[C] = [p, $ - p] } else if (y === g) h[C] = [0, m]; else { var E = t[C - y].length; h[C] = [0, E] } else h[C] = !0 } else h[l] = p === m ? !p || [p, 0] : [p, m - p]; return { start: f, end: D, markerLines: h } }(t, a, p), m = u.start, o = u.end, f = u.markerLines, i = t.start && "number" == typeof t.start.column, D = String(o).length, s = a.slice(m, o).map(function (e, t) { var n = m + 1 + t, r = " ".concat(n).slice(-D), a = " ".concat(r, " | "), u = f[n], o = !f[n + 1]; if (u) { var i = ""; if (Array.isArray(u)) { var s = e.slice(0, Math.max(u[0] - 1, 0)).replace(/[^\t]/g, " "), c = u[1] || 1; i = ["\n ", l(d.gutter, a.replace(/\d/g, " ")), s, l(d.marker, "^").repeat(c)].join(""), o && p.message && (i += " " + l(d.message, p.message)) } return [l(d.marker, ">"), l(d.gutter, a), e, i].join("") } return " ".concat(l(d.gutter, a)).concat(e) }).join("\n"); return p.message && !i && (s = "".concat(" ".repeat(D + 1)).concat(p.message, "\n").concat(s)), n ? r.reset(s) : s } }); unwrapExports(lib$1); var path$5 = {}, path$7 = Object.freeze({ default: path$5, __moduleExports: path$5 }), path$4 = path$7 && path$5 || path$7, ConfigError$1 = errors.ConfigError, locStart = loc.locStart, locEnd = loc.locEnd, ownNames = Object.getOwnPropertyNames, ownDescriptor = Object.getOwnPropertyDescriptor; function getParsers(e) { var t = {}, n = !0, r = !1, a = void 0; try { for (var u, o = e.plugins[Symbol.iterator](); !(n = (u = o.next()).done); n = !0) { var i = u.value; if (i.parsers) { var s = !0, c = !1, l = void 0; try { for (var p, d = ownNames(i.parsers)[Symbol.iterator](); !(s = (p = d.next()).done); s = !0) { var m = p.value; Object.defineProperty(t, m, ownDescriptor(i.parsers, m)) } } catch (e) { c = !0, l = e } finally { try { s || null == d.return || d.return() } finally { if (c) throw l } } } } } catch (e) { r = !0, a = e } finally { try { n || null == o.return || o.return() } finally { if (r) throw a } } return t } function resolveParser$1(opts, parsers) { if (parsers = parsers || getParsers(opts), "function" == typeof opts.parser) return { parse: opts.parser, astFormat: "estree", locStart: locStart, locEnd: locEnd }; if ("string" == typeof opts.parser) { if (parsers.hasOwnProperty(opts.parser)) return parsers[opts.parser]; try { return { parse: eval("require")(path$4.resolve(process.cwd(), opts.parser)), astFormat: "estree", locStart: locStart, locEnd: locEnd } } catch (e) { throw new ConfigError$1("Couldn't resolve parser \"".concat(opts.parser, '"')) } } } function parse$2(t, e) { var n = getParsers(e), r = Object.keys(n).reduce(function (e, t) { return Object.defineProperty(e, t, { enumerable: !0, get: function () { return n[t].parse } }) }, {}), a = resolveParser$1(e, n); try { return a.preprocess && (t = a.preprocess(t, e)), { text: t, ast: a.parse(t, r, e) } } catch (e) { var u = e.loc; if (u) { var o = lib$1; throw e.codeFrame = o.codeFrameColumns(t, u, { highlightCode: !0 }), e.message += "\n" + e.codeFrame, e } throw e.stack } } var parser = { parse: parse$2, resolveParser: resolveParser$1 }, path$9 = {}, path$11 = Object.freeze({ default: path$9, __moduleExports: path$9 }), path$8 = path$11 && path$9 || path$11, UndefinedParserError = errors.UndefinedParserError, getSupportInfo$1 = support.getSupportInfo, resolveParser = parser.resolveParser, hiddenDefaults = { astFormat: "estree", printer: {}, locStart: null, locEnd: null }; function normalize(e, t) { t = t || {}; var n = Object.assign({}, e), r = getSupportInfo$1(null, { plugins: e.plugins, showUnreleased: !0, showDeprecated: !0 }).options, a = r.reduce(function (e, t) { return Object.assign(e, _defineProperty({}, t.name, t.default)) }, Object.assign({}, hiddenDefaults)); if (!n.parser) { if (!n.filepath) throw new UndefinedParserError("No parser and no file path given, couldn't infer a parser."); if (n.parser = inferParser(n.filepath, n.plugins), !n.parser) throw new UndefinedParserError("No parser could be inferred for file: ".concat(n.filepath)) } var u = resolveParser(optionsNormalizer.normalizeApiOptions(n, [r.find(function (e) { return "parser" === e.name })], { passThrough: !0, logger: !1 })); n.astFormat = u.astFormat, n.locEnd = u.locEnd, n.locStart = u.locStart; var o = getPlugin(n); n.printer = o.printers[n.astFormat]; var i = r.filter(function (e) { return e.pluginDefaults && e.pluginDefaults[o.name] }).reduce(function (e, t) { return Object.assign(e, _defineProperty({}, t.name, t.pluginDefaults[o.name])) }, {}), s = Object.assign({}, a, i); return Object.keys(s).forEach(function (e) { null == n[e] && (n[e] = s[e]) }), "json" === n.parser && (n.trailingComma = "none"), optionsNormalizer.normalizeApiOptions(n, r, Object.assign({ passThrough: Object.keys(hiddenDefaults) }, t)) } function getPlugin(e) { var t = e.astFormat; if (!t) throw new Error("getPlugin() requires astFormat to be set"); var n = e.plugins.find(function (e) { return e.printers && e.printers[t] }); if (!n) throw new Error("Couldn't find plugin for AST format \"".concat(t, '"')); return n } function inferParser(e, t) { var n = path$8.extname(e), r = path$8.basename(e).toLowerCase(), a = getSupportInfo$1(null, { plugins: t }).languages.find(function (e) { return null !== e.since && (e.extensions && -1 < e.extensions.indexOf(n) || e.filenames && e.filenames.find(function (e) { return e.toLowerCase() === r })) }); return a && a.parsers[0] } var options = { normalize: normalize, hiddenDefaults: hiddenDefaults, inferParser: inferParser }; function massageAST(e, t, n) { if (Array.isArray(e)) return e.map(function (e) { return massageAST(e, t, n) }).filter(function (e) { return e }); if (!e || "object" !== _typeof(e)) return e; for (var r = {}, a = Object.keys(e), u = 0; u < a.length; u++) { var o = a[u]; "function" != typeof e[o] && (r[o] = massageAST(e[o], t, e)) } if (t.printer.massageAstNode) { var i = t.printer.massageAstNode(e, r, n); if (null === i) return; if (i) return i } return r } var massageAst = massageAST, assert = { ok: function () { }, strictEqual: function () { } }; function assertDoc(e) { if ("string" != typeof e && (null == e || "string" != typeof e.type)) throw new Error("Value " + JSON.stringify(e) + " is not a valid document") } function concat$1(e) { return "production" !== process.env.NODE_ENV && e.forEach(assertDoc), { type: "concat", parts: e } } function indent$1(e) { return "production" !== process.env.NODE_ENV && assertDoc(e), { type: "indent", contents: e } } function align(e, t) { return "production" !== process.env.NODE_ENV && assertDoc(t), { type: "align", contents: t, n: e } } function group(e, t) { return t = t || {}, "production" !== process.env.NODE_ENV && assertDoc(e), { type: "group", contents: e, break: !!t.shouldBreak, expandedStates: t.expandedStates } } function dedentToRoot(e) { return align(-1 / 0, e) } function markAsRoot(e) { return align({ type: "root" }, e) } function dedent$1(e) { return align(-1, e) } function conditionalGroup(e, t) { return group(e[0], Object.assign(t || {}, { expandedStates: e })) } function fill(e) { return "production" !== process.env.NODE_ENV && e.forEach(assertDoc), { type: "fill", parts: e } } function ifBreak(e, t) { return "production" !== process.env.NODE_ENV && (e && assertDoc(e), t && assertDoc(t)), { type: "if-break", breakContents: e, flatContents: t } } function lineSuffix$1(e) { return "production" !== process.env.NODE_ENV && assertDoc(e), { type: "line-suffix", contents: e } } var lineSuffixBoundary = { type: "line-suffix-boundary" }, breakParent$1 = { type: "break-parent" }, line$2 = { type: "line" }, softline = { type: "line", soft: !0 }, hardline$1 = concat$1([{ type: "line", hard: !0 }, breakParent$1]), literalline = concat$1([{ type: "line", hard: !0, literal: !0 }, breakParent$1]), cursor$1 = { type: "cursor", placeholder: Symbol("cursor") }; function join$1(e, t) { for (var n = [], r = 0; r < t.length; r++)0 !== r && n.push(e), n.push(t[r]); return concat$1(n) } function addAlignmentToDoc(e, t, n) { var r = e; if (0 < t) { for (var a = 0; a < Math.floor(t / n); ++a)r = indent$1(r); r = align(-1 / 0, r = align(t % n, r)) } return r } var docBuilders = { concat: concat$1, join: join$1, line: line$2, softline: softline, hardline: hardline$1, literalline: literalline, group: group, conditionalGroup: conditionalGroup, fill: fill, lineSuffix: lineSuffix$1, lineSuffixBoundary: lineSuffixBoundary, cursor: cursor$1, breakParent: breakParent$1, ifBreak: ifBreak, indent: indent$1, align: align, addAlignmentToDoc: addAlignmentToDoc, markAsRoot: markAsRoot, dedentToRoot: dedentToRoot, dedent: dedent$1 }, ansiRegex = createCommonjsModule(function (e) { e.exports = function () { var e = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[a-zA-Z\\d]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PRZcf-ntqry=><~]))"].join("|"); return new RegExp(e, "g") } }), stripAnsi = function (e) { return "string" == typeof e ? e.replace(ansiRegex(), "") : e }, isFullwidthCodePoint = createCommonjsModule(function (e) { e.exports = function (e) { return !Number.isNaN(e) && (4352 <= e && (e <= 4447 || 9001 === e || 9002 === e || 11904 <= e && e <= 12871 && 12351 !== e || 12880 <= e && e <= 19903 || 19968 <= e && e <= 42182 || 43360 <= e && e <= 43388 || 44032 <= e && e <= 55203 || 63744 <= e && e <= 64255 || 65040 <= e && e <= 65049 || 65072 <= e && e <= 65131 || 65281 <= e && e <= 65376 || 65504 <= e && e <= 65510 || 110592 <= e && e <= 110593 || 127488 <= e && e <= 127569 || 131072 <= e && e <= 262141)) } }), stringWidth = createCommonjsModule(function (e) { e.exports = function (e) { if ("string" != typeof e || 0 === e.length) return 0; e = stripAnsi(e); for (var t = 0, n = 0; n < e.length; n++) { var r = e.codePointAt(n); r <= 31 || 127 <= r && r <= 159 || 768 <= r && r <= 879 || (65535 < r && n++ , t += isFullwidthCodePoint(r) ? 2 : 1) } return t } }), emojiRegex$1 = function () { return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74)\uDB40\uDC7F|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC68(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]\uFE0F|(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]))|\uD83D\uDC69\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83D\uDC69\u200D[\u2695\u2696\u2708])\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC68(?:\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDD1-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC69\uDC6E\uDC70-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD26\uDD30-\uDD39\uDD3D\uDD3E\uDDD1-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])?|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDEEB\uDEEC\uDEF4-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u2660\u2663\u2665\u2666\u2668\u267B\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])\uFE0F/g }, punctuation_ranges = [[12288, 12351], [44032, 55215], [65040, 65055], [65072, 65135], [65280, 65376], [65504, 65519]], character_ranges = [[4352, 4607], [11904, 12255], [12352, 12687], [12800, 19903], [19968, 40959], [43360, 43391], [63744, 64255]], oF; function get_regex() { return create_regex(character_ranges.concat(punctuation_ranges)) } function create_regex(e) { return new RegExp("[" + e.map(get_bracket_content).reduce(function (e, t) { return e + t }) + "]", "g") } function get_bracket_content(e) { return get_escaped_unicode(e[0]) + "-" + get_escaped_unicode(e[1]) } function get_escaped_unicode(e) { return "\\u" + e.toString(16) } oF = get_regex = get_regex || {}, oF.punctuations = function () { return create_regex(punctuation_ranges) }, oF.characters = function () { return create_regex(character_ranges) }; var lib$3 = get_regex, data_generated = createCommonjsModule(function (e, t) { t.__esModule = !0, t.get_data = function () { return { Pc: [[95, 95], [8255, 8256], [8276, 8276], [65075, 65076], [65101, 65103], [65343, 65343]], Pe: [[41, 41], [93, 93], [125, 125], [3899, 3899], [3901, 3901], [5788, 5788], [8262, 8262], [8318, 8318], [8334, 8334], [8969, 8969], [8971, 8971], [9002, 9002], [10089, 10089], [10091, 10091], [10093, 10093], [10095, 10095], [10097, 10097], [10099, 10099], [10101, 10101], [10182, 10182], [10215, 10215], [10217, 10217], [10219, 10219], [10221, 10221], [10223, 10223], [10628, 10628], [10630, 10630], [10632, 10632], [10634, 10634], [10636, 10636], [10638, 10638], [10640, 10640], [10642, 10642], [10644, 10644], [10646, 10646], [10648, 10648], [10713, 10713], [10715, 10715], [10749, 10749], [11811, 11811], [11813, 11813], [11815, 11815], [11817, 11817], [12297, 12297], [12299, 12299], [12301, 12301], [12303, 12303], [12305, 12305], [12309, 12309], [12311, 12311], [12313, 12313], [12315, 12315], [12318, 12319], [64830, 64830], [65048, 65048], [65078, 65078], [65080, 65080], [65082, 65082], [65084, 65084], [65086, 65086], [65088, 65088], [65090, 65090], [65092, 65092], [65096, 65096], [65114, 65114], [65116, 65116], [65118, 65118], [65289, 65289], [65341, 65341], [65373, 65373], [65376, 65376], [65379, 65379]], Ps: [[40, 40], [91, 91], [123, 123], [3898, 3898], [3900, 3900], [5787, 5787], [8218, 8218], [8222, 8222], [8261, 8261], [8317, 8317], [8333, 8333], [8968, 8968], [8970, 8970], [9001, 9001], [10088, 10088], [10090, 10090], [10092, 10092], [10094, 10094], [10096, 10096], [10098, 10098], [10100, 10100], [10181, 10181], [10214, 10214], [10216, 10216], [10218, 10218], [10220, 10220], [10222, 10222], [10627, 10627], [10629, 10629], [10631, 10631], [10633, 10633], [10635, 10635], [10637, 10637], [10639, 10639], [10641, 10641], [10643, 10643], [10645, 10645], [10647, 10647], [10712, 10712], [10714, 10714], [10748, 10748], [11810, 11810], [11812, 11812], [11814, 11814], [11816, 11816], [11842, 11842], [12296, 12296], [12298, 12298], [12300, 12300], [12302, 12302], [12304, 12304], [12308, 12308], [12310, 12310], [12312, 12312], [12314, 12314], [12317, 12317], [64831, 64831], [65047, 65047], [65077, 65077], [65079, 65079], [65081, 65081], [65083, 65083], [65085, 65085], [65087, 65087], [65089, 65089], [65091, 65091], [65095, 65095], [65113, 65113], [65115, 65115], [65117, 65117], [65288, 65288], [65339, 65339], [65371, 65371], [65375, 65375], [65378, 65378]], Lm: [[688, 705], [710, 721], [736, 740], [748, 748], [750, 750], [884, 884], [890, 890], [1369, 1369], [1600, 1600], [1765, 1766], [2036, 2037], [2042, 2042], [2074, 2074], [2084, 2084], [2088, 2088], [2417, 2417], [3654, 3654], [3782, 3782], [4348, 4348], [6103, 6103], [6211, 6211], [6823, 6823], [7288, 7293], [7468, 7530], [7544, 7544], [7579, 7615], [8305, 8305], [8319, 8319], [8336, 8348], [11388, 11389], [11631, 11631], [11823, 11823], [12293, 12293], [12337, 12341], [12347, 12347], [12445, 12446], [12540, 12542], [40981, 40981], [42232, 42237], [42508, 42508], [42623, 42623], [42652, 42653], [42775, 42783], [42864, 42864], [42888, 42888], [43e3, 43001], [43471, 43471], [43494, 43494], [43632, 43632], [43741, 43741], [43763, 43764], [43868, 43871], [65392, 65392], [65438, 65439]], Mc: [[2307, 2307], [2363, 2363], [2366, 2368], [2377, 2380], [2382, 2383], [2434, 2435], [2494, 2496], [2503, 2504], [2507, 2508], [2519, 2519], [2563, 2563], [2622, 2624], [2691, 2691], [2750, 2752], [2761, 2761], [2763, 2764], [2818, 2819], [2878, 2878], [2880, 2880], [2887, 2888], [2891, 2892], [2903, 2903], [3006, 3007], [3009, 3010], [3014, 3016], [3018, 3020], [3031, 3031], [3073, 3075], [3137, 3140], [3202, 3203], [3262, 3262], [3264, 3268], [3271, 3272], [3274, 3275], [3285, 3286], [3330, 3331], [3390, 3392], [3398, 3400], [3402, 3404], [3415, 3415], [3458, 3459], [3535, 3537], [3544, 3551], [3570, 3571], [3902, 3903], [3967, 3967], [4139, 4140], [4145, 4145], [4152, 4152], [4155, 4156], [4182, 4183], [4194, 4196], [4199, 4205], [4227, 4228], [4231, 4236], [4239, 4239], [4250, 4252], [6070, 6070], [6078, 6085], [6087, 6088], [6435, 6438], [6441, 6443], [6448, 6449], [6451, 6456], [6681, 6682], [6741, 6741], [6743, 6743], [6753, 6753], [6755, 6756], [6765, 6770], [6916, 6916], [6965, 6965], [6971, 6971], [6973, 6977], [6979, 6980], [7042, 7042], [7073, 7073], [7078, 7079], [7082, 7082], [7143, 7143], [7146, 7148], [7150, 7150], [7154, 7155], [7204, 7211], [7220, 7221], [7393, 7393], [7410, 7411], [7415, 7415], [12334, 12335], [43043, 43044], [43047, 43047], [43136, 43137], [43188, 43203], [43346, 43347], [43395, 43395], [43444, 43445], [43450, 43451], [43453, 43456], [43567, 43568], [43571, 43572], [43597, 43597], [43643, 43643], [43645, 43645], [43755, 43755], [43758, 43759], [43765, 43765], [44003, 44004], [44006, 44007], [44009, 44010], [44012, 44012]], Zp: [[8233, 8233]], Sc: [[36, 36], [162, 165], [1423, 1423], [1547, 1547], [2546, 2547], [2555, 2555], [2801, 2801], [3065, 3065], [3647, 3647], [6107, 6107], [8352, 8383], [43064, 43064], [65020, 65020], [65129, 65129], [65284, 65284], [65504, 65505], [65509, 65510]], Me: [[1160, 1161], [6846, 6846], [8413, 8416], [8418, 8420], [42608, 42610]], Sk: [[94, 94], [96, 96], [168, 168], [175, 175], [180, 180], [184, 184], [706, 709], [722, 735], [741, 747], [749, 749], [751, 767], [885, 885], [900, 901], [8125, 8125], [8127, 8129], [8141, 8143], [8157, 8159], [8173, 8175], [8189, 8190], [12443, 12444], [42752, 42774], [42784, 42785], [42889, 42890], [43867, 43867], [64434, 64449], [65342, 65342], [65344, 65344], [65507, 65507]], Cs: [[55296, 55296], [56191, 56192], [56319, 56320], [57343, 57343]], Nl: [[5870, 5872], [8544, 8578], [8581, 8584], [12295, 12295], [12321, 12329], [12344, 12346], [42726, 42735]], So: [[166, 166], [169, 169], [174, 174], [176, 176], [1154, 1154], [1421, 1422], [1550, 1551], [1758, 1758], [1769, 1769], [1789, 1790], [2038, 2038], [2554, 2554], [2928, 2928], [3059, 3064], [3066, 3066], [3199, 3199], [3407, 3407], [3449, 3449], [3841, 3843], [3859, 3859], [3861, 3863], [3866, 3871], [3892, 3892], [3894, 3894], [3896, 3896], [4030, 4037], [4039, 4044], [4046, 4047], [4053, 4056], [4254, 4255], [5008, 5017], [6464, 6464], [6622, 6655], [7009, 7018], [7028, 7036], [8448, 8449], [8451, 8454], [8456, 8457], [8468, 8468], [8470, 8471], [8478, 8483], [8485, 8485], [8487, 8487], [8489, 8489], [8494, 8494], [8506, 8507], [8522, 8522], [8524, 8525], [8527, 8527], [8586, 8587], [8597, 8601], [8604, 8607], [8609, 8610], [8612, 8613], [8615, 8621], [8623, 8653], [8656, 8657], [8659, 8659], [8661, 8691], [8960, 8967], [8972, 8991], [8994, 9e3], [9003, 9083], [9085, 9114], [9140, 9179], [9186, 9254], [9280, 9290], [9372, 9449], [9472, 9654], [9656, 9664], [9666, 9719], [9728, 9838], [9840, 10087], [10132, 10175], [10240, 10495], [11008, 11055], [11077, 11078], [11085, 11123], [11126, 11157], [11160, 11193], [11197, 11208], [11210, 11218], [11244, 11247], [11493, 11498], [11904, 11929], [11931, 12019], [12032, 12245], [12272, 12283], [12292, 12292], [12306, 12307], [12320, 12320], [12342, 12343], [12350, 12351], [12688, 12689], [12694, 12703], [12736, 12771], [12800, 12830], [12842, 12871], [12880, 12880], [12896, 12927], [12938, 12976], [12992, 13054], [13056, 13311], [19904, 19967], [42128, 42182], [43048, 43051], [43062, 43063], [43065, 43065], [43639, 43641], [65021, 65021], [65508, 65508], [65512, 65512], [65517, 65518], [65532, 65533]], Lt: [[453, 453], [456, 456], [459, 459], [498, 498], [8072, 8079], [8088, 8095], [8104, 8111], [8124, 8124], [8140, 8140], [8188, 8188]], Zl: [[8232, 8232]], Lo: [[170, 170], [186, 186], [443, 443], [448, 451], [660, 660], [1488, 1514], [1520, 1522], [1568, 1599], [1601, 1610], [1646, 1647], [1649, 1747], [1749, 1749], [1774, 1775], [1786, 1788], [1791, 1791], [1808, 1808], [1810, 1839], [1869, 1957], [1969, 1969], [1994, 2026], [2048, 2069], [2112, 2136], [2144, 2154], [2208, 2228], [2230, 2237], [2308, 2361], [2365, 2365], [2384, 2384], [2392, 2401], [2418, 2432], [2437, 2444], [2447, 2448], [2451, 2472], [2474, 2480], [2482, 2482], [2486, 2489], [2493, 2493], [2510, 2510], [2524, 2525], [2527, 2529], [2544, 2545], [2556, 2556], [2565, 2570], [2575, 2576], [2579, 2600], [2602, 2608], [2610, 2611], [2613, 2614], [2616, 2617], [2649, 2652], [2654, 2654], [2674, 2676], [2693, 2701], [2703, 2705], [2707, 2728], [2730, 2736], [2738, 2739], [2741, 2745], [2749, 2749], [2768, 2768], [2784, 2785], [2809, 2809], [2821, 2828], [2831, 2832], [2835, 2856], [2858, 2864], [2866, 2867], [2869, 2873], [2877, 2877], [2908, 2909], [2911, 2913], [2929, 2929], [2947, 2947], [2949, 2954], [2958, 2960], [2962, 2965], [2969, 2970], [2972, 2972], [2974, 2975], [2979, 2980], [2984, 2986], [2990, 3001], [3024, 3024], [3077, 3084], [3086, 3088], [3090, 3112], [3114, 3129], [3133, 3133], [3160, 3162], [3168, 3169], [3200, 3200], [3205, 3212], [3214, 3216], [3218, 3240], [3242, 3251], [3253, 3257], [3261, 3261], [3294, 3294], [3296, 3297], [3313, 3314], [3333, 3340], [3342, 3344], [3346, 3386], [3389, 3389], [3406, 3406], [3412, 3414], [3423, 3425], [3450, 3455], [3461, 3478], [3482, 3505], [3507, 3515], [3517, 3517], [3520, 3526], [3585, 3632], [3634, 3635], [3648, 3653], [3713, 3714], [3716, 3716], [3719, 3720], [3722, 3722], [3725, 3725], [3732, 3735], [3737, 3743], [3745, 3747], [3749, 3749], [3751, 3751], [3754, 3755], [3757, 3760], [3762, 3763], [3773, 3773], [3776, 3780], [3804, 3807], [3840, 3840], [3904, 3911], [3913, 3948], [3976, 3980], [4096, 4138], [4159, 4159], [4176, 4181], [4186, 4189], [4193, 4193], [4197, 4198], [4206, 4208], [4213, 4225], [4238, 4238], [4304, 4346], [4349, 4680], [4682, 4685], [4688, 4694], [4696, 4696], [4698, 4701], [4704, 4744], [4746, 4749], [4752, 4784], [4786, 4789], [4792, 4798], [4800, 4800], [4802, 4805], [4808, 4822], [4824, 4880], [4882, 4885], [4888, 4954], [4992, 5007], [5121, 5740], [5743, 5759], [5761, 5786], [5792, 5866], [5873, 5880], [5888, 5900], [5902, 5905], [5920, 5937], [5952, 5969], [5984, 5996], [5998, 6e3], [6016, 6067], [6108, 6108], [6176, 6210], [6212, 6263], [6272, 6276], [6279, 6312], [6314, 6314], [6320, 6389], [6400, 6430], [6480, 6509], [6512, 6516], [6528, 6571], [6576, 6601], [6656, 6678], [6688, 6740], [6917, 6963], [6981, 6987], [7043, 7072], [7086, 7087], [7098, 7141], [7168, 7203], [7245, 7247], [7258, 7287], [7401, 7404], [7406, 7409], [7413, 7414], [8501, 8504], [11568, 11623], [11648, 11670], [11680, 11686], [11688, 11694], [11696, 11702], [11704, 11710], [11712, 11718], [11720, 11726], [11728, 11734], [11736, 11742], [12294, 12294], [12348, 12348], [12353, 12438], [12447, 12447], [12449, 12538], [12543, 12543], [12549, 12590], [12593, 12686], [12704, 12730], [12784, 12799], [13312, 13312], [19893, 19893], [19968, 19968], [40938, 40938], [40960, 40980], [40982, 42124], [42192, 42231], [42240, 42507], [42512, 42527], [42538, 42539], [42606, 42606], [42656, 42725], [42895, 42895], [42999, 42999], [43003, 43009], [43011, 43013], [43015, 43018], [43020, 43042], [43072, 43123], [43138, 43187], [43250, 43255], [43259, 43259], [43261, 43261], [43274, 43301], [43312, 43334], [43360, 43388], [43396, 43442], [43488, 43492], [43495, 43503], [43514, 43518], [43520, 43560], [43584, 43586], [43588, 43595], [43616, 43631], [43633, 43638], [43642, 43642], [43646, 43695], [43697, 43697], [43701, 43702], [43705, 43709], [43712, 43712], [43714, 43714], [43739, 43740], [43744, 43754], [43762, 43762], [43777, 43782], [43785, 43790], [43793, 43798], [43808, 43814], [43816, 43822], [43968, 44002], [44032, 44032], [55203, 55203], [55216, 55238], [55243, 55291], [63744, 64109], [64112, 64217], [64285, 64285], [64287, 64296], [64298, 64310], [64312, 64316], [64318, 64318], [64320, 64321], [64323, 64324], [64326, 64433], [64467, 64829], [64848, 64911], [64914, 64967], [65008, 65019], [65136, 65140], [65142, 65276], [65382, 65391], [65393, 65437], [65440, 65470], [65474, 65479], [65482, 65487], [65490, 65495], [65498, 65500]], Mn: [[768, 879], [1155, 1159], [1425, 1469], [1471, 1471], [1473, 1474], [1476, 1477], [1479, 1479], [1552, 1562], [1611, 1631], [1648, 1648], [1750, 1756], [1759, 1764], [1767, 1768], [1770, 1773], [1809, 1809], [1840, 1866], [1958, 1968], [2027, 2035], [2070, 2073], [2075, 2083], [2085, 2087], [2089, 2093], [2137, 2139], [2260, 2273], [2275, 2306], [2362, 2362], [2364, 2364], [2369, 2376], [2381, 2381], [2385, 2391], [2402, 2403], [2433, 2433], [2492, 2492], [2497, 2500], [2509, 2509], [2530, 2531], [2561, 2562], [2620, 2620], [2625, 2626], [2631, 2632], [2635, 2637], [2641, 2641], [2672, 2673], [2677, 2677], [2689, 2690], [2748, 2748], [2753, 2757], [2759, 2760], [2765, 2765], [2786, 2787], [2810, 2815], [2817, 2817], [2876, 2876], [2879, 2879], [2881, 2884], [2893, 2893], [2902, 2902], [2914, 2915], [2946, 2946], [3008, 3008], [3021, 3021], [3072, 3072], [3134, 3136], [3142, 3144], [3146, 3149], [3157, 3158], [3170, 3171], [3201, 3201], [3260, 3260], [3263, 3263], [3270, 3270], [3276, 3277], [3298, 3299], [3328, 3329], [3387, 3388], [3393, 3396], [3405, 3405], [3426, 3427], [3530, 3530], [3538, 3540], [3542, 3542], [3633, 3633], [3636, 3642], [3655, 3662], [3761, 3761], [3764, 3769], [3771, 3772], [3784, 3789], [3864, 3865], [3893, 3893], [3895, 3895], [3897, 3897], [3953, 3966], [3968, 3972], [3974, 3975], [3981, 3991], [3993, 4028], [4038, 4038], [4141, 4144], [4146, 4151], [4153, 4154], [4157, 4158], [4184, 4185], [4190, 4192], [4209, 4212], [4226, 4226], [4229, 4230], [4237, 4237], [4253, 4253], [4957, 4959], [5906, 5908], [5938, 5940], [5970, 5971], [6002, 6003], [6068, 6069], [6071, 6077], [6086, 6086], [6089, 6099], [6109, 6109], [6155, 6157], [6277, 6278], [6313, 6313], [6432, 6434], [6439, 6440], [6450, 6450], [6457, 6459], [6679, 6680], [6683, 6683], [6742, 6742], [6744, 6750], [6752, 6752], [6754, 6754], [6757, 6764], [6771, 6780], [6783, 6783], [6832, 6845], [6912, 6915], [6964, 6964], [6966, 6970], [6972, 6972], [6978, 6978], [7019, 7027], [7040, 7041], [7074, 7077], [7080, 7081], [7083, 7085], [7142, 7142], [7144, 7145], [7149, 7149], [7151, 7153], [7212, 7219], [7222, 7223], [7376, 7378], [7380, 7392], [7394, 7400], [7405, 7405], [7412, 7412], [7416, 7417], [7616, 7673], [7675, 7679], [8400, 8412], [8417, 8417], [8421, 8432], [11503, 11505], [11647, 11647], [11744, 11775], [12330, 12333], [12441, 12442], [42607, 42607], [42612, 42621], [42654, 42655], [42736, 42737], [43010, 43010], [43014, 43014], [43019, 43019], [43045, 43046], [43204, 43205], [43232, 43249], [43302, 43309], [43335, 43345], [43392, 43394], [43443, 43443], [43446, 43449], [43452, 43452], [43493, 43493], [43561, 43566], [43569, 43570], [43573, 43574], [43587, 43587], [43596, 43596], [43644, 43644], [43696, 43696], [43698, 43700], [43703, 43704], [43710, 43711], [43713, 43713], [43756, 43757], [43766, 43766], [44005, 44005], [44008, 44008], [44013, 44013], [64286, 64286], [65024, 65039], [65056, 65071]], Po: [[33, 35], [37, 39], [42, 42], [44, 44], [46, 47], [58, 59], [63, 64], [92, 92], [161, 161], [167, 167], [182, 183], [191, 191], [894, 894], [903, 903], [1370, 1375], [1417, 1417], [1472, 1472], [1475, 1475], [1478, 1478], [1523, 1524], [1545, 1546], [1548, 1549], [1563, 1563], [1566, 1567], [1642, 1645], [1748, 1748], [1792, 1805], [2039, 2041], [2096, 2110], [2142, 2142], [2404, 2405], [2416, 2416], [2557, 2557], [2800, 2800], [3572, 3572], [3663, 3663], [3674, 3675], [3844, 3858], [3860, 3860], [3973, 3973], [4048, 4052], [4057, 4058], [4170, 4175], [4347, 4347], [4960, 4968], [5741, 5742], [5867, 5869], [5941, 5942], [6100, 6102], [6104, 6106], [6144, 6149], [6151, 6154], [6468, 6469], [6686, 6687], [6816, 6822], [6824, 6829], [7002, 7008], [7164, 7167], [7227, 7231], [7294, 7295], [7360, 7367], [7379, 7379], [8214, 8215], [8224, 8231], [8240, 8248], [8251, 8254], [8257, 8259], [8263, 8273], [8275, 8275], [8277, 8286], [11513, 11516], [11518, 11519], [11632, 11632], [11776, 11777], [11782, 11784], [11787, 11787], [11790, 11798], [11800, 11801], [11803, 11803], [11806, 11807], [11818, 11822], [11824, 11833], [11836, 11839], [11841, 11841], [11843, 11849], [12289, 12291], [12349, 12349], [12539, 12539], [42238, 42239], [42509, 42511], [42611, 42611], [42622, 42622], [42738, 42743], [43124, 43127], [43214, 43215], [43256, 43258], [43260, 43260], [43310, 43311], [43359, 43359], [43457, 43469], [43486, 43487], [43612, 43615], [43742, 43743], [43760, 43761], [44011, 44011], [65040, 65046], [65049, 65049], [65072, 65072], [65093, 65094], [65097, 65100], [65104, 65106], [65108, 65111], [65119, 65121], [65128, 65128], [65130, 65131], [65281, 65283], [65285, 65287], [65290, 65290], [65292, 65292], [65294, 65295], [65306, 65307], [65311, 65312], [65340, 65340], [65377, 65377], [65380, 65381]], Co: [[57344, 57344], [63743, 63743]], Sm: [[43, 43], [60, 62], [124, 124], [126, 126], [172, 172], [177, 177], [215, 215], [247, 247], [1014, 1014], [1542, 1544], [8260, 8260], [8274, 8274], [8314, 8316], [8330, 8332], [8472, 8472], [8512, 8516], [8523, 8523], [8592, 8596], [8602, 8603], [8608, 8608], [8611, 8611], [8614, 8614], [8622, 8622], [8654, 8655], [8658, 8658], [8660, 8660], [8692, 8959], [8992, 8993], [9084, 9084], [9115, 9139], [9180, 9185], [9655, 9655], [9665, 9665], [9720, 9727], [9839, 9839], [10176, 10180], [10183, 10213], [10224, 10239], [10496, 10626], [10649, 10711], [10716, 10747], [10750, 11007], [11056, 11076], [11079, 11084], [64297, 64297], [65122, 65122], [65124, 65126], [65291, 65291], [65308, 65310], [65372, 65372], [65374, 65374], [65506, 65506], [65513, 65516]], Pf: [[187, 187], [8217, 8217], [8221, 8221], [8250, 8250], [11779, 11779], [11781, 11781], [11786, 11786], [11789, 11789], [11805, 11805], [11809, 11809]], Cc: [[0, 31], [127, 159]], Pi: [[171, 171], [8216, 8216], [8219, 8220], [8223, 8223], [8249, 8249], [11778, 11778], [11780, 11780], [11785, 11785], [11788, 11788], [11804, 11804], [11808, 11808]], Lu: [[65, 90], [192, 214], [216, 222], [256, 256], [258, 258], [260, 260], [262, 262], [264, 264], [266, 266], [268, 268], [270, 270], [272, 272], [274, 274], [276, 276], [278, 278], [280, 280], [282, 282], [284, 284], [286, 286], [288, 288], [290, 290], [292, 292], [294, 294], [296, 296], [298, 298], [300, 300], [302, 302], [304, 304], [306, 306], [308, 308], [310, 310], [313, 313], [315, 315], [317, 317], [319, 319], [321, 321], [323, 323], [325, 325], [327, 327], [330, 330], [332, 332], [334, 334], [336, 336], [338, 338], [340, 340], [342, 342], [344, 344], [346, 346], [348, 348], [350, 350], [352, 352], [354, 354], [356, 356], [358, 358], [360, 360], [362, 362], [364, 364], [366, 366], [368, 368], [370, 370], [372, 372], [374, 374], [376, 377], [379, 379], [381, 381], [385, 386], [388, 388], [390, 391], [393, 395], [398, 401], [403, 404], [406, 408], [412, 413], [415, 416], [418, 418], [420, 420], [422, 423], [425, 425], [428, 428], [430, 431], [433, 435], [437, 437], [439, 440], [444, 444], [452, 452], [455, 455], [458, 458], [461, 461], [463, 463], [465, 465], [467, 467], [469, 469], [471, 471], [473, 473], [475, 475], [478, 478], [480, 480], [482, 482], [484, 484], [486, 486], [488, 488], [490, 490], [492, 492], [494, 494], [497, 497], [500, 500], [502, 504], [506, 506], [508, 508], [510, 510], [512, 512], [514, 514], [516, 516], [518, 518], [520, 520], [522, 522], [524, 524], [526, 526], [528, 528], [530, 530], [532, 532], [534, 534], [536, 536], [538, 538], [540, 540], [542, 542], [544, 544], [546, 546], [548, 548], [550, 550], [552, 552], [554, 554], [556, 556], [558, 558], [560, 560], [562, 562], [570, 571], [573, 574], [577, 577], [579, 582], [584, 584], [586, 586], [588, 588], [590, 590], [880, 880], [882, 882], [886, 886], [895, 895], [902, 902], [904, 906], [908, 908], [910, 911], [913, 929], [931, 939], [975, 975], [978, 980], [984, 984], [986, 986], [988, 988], [990, 990], [992, 992], [994, 994], [996, 996], [998, 998], [1e3, 1e3], [1002, 1002], [1004, 1004], [1006, 1006], [1012, 1012], [1015, 1015], [1017, 1018], [1021, 1071], [1120, 1120], [1122, 1122], [1124, 1124], [1126, 1126], [1128, 1128], [1130, 1130], [1132, 1132], [1134, 1134], [1136, 1136], [1138, 1138], [1140, 1140], [1142, 1142], [1144, 1144], [1146, 1146], [1148, 1148], [1150, 1150], [1152, 1152], [1162, 1162], [1164, 1164], [1166, 1166], [1168, 1168], [1170, 1170], [1172, 1172], [1174, 1174], [1176, 1176], [1178, 1178], [1180, 1180], [1182, 1182], [1184, 1184], [1186, 1186], [1188, 1188], [1190, 1190], [1192, 1192], [1194, 1194], [1196, 1196], [1198, 1198], [1200, 1200], [1202, 1202], [1204, 1204], [1206, 1206], [1208, 1208], [1210, 1210], [1212, 1212], [1214, 1214], [1216, 1217], [1219, 1219], [1221, 1221], [1223, 1223], [1225, 1225], [1227, 1227], [1229, 1229], [1232, 1232], [1234, 1234], [1236, 1236], [1238, 1238], [1240, 1240], [1242, 1242], [1244, 1244], [1246, 1246], [1248, 1248], [1250, 1250], [1252, 1252], [1254, 1254], [1256, 1256], [1258, 1258], [1260, 1260], [1262, 1262], [1264, 1264], [1266, 1266], [1268, 1268], [1270, 1270], [1272, 1272], [1274, 1274], [1276, 1276], [1278, 1278], [1280, 1280], [1282, 1282], [1284, 1284], [1286, 1286], [1288, 1288], [1290, 1290], [1292, 1292], [1294, 1294], [1296, 1296], [1298, 1298], [1300, 1300], [1302, 1302], [1304, 1304], [1306, 1306], [1308, 1308], [1310, 1310], [1312, 1312], [1314, 1314], [1316, 1316], [1318, 1318], [1320, 1320], [1322, 1322], [1324, 1324], [1326, 1326], [1329, 1366], [4256, 4293], [4295, 4295], [4301, 4301], [5024, 5109], [7680, 7680], [7682, 7682], [7684, 7684], [7686, 7686], [7688, 7688], [7690, 7690], [7692, 7692], [7694, 7694], [7696, 7696], [7698, 7698], [7700, 7700], [7702, 7702], [7704, 7704], [7706, 7706], [7708, 7708], [7710, 7710], [7712, 7712], [7714, 7714], [7716, 7716], [7718, 7718], [7720, 7720], [7722, 7722], [7724, 7724], [7726, 7726], [7728, 7728], [7730, 7730], [7732, 7732], [7734, 7734], [7736, 7736], [7738, 7738], [7740, 7740], [7742, 7742], [7744, 7744], [7746, 7746], [7748, 7748], [7750, 7750], [7752, 7752], [7754, 7754], [7756, 7756], [7758, 7758], [7760, 7760], [7762, 7762], [7764, 7764], [7766, 7766], [7768, 7768], [7770, 7770], [7772, 7772], [7774, 7774], [7776, 7776], [7778, 7778], [7780, 7780], [7782, 7782], [7784, 7784], [7786, 7786], [7788, 7788], [7790, 7790], [7792, 7792], [7794, 7794], [7796, 7796], [7798, 7798], [7800, 7800], [7802, 7802], [7804, 7804], [7806, 7806], [7808, 7808], [7810, 7810], [7812, 7812], [7814, 7814], [7816, 7816], [7818, 7818], [7820, 7820], [7822, 7822], [7824, 7824], [7826, 7826], [7828, 7828], [7838, 7838], [7840, 7840], [7842, 7842], [7844, 7844], [7846, 7846], [7848, 7848], [7850, 7850], [7852, 7852], [7854, 7854], [7856, 7856], [7858, 7858], [7860, 7860], [7862, 7862], [7864, 7864], [7866, 7866], [7868, 7868], [7870, 7870], [7872, 7872], [7874, 7874], [7876, 7876], [7878, 7878], [7880, 7880], [7882, 7882], [7884, 7884], [7886, 7886], [7888, 7888], [7890, 7890], [7892, 7892], [7894, 7894], [7896, 7896], [7898, 7898], [7900, 7900], [7902, 7902], [7904, 7904], [7906, 7906], [7908, 7908], [7910, 7910], [7912, 7912], [7914, 7914], [7916, 7916], [7918, 7918], [7920, 7920], [7922, 7922], [7924, 7924], [7926, 7926], [7928, 7928], [7930, 7930], [7932, 7932], [7934, 7934], [7944, 7951], [7960, 7965], [7976, 7983], [7992, 7999], [8008, 8013], [8025, 8025], [8027, 8027], [8029, 8029], [8031, 8031], [8040, 8047], [8120, 8123], [8136, 8139], [8152, 8155], [8168, 8172], [8184, 8187], [8450, 8450], [8455, 8455], [8459, 8461], [8464, 8466], [8469, 8469], [8473, 8477], [8484, 8484], [8486, 8486], [8488, 8488], [8490, 8493], [8496, 8499], [8510, 8511], [8517, 8517], [8579, 8579], [11264, 11310], [11360, 11360], [11362, 11364], [11367, 11367], [11369, 11369], [11371, 11371], [11373, 11376], [11378, 11378], [11381, 11381], [11390, 11392], [11394, 11394], [11396, 11396], [11398, 11398], [11400, 11400], [11402, 11402], [11404, 11404], [11406, 11406], [11408, 11408], [11410, 11410], [11412, 11412], [11414, 11414], [11416, 11416], [11418, 11418], [11420, 11420], [11422, 11422], [11424, 11424], [11426, 11426], [11428, 11428], [11430, 11430], [11432, 11432], [11434, 11434], [11436, 11436], [11438, 11438], [11440, 11440], [11442, 11442], [11444, 11444], [11446, 11446], [11448, 11448], [11450, 11450], [11452, 11452], [11454, 11454], [11456, 11456], [11458, 11458], [11460, 11460], [11462, 11462], [11464, 11464], [11466, 11466], [11468, 11468], [11470, 11470], [11472, 11472], [11474, 11474], [11476, 11476], [11478, 11478], [11480, 11480], [11482, 11482], [11484, 11484], [11486, 11486], [11488, 11488], [11490, 11490], [11499, 11499], [11501, 11501], [11506, 11506], [42560, 42560], [42562, 42562], [42564, 42564], [42566, 42566], [42568, 42568], [42570, 42570], [42572, 42572], [42574, 42574], [42576, 42576], [42578, 42578], [42580, 42580], [42582, 42582], [42584, 42584], [42586, 42586], [42588, 42588], [42590, 42590], [42592, 42592], [42594, 42594], [42596, 42596], [42598, 42598], [42600, 42600], [42602, 42602], [42604, 42604], [42624, 42624], [42626, 42626], [42628, 42628], [42630, 42630], [42632, 42632], [42634, 42634], [42636, 42636], [42638, 42638], [42640, 42640], [42642, 42642], [42644, 42644], [42646, 42646], [42648, 42648], [42650, 42650], [42786, 42786], [42788, 42788], [42790, 42790], [42792, 42792], [42794, 42794], [42796, 42796], [42798, 42798], [42802, 42802], [42804, 42804], [42806, 42806], [42808, 42808], [42810, 42810], [42812, 42812], [42814, 42814], [42816, 42816], [42818, 42818], [42820, 42820], [42822, 42822], [42824, 42824], [42826, 42826], [42828, 42828], [42830, 42830], [42832, 42832], [42834, 42834], [42836, 42836], [42838, 42838], [42840, 42840], [42842, 42842], [42844, 42844], [42846, 42846], [42848, 42848], [42850, 42850], [42852, 42852], [42854, 42854], [42856, 42856], [42858, 42858], [42860, 42860], [42862, 42862], [42873, 42873], [42875, 42875], [42877, 42878], [42880, 42880], [42882, 42882], [42884, 42884], [42886, 42886], [42891, 42891], [42893, 42893], [42896, 42896], [42898, 42898], [42902, 42902], [42904, 42904], [42906, 42906], [42908, 42908], [42910, 42910], [42912, 42912], [42914, 42914], [42916, 42916], [42918, 42918], [42920, 42920], [42922, 42926], [42928, 42932], [42934, 42934], [65313, 65338]], Pd: [[45, 45], [1418, 1418], [1470, 1470], [5120, 5120], [6150, 6150], [8208, 8213], [11799, 11799], [11802, 11802], [11834, 11835], [11840, 11840], [12316, 12316], [12336, 12336], [12448, 12448], [65073, 65074], [65112, 65112], [65123, 65123], [65293, 65293]], Cf: [[173, 173], [1536, 1541], [1564, 1564], [1757, 1757], [1807, 1807], [2274, 2274], [6158, 6158], [8203, 8207], [8234, 8238], [8288, 8292], [8294, 8303], [65279, 65279], [65529, 65531]], Nd: [[48, 57], [1632, 1641], [1776, 1785], [1984, 1993], [2406, 2415], [2534, 2543], [2662, 2671], [2790, 2799], [2918, 2927], [3046, 3055], [3174, 3183], [3302, 3311], [3430, 3439], [3558, 3567], [3664, 3673], [3792, 3801], [3872, 3881], [4160, 4169], [4240, 4249], [6112, 6121], [6160, 6169], [6470, 6479], [6608, 6617], [6784, 6793], [6800, 6809], [6992, 7001], [7088, 7097], [7232, 7241], [7248, 7257], [42528, 42537], [43216, 43225], [43264, 43273], [43472, 43481], [43504, 43513], [43600, 43609], [44016, 44025], [65296, 65305]], Ll: [[97, 122], [181, 181], [223, 246], [248, 255], [257, 257], [259, 259], [261, 261], [263, 263], [265, 265], [267, 267], [269, 269], [271, 271], [273, 273], [275, 275], [277, 277], [279, 279], [281, 281], [283, 283], [285, 285], [287, 287], [289, 289], [291, 291], [293, 293], [295, 295], [297, 297], [299, 299], [301, 301], [303, 303], [305, 305], [307, 307], [309, 309], [311, 312], [314, 314], [316, 316], [318, 318], [320, 320], [322, 322], [324, 324], [326, 326], [328, 329], [331, 331], [333, 333], [335, 335], [337, 337], [339, 339], [341, 341], [343, 343], [345, 345], [347, 347], [349, 349], [351, 351], [353, 353], [355, 355], [357, 357], [359, 359], [361, 361], [363, 363], [365, 365], [367, 367], [369, 369], [371, 371], [373, 373], [375, 375], [378, 378], [380, 380], [382, 384], [387, 387], [389, 389], [392, 392], [396, 397], [402, 402], [405, 405], [409, 411], [414, 414], [417, 417], [419, 419], [421, 421], [424, 424], [426, 427], [429, 429], [432, 432], [436, 436], [438, 438], [441, 442], [445, 447], [454, 454], [457, 457], [460, 460], [462, 462], [464, 464], [466, 466], [468, 468], [470, 470], [472, 472], [474, 474], [476, 477], [479, 479], [481, 481], [483, 483], [485, 485], [487, 487], [489, 489], [491, 491], [493, 493], [495, 496], [499, 499], [501, 501], [505, 505], [507, 507], [509, 509], [511, 511], [513, 513], [515, 515], [517, 517], [519, 519], [521, 521], [523, 523], [525, 525], [527, 527], [529, 529], [531, 531], [533, 533], [535, 535], [537, 537], [539, 539], [541, 541], [543, 543], [545, 545], [547, 547], [549, 549], [551, 551], [553, 553], [555, 555], [557, 557], [559, 559], [561, 561], [563, 569], [572, 572], [575, 576], [578, 578], [583, 583], [585, 585], [587, 587], [589, 589], [591, 659], [661, 687], [881, 881], [883, 883], [887, 887], [891, 893], [912, 912], [940, 974], [976, 977], [981, 983], [985, 985], [987, 987], [989, 989], [991, 991], [993, 993], [995, 995], [997, 997], [999, 999], [1001, 1001], [1003, 1003], [1005, 1005], [1007, 1011], [1013, 1013], [1016, 1016], [1019, 1020], [1072, 1119], [1121, 1121], [1123, 1123], [1125, 1125], [1127, 1127], [1129, 1129], [1131, 1131], [1133, 1133], [1135, 1135], [1137, 1137], [1139, 1139], [1141, 1141], [1143, 1143], [1145, 1145], [1147, 1147], [1149, 1149], [1151, 1151], [1153, 1153], [1163, 1163], [1165, 1165], [1167, 1167], [1169, 1169], [1171, 1171], [1173, 1173], [1175, 1175], [1177, 1177], [1179, 1179], [1181, 1181], [1183, 1183], [1185, 1185], [1187, 1187], [1189, 1189], [1191, 1191], [1193, 1193], [1195, 1195], [1197, 1197], [1199, 1199], [1201, 1201], [1203, 1203], [1205, 1205], [1207, 1207], [1209, 1209], [1211, 1211], [1213, 1213], [1215, 1215], [1218, 1218], [1220, 1220], [1222, 1222], [1224, 1224], [1226, 1226], [1228, 1228], [1230, 1231], [1233, 1233], [1235, 1235], [1237, 1237], [1239, 1239], [1241, 1241], [1243, 1243], [1245, 1245], [1247, 1247], [1249, 1249], [1251, 1251], [1253, 1253], [1255, 1255], [1257, 1257], [1259, 1259], [1261, 1261], [1263, 1263], [1265, 1265], [1267, 1267], [1269, 1269], [1271, 1271], [1273, 1273], [1275, 1275], [1277, 1277], [1279, 1279], [1281, 1281], [1283, 1283], [1285, 1285], [1287, 1287], [1289, 1289], [1291, 1291], [1293, 1293], [1295, 1295], [1297, 1297], [1299, 1299], [1301, 1301], [1303, 1303], [1305, 1305], [1307, 1307], [1309, 1309], [1311, 1311], [1313, 1313], [1315, 1315], [1317, 1317], [1319, 1319], [1321, 1321], [1323, 1323], [1325, 1325], [1327, 1327], [1377, 1415], [5112, 5117], [7296, 7304], [7424, 7467], [7531, 7543], [7545, 7578], [7681, 7681], [7683, 7683], [7685, 7685], [7687, 7687], [7689, 7689], [7691, 7691], [7693, 7693], [7695, 7695], [7697, 7697], [7699, 7699], [7701, 7701], [7703, 7703], [7705, 7705], [7707, 7707], [7709, 7709], [7711, 7711], [7713, 7713], [7715, 7715], [7717, 7717], [7719, 7719], [7721, 7721], [7723, 7723], [7725, 7725], [7727, 7727], [7729, 7729], [7731, 7731], [7733, 7733], [7735, 7735], [7737, 7737], [7739, 7739], [7741, 7741], [7743, 7743], [7745, 7745], [7747, 7747], [7749, 7749], [7751, 7751], [7753, 7753], [7755, 7755], [7757, 7757], [7759, 7759], [7761, 7761], [7763, 7763], [7765, 7765], [7767, 7767], [7769, 7769], [7771, 7771], [7773, 7773], [7775, 7775], [7777, 7777], [7779, 7779], [7781, 7781], [7783, 7783], [7785, 7785], [7787, 7787], [7789, 7789], [7791, 7791], [7793, 7793], [7795, 7795], [7797, 7797], [7799, 7799], [7801, 7801], [7803, 7803], [7805, 7805], [7807, 7807], [7809, 7809], [7811, 7811], [7813, 7813], [7815, 7815], [7817, 7817], [7819, 7819], [7821, 7821], [7823, 7823], [7825, 7825], [7827, 7827], [7829, 7837], [7839, 7839], [7841, 7841], [7843, 7843], [7845, 7845], [7847, 7847], [7849, 7849], [7851, 7851], [7853, 7853], [7855, 7855], [7857, 7857], [7859, 7859], [7861, 7861], [7863, 7863], [7865, 7865], [7867, 7867], [7869, 7869], [7871, 7871], [7873, 7873], [7875, 7875], [7877, 7877], [7879, 7879], [7881, 7881], [7883, 7883], [7885, 7885], [7887, 7887], [7889, 7889], [7891, 7891], [7893, 7893], [7895, 7895], [7897, 7897], [7899, 7899], [7901, 7901], [7903, 7903], [7905, 7905], [7907, 7907], [7909, 7909], [7911, 7911], [7913, 7913], [7915, 7915], [7917, 7917], [7919, 7919], [7921, 7921], [7923, 7923], [7925, 7925], [7927, 7927], [7929, 7929], [7931, 7931], [7933, 7933], [7935, 7943], [7952, 7957], [7968, 7975], [7984, 7991], [8e3, 8005], [8016, 8023], [8032, 8039], [8048, 8061], [8064, 8071], [8080, 8087], [8096, 8103], [8112, 8116], [8118, 8119], [8126, 8126], [8130, 8132], [8134, 8135], [8144, 8147], [8150, 8151], [8160, 8167], [8178, 8180], [8182, 8183], [8458, 8458], [8462, 8463], [8467, 8467], [8495, 8495], [8500, 8500], [8505, 8505], [8508, 8509], [8518, 8521], [8526, 8526], [8580, 8580], [11312, 11358], [11361, 11361], [11365, 11366], [11368, 11368], [11370, 11370], [11372, 11372], [11377, 11377], [11379, 11380], [11382, 11387], [11393, 11393], [11395, 11395], [11397, 11397], [11399, 11399], [11401, 11401], [11403, 11403], [11405, 11405], [11407, 11407], [11409, 11409], [11411, 11411], [11413, 11413], [11415, 11415], [11417, 11417], [11419, 11419], [11421, 11421], [11423, 11423], [11425, 11425], [11427, 11427], [11429, 11429], [11431, 11431], [11433, 11433], [11435, 11435], [11437, 11437], [11439, 11439], [11441, 11441], [11443, 11443], [11445, 11445], [11447, 11447], [11449, 11449], [11451, 11451], [11453, 11453], [11455, 11455], [11457, 11457], [11459, 11459], [11461, 11461], [11463, 11463], [11465, 11465], [11467, 11467], [11469, 11469], [11471, 11471], [11473, 11473], [11475, 11475], [11477, 11477], [11479, 11479], [11481, 11481], [11483, 11483], [11485, 11485], [11487, 11487], [11489, 11489], [11491, 11492], [11500, 11500], [11502, 11502], [11507, 11507], [11520, 11557], [11559, 11559], [11565, 11565], [42561, 42561], [42563, 42563], [42565, 42565], [42567, 42567], [42569, 42569], [42571, 42571], [42573, 42573], [42575, 42575], [42577, 42577], [42579, 42579], [42581, 42581], [42583, 42583], [42585, 42585], [42587, 42587], [42589, 42589], [42591, 42591], [42593, 42593], [42595, 42595], [42597, 42597], [42599, 42599], [42601, 42601], [42603, 42603], [42605, 42605], [42625, 42625], [42627, 42627], [42629, 42629], [42631, 42631], [42633, 42633], [42635, 42635], [42637, 42637], [42639, 42639], [42641, 42641], [42643, 42643], [42645, 42645], [42647, 42647], [42649, 42649], [42651, 42651], [42787, 42787], [42789, 42789], [42791, 42791], [42793, 42793], [42795, 42795], [42797, 42797], [42799, 42801], [42803, 42803], [42805, 42805], [42807, 42807], [42809, 42809], [42811, 42811], [42813, 42813], [42815, 42815], [42817, 42817], [42819, 42819], [42821, 42821], [42823, 42823], [42825, 42825], [42827, 42827], [42829, 42829], [42831, 42831], [42833, 42833], [42835, 42835], [42837, 42837], [42839, 42839], [42841, 42841], [42843, 42843], [42845, 42845], [42847, 42847], [42849, 42849], [42851, 42851], [42853, 42853], [42855, 42855], [42857, 42857], [42859, 42859], [42861, 42861], [42863, 42863], [42865, 42872], [42874, 42874], [42876, 42876], [42879, 42879], [42881, 42881], [42883, 42883], [42885, 42885], [42887, 42887], [42892, 42892], [42894, 42894], [42897, 42897], [42899, 42901], [42903, 42903], [42905, 42905], [42907, 42907], [42909, 42909], [42911, 42911], [42913, 42913], [42915, 42915], [42917, 42917], [42919, 42919], [42921, 42921], [42933, 42933], [42935, 42935], [43002, 43002], [43824, 43866], [43872, 43877], [43888, 43967], [64256, 64262], [64275, 64279], [65345, 65370]], No: [[178, 179], [185, 185], [188, 190], [2548, 2553], [2930, 2935], [3056, 3058], [3192, 3198], [3416, 3422], [3440, 3448], [3882, 3891], [4969, 4988], [6128, 6137], [6618, 6618], [8304, 8304], [8308, 8313], [8320, 8329], [8528, 8543], [8585, 8585], [9312, 9371], [9450, 9471], [10102, 10131], [11517, 11517], [12690, 12693], [12832, 12841], [12872, 12879], [12881, 12895], [12928, 12937], [12977, 12991], [43056, 43061]], Zs: [[32, 32], [160, 160], [5760, 5760], [8192, 8202], [8239, 8239], [8287, 8287], [12288, 12288]] } } }); unwrapExports(data_generated); var utils$2 = createCommonjsModule(function (e, t) { function r(e) { for (var t = e.toString(16); t.length < 4;)t = "0" + t; return t } t.__esModule = !0, t.normalize_ranges = function (e) { return e.sort(function (e, t) { return e[0] - t[0] }).reduce(function (e, t, n) { if (0 === n) return [t]; var r = e[e.length - 1], a = r[0], u = r[1], o = t[0], i = t[1]; return u + 1 === o ? e.slice(0, -1).concat([[a, i]]) : e.concat([t]) }, []) }, t.build_regex = function (e, t) { var n = e.map(function (e) { var t = e[0], n = e[1]; return t === n ? "\\u" + r(t) : "\\u" + r(t) + "-\\u" + r(n) }).join(""); return new RegExp("[" + n + "]", t) } }); unwrapExports(utils$2); var lib$5 = function (e, t) { var n = data_generated.get_data(), r = e.reduce(function (e, t) { return e.concat(n[t]) }, []); return utils$2.build_regex(utils$2.normalize_ranges(r), t) }, emojiRegex = emojiRegex$1(), cjkPattern = lib$3().source, asciiPunctuationCharRange = escapeStringRegexp("!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~"), punctuationCharRange = "".concat(asciiPunctuationCharRange).concat(lib$5(["Pc", "Pd", "Pe", "Pf", "Pi", "Po", "Ps"]).source.slice(1, -1)), punctuationRegex = new RegExp("[".concat(punctuationCharRange, "]")); function isExportDeclaration(e) { if (e) switch (e.type) { case "ExportDefaultDeclaration": case "ExportDefaultSpecifier": case "DeclareExportDeclaration": case "ExportNamedDeclaration": case "ExportAllDeclaration": return !0 }return !1 } function getParentExportDeclaration(e) { var t = e.getParentNode(); return "declaration" === e.getName() && isExportDeclaration(t) ? t : null } function getPenultimate(e) { return 1 < e.length ? e[e.length - 2] : null } function getLast$3(e) { return 0 < e.length ? e[e.length - 1] : null } function skip(i) { return function (e, t, n) { var r = n && n.backwards; if (!1 === t) return !1; for (var a = e.length, u = t; 0 <= u && u < a;) { var o = e.charAt(u); if (i instanceof RegExp) { if (!i.test(o)) return u } else if (-1 === i.indexOf(o)) return u; r ? u-- : u++ } return (-1 === u || u === a) && u } } var skipWhitespace = skip(/\s/), skipSpaces = skip(" \t"), skipToLineEnd = skip(",; \t"), skipEverythingButNewLine = skip(/[^\r\n]/); function skipInlineComment(e, t) { if (!1 === t) return !1; if ("/" === e.charAt(t) && "*" === e.charAt(t + 1)) for (var n = t + 2; n < e.length; ++n)if ("*" === e.charAt(n) && "/" === e.charAt(n + 1)) return n + 2; return t } function skipTrailingComment(e, t) { return !1 !== t && ("/" === e.charAt(t) && "/" === e.charAt(t + 1) ? skipEverythingButNewLine(e, t) : t) } function skipNewline$1(e, t, n) { var r = n && n.backwards; if (!1 === t) return !1; var a = e.charAt(t); if (r) { if ("\r" === e.charAt(t - 1) && "\n" === a) return t - 2; if ("\n" === a || "\r" === a || "\u2028" === a || "\u2029" === a) return t - 1 } else { if ("\r" === a && "\n" === e.charAt(t + 1)) return t + 2; if ("\n" === a || "\r" === a || "\u2028" === a || "\u2029" === a) return t + 1 } return t } function hasNewline$1(e, t, n) { var r = skipSpaces(e, (n = n || {}).backwards ? t - 1 : t, n); return r !== skipNewline$1(e, r, n) } function hasNewlineInRange(e, t, n) { for (var r = t; r < n; ++r)if ("\n" === e.charAt(r)) return !0; return !1 } function isPreviousLineEmpty$1(e, t, n) { var r = n(t) - 1; return r = skipNewline$1(e, r = skipSpaces(e, r, { backwards: !0 }), { backwards: !0 }), (r = skipSpaces(e, r, { backwards: !0 })) !== skipNewline$1(e, r, { backwards: !0 }) } function isNextLineEmptyAfterIndex(e, t) { for (var n = null, r = t; r !== n;)r = skipInlineComment(e, r = skipToLineEnd(e, n = r)), r = skipSpaces(e, r); return hasNewline$1(e, r = skipNewline$1(e, r = skipTrailingComment(e, r))) } function isNextLineEmpty(e, t, n) { return isNextLineEmptyAfterIndex(e, n(t)) } function getNextNonSpaceNonCommentCharacterIndex(e, t, n) { for (var r = null, a = n(t); a !== r;)a = skipNewline$1(e, a = skipTrailingComment(e, a = skipInlineComment(e, a = skipSpaces(e, r = a)))); return a } function getNextNonSpaceNonCommentCharacter(e, t, n) { return e.charAt(getNextNonSpaceNonCommentCharacterIndex(e, t, n)) } function hasSpaces(e, t, n) { return skipSpaces(e, (n = n || {}).backwards ? t - 1 : t, n) !== t } function setLocStart(e, t) { e.range ? e.range[0] = t : e.start = t } function setLocEnd(e, t) { e.range ? e.range[1] = t : e.end = t } var PRECEDENCE = {}; function getPrecedence(e) { return PRECEDENCE[e] } [["|>"], ["||", "??"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]].forEach(function (e, t) { e.forEach(function (e) { PRECEDENCE[e] = t }) }); var equalityOperators = { "==": !0, "!=": !0, "===": !0, "!==": !0 }, additiveOperators = { "+": !0, "-": !0 }, multiplicativeOperators = { "*": !0, "/": !0, "%": !0 }, bitshiftOperators = { ">>": !0, ">>>": !0, "<<": !0 }; function shouldFlatten(e, t) { return getPrecedence(t) !== getPrecedence(e) ? "%" === t && !additiveOperators[e] : "**" !== e && ((!equalityOperators[e] || !equalityOperators[t]) && (!("%" === t && multiplicativeOperators[e] || "%" === e && multiplicativeOperators[t]) && ((t === e || !multiplicativeOperators[t] || !multiplicativeOperators[e]) && (!bitshiftOperators[e] || !bitshiftOperators[t])))) } function isBitwiseOperator(e) { return !!bitshiftOperators[e] || "|" === e || "^" === e || "&" === e } function startsWithNoLookaheadToken(e, t) { switch ((e = getLeftMost(e)).type) { case "ObjectPattern": return !t; case "FunctionExpression": case "ClassExpression": case "DoExpression": return t; case "ObjectExpression": return !0; case "MemberExpression": return startsWithNoLookaheadToken(e.object, t); case "TaggedTemplateExpression": return "FunctionExpression" !== e.tag.type && startsWithNoLookaheadToken(e.tag, t); case "CallExpression": return "FunctionExpression" !== e.callee.type && startsWithNoLookaheadToken(e.callee, t); case "ConditionalExpression": return startsWithNoLookaheadToken(e.test, t); case "UpdateExpression": return !e.prefix && startsWithNoLookaheadToken(e.argument, t); case "BindExpression": return e.object && startsWithNoLookaheadToken(e.object, t); case "SequenceExpression": return startsWithNoLookaheadToken(e.expressions[0], t); case "TSAsExpression": return startsWithNoLookaheadToken(e.expression, t); default: return !1 } } function getLeftMost(e) { return e.left ? getLeftMost(e.left) : e } function getAlignmentSize(e, t, n) { for (var r = 0, a = n = n || 0; a < e.length; ++a)"\t" === e[a] ? r = r + t - r % t : r++; return r } function getIndentSize(e, t) { var n = e.lastIndexOf("\n"); return -1 === n ? 0 : getAlignmentSize(e.slice(n + 1).match(/^[ \t]*/)[0], t) } function printString(e, t, n) { var r = e.slice(1, -1), a = { quote: '"', regex: /"/g }, u = { quote: "'", regex: /'/g }, o = t.singleQuote ? u : a, i = o === u ? a : u, s = !1, c = !1; if (r.includes(o.quote) || r.includes(i.quote)) { var l = (r.match(o.regex) || []).length; s = (r.match(i.regex) || []).length < l } else c = !0; var p = "json" === t.parser ? a.quote : s ? i.quote : o.quote; return n ? c ? p + r + p : e : makeString(r, p, !("css" === t.parser || "less" === t.parser || "scss" === t.parser)) } function makeString(e, r, a) { var u = '"' === r ? "'" : '"', t = e.replace(/\\([\s\S])|(['"])/g, function (e, t, n) { return t === u ? t : n === r ? "\\" + n : n || (a && /^[^\\nrvtbfux\r\n\u2028\u2029"'0-7]$/.test(t) ? t : "\\" + t) }); return r + t + r } function printNumber(e) { return e.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "") } function getMaxContinuousCount(e, n) { var t = e.match(new RegExp("(".concat(escapeStringRegexp(n), ")+"), "g")); return null === t ? 0 : t.reduce(function (e, t) { return Math.max(e, t.length / n.length) }, 0) } function splitText(e, t) { var a = "non-cjk", u = "cjk-character", o = "cjk-punctuation", i = []; return ("preserve" === t.proseWrap ? e : e.replace(new RegExp("(".concat(cjkPattern, ")\n(").concat(cjkPattern, ")"), "g"), "$1$2")).split(/([ \t\n]+)/).forEach(function (e, t, n) { t % 2 != 1 ? (0 !== t && t !== n.length - 1 || "" !== e) && e.split(new RegExp("(".concat(cjkPattern, ")"))).forEach(function (e, t, n) { (0 !== t && t !== n.length - 1 || "" !== e) && (t % 2 != 0 ? r(punctuationRegex.test(e) ? { type: "word", value: e, kind: o, hasLeadingPunctuation: !0, hasTrailingPunctuation: !0 } : { type: "word", value: e, kind: u, hasLeadingPunctuation: !1, hasTrailingPunctuation: !1 }) : "" !== e && r({ type: "word", value: e, kind: a, hasLeadingPunctuation: punctuationRegex.test(e[0]), hasTrailingPunctuation: punctuationRegex.test(getLast$3(e)) })) }) : i.push({ type: "whitespace", value: /\n/.test(e) ? "\n" : " " }) }), i; function r(e) { var t, n, r = getLast$3(i); r && "word" === r.type && (r.kind === a && e.kind === u && !r.hasTrailingPunctuation || r.kind === u && e.kind === a && !e.hasLeadingPunctuation ? i.push({ type: "whitespace", value: " " }) : (t = a, n = o, r.kind === t && e.kind === n || r.kind === n && e.kind === t || [r.value, e.value].some(function (e) { return /\u3000/.test(e) }) || i.push({ type: "whitespace", value: "" }))), i.push(e) } } function getStringWidth(e) { return e ? stringWidth(e.replace(emojiRegex, "  ")) : 0 } function hasIgnoreComment(e) { return hasNodeIgnoreComment(e.getValue()) } function hasNodeIgnoreComment(e) { return e && e.comments && 0 < e.comments.length && e.comments.some(function (e) { return "prettier-ignore" === e.value.trim() }) } function addCommentHelper(e, t) { (e.comments || (e.comments = [])).push(t), t.printed = !1, "JSXText" === e.type && (t.printed = !0) } function addLeadingComment$1(e, t) { t.leading = !0, t.trailing = !1, addCommentHelper(e, t) } function addDanglingComment$1(e, t) { t.leading = !1, t.trailing = !1, addCommentHelper(e, t) } function addTrailingComment$1(e, t) { t.leading = !1, t.trailing = !0, addCommentHelper(e, t) } var util = { punctuationRegex: punctuationRegex, punctuationCharRange: punctuationCharRange, getStringWidth: getStringWidth, splitText: splitText, getMaxContinuousCount: getMaxContinuousCount, getPrecedence: getPrecedence, shouldFlatten: shouldFlatten, isBitwiseOperator: isBitwiseOperator, isExportDeclaration: isExportDeclaration, getParentExportDeclaration: getParentExportDeclaration, getPenultimate: getPenultimate, getLast: getLast$3, getNextNonSpaceNonCommentCharacterIndex: getNextNonSpaceNonCommentCharacterIndex, getNextNonSpaceNonCommentCharacter: getNextNonSpaceNonCommentCharacter, skipWhitespace: skipWhitespace, skipSpaces: skipSpaces, skipNewline: skipNewline$1, isNextLineEmptyAfterIndex: isNextLineEmptyAfterIndex, isNextLineEmpty: isNextLineEmpty, isPreviousLineEmpty: isPreviousLineEmpty$1, hasNewline: hasNewline$1, hasNewlineInRange: hasNewlineInRange, hasSpaces: hasSpaces, setLocStart: setLocStart, setLocEnd: setLocEnd, startsWithNoLookaheadToken: startsWithNoLookaheadToken, getAlignmentSize: getAlignmentSize, getIndentSize: getIndentSize, printString: printString, printNumber: printNumber, hasIgnoreComment: hasIgnoreComment, hasNodeIgnoreComment: hasNodeIgnoreComment, makeString: makeString, addLeadingComment: addLeadingComment$1, addDanglingComment: addDanglingComment$1, addTrailingComment: addTrailingComment$1 }, concat$2 = docBuilders.concat, fill$1 = docBuilders.fill, cursor$2 = docBuilders.cursor, MODE_BREAK = 1, MODE_FLAT = 2; function rootIndent() { return { value: "", length: 0, queue: [] } } function makeIndent(e, t) { return generateInd(e, { type: "indent" }, t) } function makeAlign(e, t, n) { return t === -1 / 0 ? e.root || rootIndent() : t < 0 ? generateInd(e, { type: "dedent" }, n) : t ? "root" === t.type ? Object.assign({}, e, { root: e }) : generateInd(e, "string" == typeof t ? { type: "stringAlign", n: t } : { type: "numberAlign", n: t }, n) : e } function generateInd(e, t, n) { var r = "dedent" === t.type ? e.queue.slice(0, -1) : e.queue.concat(t), a = "", u = 0, o = 0, i = 0, s = !0, c = !1, l = void 0; try { for (var p, d = r[Symbol.iterator](); !(s = (p = d.next()).done); s = !0) { var m = p.value; switch (m.type) { case "indent": g(), n.useTabs ? f(1) : D(n.tabWidth); break; case "stringAlign": g(), a += m.n, u += m.n.length; break; case "numberAlign": o += 1, i += m.n; break; default: throw new Error("Unexpected type '".concat(m.type, "'")) } } } catch (e) { c = !0, l = e } finally { try { s || null == d.return || d.return() } finally { if (c) throw l } } return h(), Object.assign({}, e, { value: a, length: u, queue: r }); function f(e) { a += "\t".repeat(e), u += n.tabWidth * e } function D(e) { a += " ".repeat(e), u += e } function g() { n.useTabs ? function () { 0 < o && f(o); y() }() : h() } function h() { 0 < i && D(i), y() } function y() { i = o = 0 } } function fits(e, t, n, r, a) { for (var u = t.length, o = [e]; 0 <= n;)if (0 !== o.length) { var i = o.pop(), s = i[0], c = i[1], l = i[2]; if ("string" == typeof l) n -= util.getStringWidth(l); else switch (l.type) { case "concat": for (var p = l.parts.length - 1; 0 <= p; p--)o.push([s, c, l.parts[p]]); break; case "indent": o.push([makeIndent(s, r), c, l.contents]); break; case "align": o.push([makeAlign(s, l.n, r), c, l.contents]); break; case "group": if (a && l.break) return !1; o.push([s, l.break ? MODE_BREAK : c, l.contents]); break; case "fill": for (var d = l.parts.length - 1; 0 <= d; d--)o.push([s, c, l.parts[d]]); break; case "if-break": c === MODE_BREAK && l.breakContents && o.push([s, c, l.breakContents]), c === MODE_FLAT && l.flatContents && o.push([s, c, l.flatContents]); break; case "line": switch (c) { case MODE_FLAT: if (l.hard) return !0; l.soft || (n -= 1); break; case MODE_BREAK: return !0 } } } else { if (0 === u) return !0; o.push(t[u - 1]), u-- } return !1 } function printDocToString(e, t) { for (var n = t.printWidth, r = t.newLine || "\n", a = 0, u = [[rootIndent(), MODE_BREAK, e]], o = [], i = !1, s = []; 0 !== u.length;) { var c = u.pop(), l = c[0], p = c[1], d = c[2]; if ("string" == typeof d) o.push(d), a += util.getStringWidth(d); else switch (d.type) { case "cursor": o.push(cursor$2.placeholder); break; case "concat": for (var m = d.parts.length - 1; 0 <= m; m--)u.push([l, p, d.parts[m]]); break; case "indent": u.push([makeIndent(l, t), p, d.contents]); break; case "align": u.push([makeAlign(l, d.n, t), p, d.contents]); break; case "group": switch (p) { case MODE_FLAT: if (!i) { u.push([l, d.break ? MODE_BREAK : MODE_FLAT, d.contents]); break } case MODE_BREAK: i = !1; var f = [l, MODE_FLAT, d.contents], D = n - a; if (!d.break && fits(f, u, D, t)) u.push(f); else if (d.expandedStates) { var g = d.expandedStates[d.expandedStates.length - 1]; if (d.break) { u.push([l, MODE_BREAK, g]); break } for (var h = 1; h < d.expandedStates.length + 1; h++) { if (h >= d.expandedStates.length) { u.push([l, MODE_BREAK, g]); break } var y = d.expandedStates[h], C = [l, MODE_FLAT, y]; if (fits(C, u, D, t)) { u.push(C); break } } } else u.push([l, MODE_BREAK, d.contents]) }break; case "fill": var $ = n - a, E = d.parts; if (0 === E.length) break; var A = E[0], v = [l, MODE_FLAT, A], F = [l, MODE_BREAK, A], b = fits(v, [], $, t, !0); if (1 === E.length) { b ? u.push(v) : u.push(F); break } var x = E[1], S = [l, MODE_FLAT, x], B = [l, MODE_BREAK, x]; if (2 === E.length) { b ? (u.push(S), u.push(v)) : (u.push(B), u.push(F)); break } E.splice(0, 2); var T = [l, p, fill$1(E)], N = E[0]; fits([l, MODE_FLAT, concat$2([A, x, N])], [], $, t, !0) ? (u.push(T), u.push(S), u.push(v)) : b ? (u.push(T), u.push(B), u.push(v)) : (u.push(T), u.push(B), u.push(F)); break; case "if-break": p === MODE_BREAK && d.breakContents && u.push([l, p, d.breakContents]), p === MODE_FLAT && d.flatContents && u.push([l, p, d.flatContents]); break; case "line-suffix": s.push([l, p, d.contents]); break; case "line-suffix-boundary": 0 < s.length && u.push([l, p, { type: "line", hard: !0 }]); break; case "line": switch (p) { case MODE_FLAT: if (!d.hard) { d.soft || (o.push(" "), a += 1); break } i = !0; case MODE_BREAK: if (s.length) { u.push([l, p, d]), [].push.apply(u, s.reverse()), s = []; break } if (d.literal) a = l.root ? (o.push(r, l.root.value), l.root.length) : (o.push(r), 0); else { if (0 < o.length) { for (; 0 < o.length && "string" == typeof o[o.length - 1] && o[o.length - 1].match(/^[^\S\n]*$/);)o.pop(); !o.length || "string" != typeof o[o.length - 1] || "markdown" === t.parser && /\S {2}$/.test(o[o.length - 1]) || (o[o.length - 1] = o[o.length - 1].replace(/[^\S\n]*$/, "")) } o.push(r + l.value), a = l.length } } } } var w = o.indexOf(cursor$2.placeholder); if (-1 === w) return { formatted: o.join("") }; var P = o.indexOf(cursor$2.placeholder, w + 1), k = o.slice(0, w).join(""), O = o.slice(w + 1, P).join(""); return { formatted: k + O + o.slice(P + 1).join(""), cursorNodeStart: k.length, cursorNodeText: O } } var docPrinter = { printDocToString: printDocToString }; function traverseDoc(e, a, u, o) { !function e(t) { var n = !0; if (a && !1 === a(t) && (n = !1), n) if ("concat" === t.type || "fill" === t.type) for (var r = 0; r < t.parts.length; r++)e(t.parts[r]); else "if-break" === t.type ? (t.breakContents && e(t.breakContents), t.flatContents && e(t.flatContents)) : "group" === t.type && t.expandedStates ? o ? t.expandedStates.forEach(e) : e(t.contents) : t.contents && e(t.contents); u && u(t) }(e) } function mapDoc(e, t) { if ("concat" === e.type || "fill" === e.type) { var n = e.parts.map(function (e) { return mapDoc(e, t) }); return t(Object.assign({}, e, { parts: n })) } if ("if-break" === e.type) { var r = e.breakContents && mapDoc(e.breakContents, t), a = e.flatContents && mapDoc(e.flatContents, t); return t(Object.assign({}, e, { breakContents: r, flatContents: a })) } if (e.contents) { var u = mapDoc(e.contents, t); return t(Object.assign({}, e, { contents: u })) } return t(e) } function findInDoc(e, n, t) { var r = t, a = !1; return traverseDoc(e, function (e) { var t = n(e); if (void 0 !== t && (a = !0, r = t), a) return !1 }), r } function isEmpty(e) { return "string" == typeof e && 0 === e.length } function isLineNext(e) { return findInDoc(e, function (e) { return "string" != typeof e && ("line" === e.type || void 0) }, !1) } function willBreak(e) { return findInDoc(e, function (e) { return !("group" !== e.type || !e.break) || (!("line" !== e.type || !e.hard) || ("break-parent" === e.type || void 0)) }, !1) } function breakParentGroup(e) { if (0 < e.length) { var t = e[e.length - 1]; t.expandedStates || (t.break = !0) } return null } function propagateBreaks(e) { var t = new Map, n = []; traverseDoc(e, function (e) { if ("break-parent" === e.type && breakParentGroup(n), "group" === e.type) { if (n.push(e), t.has(e)) return !1; t.set(e, !0) } }, function (e) { "group" === e.type && n.pop().break && breakParentGroup(n) }, !0) } function removeLines(e) { return mapDoc(e, function (e) { return "line" !== e.type || e.hard ? "if-break" === e.type ? e.flatContents || "" : e : e.soft ? "" : " " }) } function stripTrailingHardline(e) { return "concat" === e.type && 2 === e.parts.length && "concat" === e.parts[1].type && 2 === e.parts[1].parts.length && e.parts[1].parts[0].hard && "break-parent" === e.parts[1].parts[1].type ? e.parts[0] : e } var docUtils = { isEmpty: isEmpty, willBreak: willBreak, isLineNext: isLineNext, traverseDoc: traverseDoc, mapDoc: mapDoc, propagateBreaks: propagateBreaks, removeLines: removeLines, stripTrailingHardline: stripTrailingHardline }; function flattenDoc(e) { if ("concat" !== e.type) return "if-break" === e.type ? Object.assign({}, e, { breakContents: null != e.breakContents ? flattenDoc(e.breakContents) : null, flatContents: null != e.flatContents ? flattenDoc(e.flatContents) : null }) : "group" === e.type ? Object.assign({}, e, { contents: flattenDoc(e.contents), expandedStates: e.expandedStates ? e.expandedStates.map(flattenDoc) : e.expandedStates }) : e.contents ? Object.assign({}, e, { contents: flattenDoc(e.contents) }) : e; for (var t = [], n = 0; n < e.parts.length; ++n) { var r = e.parts[n]; if ("string" != typeof r && "concat" === r.type) [].push.apply(t, flattenDoc(r).parts); else { var a = flattenDoc(r); "" !== a && t.push(a) } } return Object.assign({}, e, { parts: t }) } function printDoc(e) { if ("string" == typeof e) return JSON.stringify(e); if ("line" === e.type) return e.literalline ? "literalline" : e.hard ? "hardline" : e.soft ? "softline" : "line"; if ("break-parent" === e.type) return "breakParent"; if ("concat" === e.type) return "[" + e.parts.map(printDoc).join(", ") + "]"; if ("indent" === e.type) return "indent(" + printDoc(e.contents) + ")"; if ("align" === e.type) return e.n === -1 / 0 ? "dedentToRoot(" + printDoc(e.contents) + ")" : e.n < 0 ? "dedent(" + printDoc(e.contents) + ")" : "root" === e.n.type ? "markAsRoot(" + printDoc(e.contents) + ")" : "align(" + JSON.stringify(e.n) + ", " + printDoc(e.contents) + ")"; if ("if-break" === e.type) return "ifBreak(" + printDoc(e.breakContents) + (e.flatContents ? ", " + printDoc(e.flatContents) : "") + ")"; if ("group" === e.type) return e.expandedStates ? "conditionalGroup([" + e.expandedStates.map(printDoc).join(",") + "])" : (e.break ? "wrappedGroup" : "group") + "(" + printDoc(e.contents) + ")"; if ("fill" === e.type) return "fill(" + e.parts.map(printDoc).join(", ") + ")"; if ("line-suffix" === e.type) return "lineSuffix(" + printDoc(e.contents) + ")"; if ("line-suffix-boundary" === e.type) return "lineSuffixBoundary"; throw new Error("Unknown doc type " + e.type) } var docDebug = { printDocToDebug: function (e) { return printDoc(flattenDoc(e)) } }, doc = { builders: docBuilders, printer: docPrinter, utils: docUtils, debug: docDebug }, mapDoc$1 = doc.utils.mapDoc; function isNextLineEmpty$1(e, t, n) { return util.isNextLineEmpty(e, t, n.locEnd) } function getNextNonSpaceNonCommentCharacterIndex$1(e, t, n) { return util.getNextNonSpaceNonCommentCharacterIndex(e, t, n.locEnd) } var utilShared = { isNextLineEmpty: isNextLineEmpty$1, isNextLineEmptyAfterIndex: util.isNextLineEmptyAfterIndex, getNextNonSpaceNonCommentCharacterIndex: getNextNonSpaceNonCommentCharacterIndex$1, mapDoc: mapDoc$1, makeString: util.makeString, addLeadingComment: util.addLeadingComment, addDanglingComment: util.addDanglingComment, addTrailingComment: util.addTrailingComment }, _require$$0$builders = doc.builders, concat = _require$$0$builders.concat, hardline = _require$$0$builders.hardline, breakParent = _require$$0$builders.breakParent, indent = _require$$0$builders.indent, lineSuffix = _require$$0$builders.lineSuffix, join = _require$$0$builders.join, cursor = _require$$0$builders.cursor, hasNewline = util.hasNewline, skipNewline = util.skipNewline, isPreviousLineEmpty = util.isPreviousLineEmpty, addLeadingComment = utilShared.addLeadingComment, addDanglingComment = utilShared.addDanglingComment, addTrailingComment = utilShared.addTrailingComment, childNodesCacheKey = Symbol("child-nodes"); function getSortedChildNodes(t, n, r) { if (t) { var e, a = n.printer, u = n.locStart, o = n.locEnd; if (r) { if (t && a.canAttachComment && a.canAttachComment(t)) { var i; for (i = r.length - 1; 0 <= i && !(u(r[i]) <= u(t) && o(r[i]) <= o(t)); --i); return void r.splice(i + 1, 0, t) } } else if (t[childNodesCacheKey]) return t[childNodesCacheKey]; if (a.getCommentChildNodes ? e = a.getCommentChildNodes(t) : t && "object" === _typeof(t) && (e = Object.keys(t).filter(function (e) { return "enclosingNode" !== e && "precedingNode" !== e && "followingNode" !== e }).map(function (e) { return t[e] })), e) return r || Object.defineProperty(t, childNodesCacheKey, { value: r = [], enumerable: !1 }), e.forEach(function (e) { getSortedChildNodes(e, n, r) }), r } } function decorateComment(e, t, n) { for (var r, a, u = n.locStart, o = n.locEnd, i = getSortedChildNodes(e, n), s = 0, c = i.length; s < c;) { var l = s + c >> 1, p = i[l]; if (u(p) - u(t) <= 0 && o(t) - o(p) <= 0) return void decorateComment(t.enclosingNode = p, t, n); if (o(p) - u(t) <= 0) r = p, s = 1 + l; else { if (!(o(t) - u(p) <= 0)) throw new Error("Comment location overlaps with node location"); a = p, c = l } } if (t.enclosingNode && "TemplateLiteral" === t.enclosingNode.type) { var d = t.enclosingNode.quasis, m = findExpressionIndexForComment(d, t, n); r && findExpressionIndexForComment(d, r, n) !== m && (r = null), a && findExpressionIndexForComment(d, a, n) !== m && (a = null) } r && (t.precedingNode = r), a && (t.followingNode = a) } function attach(l, p, d, m) { if (Array.isArray(l)) { var f = [], D = m.locStart, g = m.locEnd; l.forEach(function (e, t) { if (("json" === m.parser || "json5" === m.parser) && D(e) - D(p) <= 0) addLeadingComment(p, e); else { decorateComment(p, e, m); var n = e.precedingNode, r = e.enclosingNode, a = e.followingNode, u = m.printer.handleComments && m.printer.handleComments.ownLine ? m.printer.handleComments.ownLine : function () { return !1 }, o = m.printer.handleComments && m.printer.handleComments.endOfLine ? m.printer.handleComments.endOfLine : function () { return !1 }, i = m.printer.handleComments && m.printer.handleComments.remaining ? m.printer.handleComments.remaining : function () { return !1 }, s = l.length - 1 === t; if (hasNewline(d, D(e), { backwards: !0 })) u(e, d, m, p, s) || (a ? addLeadingComment(a, e) : n ? addTrailingComment(n, e) : addDanglingComment(r || p, e)); else if (hasNewline(d, g(e))) o(e, d, m, p, s) || (n ? addTrailingComment(n, e) : a ? addLeadingComment(a, e) : addDanglingComment(r || p, e)); else if (i(e, d, m, p, s)); else if (n && a) { var c = f.length; if (0 < c) f[c - 1].followingNode !== e.followingNode && breakTies(f, d, m); f.push(e) } else n ? addTrailingComment(n, e) : a ? addLeadingComment(a, e) : addDanglingComment(r || p, e) } }), breakTies(f, d, m), l.forEach(function (e) { delete e.precedingNode, delete e.enclosingNode, delete e.followingNode }) } } function breakTies(e, t, n) { var r = e.length; if (0 !== r) { var a, u = e[0].precedingNode, o = e[0].followingNode, i = n.locStart(o); for (a = r; 0 < a; --a) { var s = e[a - 1]; assert.strictEqual(s.precedingNode, u), assert.strictEqual(s.followingNode, o); var c = t.slice(n.locEnd(s), i).trim(); if ("" !== c && !/^\(+$/.test(c)) break; i = n.locStart(s) } e.forEach(function (e, t) { t < a ? addTrailingComment(u, e) : addLeadingComment(o, e) }), e.length = 0 } } function printComment(e, t) { return e.getValue().printed = !0, t.printer.printComment(e, t) } function findExpressionIndexForComment(e, t, n) { for (var r = n.locStart(t) - 1, a = 1; a < e.length; ++a)if (r < getQuasiRange(e[a]).start) return a - 1; return 0 } function getQuasiRange(e) { return void 0 !== e.start ? { start: e.start, end: e.end } : { start: e.range[0], end: e.range[1] } } function printLeadingComment(e, t, n) { var r = e.getValue(), a = printComment(e, n); if (!a) return ""; var u = n.printer.isBlockComment && n.printer.isBlockComment(r); return concat(u ? [a, hasNewline(n.originalText, n.locEnd(r)) ? hardline : " "] : [a, hardline]) } function printTrailingComment(e, t, n) { var r = e.getValue(), a = printComment(e, n); if (!a) return ""; var u = n.printer.isBlockComment && n.printer.isBlockComment(r), o = e.getNode(1), i = e.getNode(2), s = i && ("ClassDeclaration" === i.type || "ClassExpression" === i.type) && i.superClass === o; if (hasNewline(n.originalText, n.locStart(r), { backwards: !0 })) { var c = isPreviousLineEmpty(n.originalText, r, n.locStart); return lineSuffix(concat([hardline, c ? hardline : "", a])) } return concat(u || s ? [" ", a] : [lineSuffix(" " + a), u ? "" : breakParent]) } function printDanglingComments(e, n, t, r) { var a = [], u = e.getValue(); return u && u.comments ? (e.each(function (e) { var t = e.getValue(); !t || t.leading || t.trailing || r && !r(t) || a.push(printComment(e, n)) }, "comments"), 0 === a.length ? "" : t ? join(hardline, a) : indent(concat([hardline, join(hardline, a)]))) : "" } function prependCursorPlaceholder(e, t, n) { return e.getNode() === t.cursorNode && e.getValue() ? concat([cursor, n, cursor]) : n } function printComments(e, o, i, t) { var n = e.getValue(), r = o(e), a = n && n.comments; if (!a || 0 === a.length) return prependCursorPlaceholder(e, i, r); var s = [], c = [t ? ";" : "", r]; return e.each(function (e) { var t = e.getValue(), n = t.leading, r = t.trailing; if (n) { var a = printLeadingComment(e, o, i); if (!a) return; s.push(a); var u = i.originalText; hasNewline(u, skipNewline(u, i.locEnd(t))) && s.push(hardline) } else r && c.push(printTrailingComment(e, o, i)) }, "comments"), prependCursorPlaceholder(e, i, concat(s.concat(c))) } var comments = { attach: attach, printComments: printComments, printDanglingComments: printDanglingComments, getSortedChildNodes: getSortedChildNodes }; function FastPath(e) { assert.ok(this instanceof FastPath), this.stack = [e] } function getNodeHelper(e, t) { for (var n = e.stack, r = n.length - 1; 0 <= r; r -= 2) { var a = n[r]; if (a && !Array.isArray(a) && --t < 0) return a } return null } FastPath.prototype.getName = function () { var e = this.stack, t = e.length; return 1 < t ? e[t - 2] : null }, FastPath.prototype.getValue = function () { var e = this.stack; return e[e.length - 1] }, FastPath.prototype.getNode = function (e) { return getNodeHelper(this, ~~e) }, FastPath.prototype.getParentNode = function (e) { return getNodeHelper(this, 1 + ~~e) }, FastPath.prototype.call = function (e) { for (var t = this.stack, n = t.length, r = t[n - 1], a = arguments.length, u = 1; u < a; ++u) { var o = arguments[u]; r = r[o], t.push(o, r) } var i = e(this); return t.length = n, i }, FastPath.prototype.each = function (e) { for (var t = this.stack, n = t.length, r = t[n - 1], a = arguments.length, u = 1; u < a; ++u) { var o = arguments[u]; r = r[o], t.push(o, r) } for (var i = 0; i < r.length; ++i)i in r && (t.push(i, r[i]), e(this), t.length -= 2); t.length = n }, FastPath.prototype.map = function (e) { for (var t = this.stack, n = t.length, r = t[n - 1], a = arguments.length, u = 1; u < a; ++u) { var o = arguments[u]; r = r[o], t.push(o, r) } for (var i = new Array(r.length), s = 0; s < r.length; ++s)s in r && (t.push(s, r[s]), i[s] = e(this, s), t.length -= 2); return t.length = n, i }; var fastPath = FastPath, normalize$1 = options.normalize; function printSubtree(e, t, n, r) { if (n.printer.embed) return n.printer.embed(e, t, function (e, t) { return textToDoc(e, t, n, r) }, n) } function textToDoc(e, t, n, r) { var a = normalize$1(Object.assign({}, n, t, { parentParser: n.parser, originalText: e }), { passThrough: !0 }), u = parser.parse(e, a), o = u.ast; e = u.text; var i = o.comments; return delete o.comments, comments.attach(i, o, e, a), r(o, a) } var multiparser = { printSubtree: printSubtree }, doc$2 = doc, docBuilders$2 = doc$2.builders, concat$3 = docBuilders$2.concat, hardline$2 = docBuilders$2.hardline, addAlignmentToDoc$1 = docBuilders$2.addAlignmentToDoc, docUtils$2 = doc$2.utils; function printAstToDoc(e, o, t) { t = t || 0; var i = o.printer, s = new Map; var n = function t(e, n) { var r, a = e.getValue(), u = a && "object" === _typeof(a) && void 0 === n; return u && s.has(a) ? s.get(a) : (r = i.willPrintOwnComments && i.willPrintOwnComments(e) ? genericPrint(e, o, t, n) : comments.printComments(e, function (e) { return genericPrint(e, o, t, n) }, o, n && n.needsSemi), u && s.set(a, r), r) }(new fastPath(e)); return 0 < t && (n = addAlignmentToDoc$1(docUtils$2.removeLines(concat$3([hardline$2, n])), t, o.tabWidth)), docUtils$2.propagateBreaks(n), "json" !== o.parser && "json5" !== o.parser && "json-stringify" !== o.parser || (n = concat$3([n, hardline$2])), n } function genericPrint(e, t, n, r) { assert.ok(e instanceof fastPath); var a = e.getValue(), u = t.printer; if (u.hasPrettierIgnore && u.hasPrettierIgnore(e)) return t.originalText.slice(t.locStart(a), t.locEnd(a)); if (a) try { var o = multiparser.printSubtree(e, n, t, printAstToDoc); if (o) return o } catch (e) { if (commonjsGlobal.PRETTIER_DEBUG) throw e } return u.print(e, t, n, r) } var astToDoc = printAstToDoc; function findSiblingAncestors(e, t, n) { var r = e.node, a = t.node; if (r === a) return { startNode: r, endNode: a }; var u = !0, o = !1, i = void 0; try { for (var s, c = t.parentNodes[Symbol.iterator](); !(u = (s = c.next()).done); u = !0) { var l = s.value; if (!("Program" !== l.type && "File" !== l.type && n.locStart(l) >= n.locStart(e.node))) break; a = l } } catch (e) { o = !0, i = e } finally { try { u || null == c.return || c.return() } finally { if (o) throw i } } var p = !0, d = !1, m = void 0; try { for (var f, D = e.parentNodes[Symbol.iterator](); !(p = (f = D.next()).done); p = !0) { var g = f.value; if (!("Program" !== g.type && "File" !== g.type && n.locEnd(g) <= n.locEnd(t.node))) break; r = g } } catch (e) { d = !0, m = e } finally { try { p || null == D.return || D.return() } finally { if (d) throw m } } return { startNode: r, endNode: a } } function findNodeAtOffset(e, t, n, r, a) { r = r || function () { return !0 }, a = a || []; var u = n.locStart(e, n.locStart), o = n.locEnd(e, n.locEnd); if (u <= t && t <= o) { var i = !0, s = !1, c = void 0; try { for (var l, p = comments.getSortedChildNodes(e, n)[Symbol.iterator](); !(i = (l = p.next()).done); i = !0) { var d = findNodeAtOffset(l.value, t, n, r, [e].concat(a)); if (d) return d } } catch (e) { s = !0, c = e } finally { try { i || null == p.return || p.return() } finally { if (s) throw c } } if (r(e)) return { node: e, parentNodes: a } } } function isSourceElement(e, t) { if (null == t) return !1; switch (e.parser) { case "flow": case "babylon": case "typescript": return -1 < ["FunctionDeclaration", "BlockStatement", "BreakStatement", "ContinueStatement", "DebuggerStatement", "DoWhileStatement", "EmptyStatement", "ExpressionStatement", "ForInStatement", "ForStatement", "IfStatement", "LabeledStatement", "ReturnStatement", "SwitchStatement", "ThrowStatement", "TryStatement", "VariableDeclaration", "WhileStatement", "WithStatement", "ClassDeclaration", "ImportDeclaration", "ExportDefaultDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration", "TypeAlias", "InterfaceDeclaration", "TypeAliasDeclaration", "ExportAssignment", "ExportDeclaration"].indexOf(t.type); case "json": return -1 < ["ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral"].indexOf(t.type); case "graphql": return -1 < ["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"].indexOf(t.kind) }return !1 } function calculateRange(e, t, n) { var r, a = e.slice(t.rangeStart, t.rangeEnd), u = Math.max(t.rangeStart + a.search(/\S/), t.rangeStart); for (r = t.rangeEnd; r > t.rangeStart && !e[r - 1].match(/\S/); --r); var o = findNodeAtOffset(n, u, t, function (e) { return isSourceElement(t, e) }), i = findNodeAtOffset(n, r, t, function (e) { return isSourceElement(t, e) }); if (!o || !i) return { rangeStart: 0, rangeEnd: 0 }; var s = findSiblingAncestors(o, i, t), c = s.startNode, l = s.endNode; return { rangeStart: Math.min(t.locStart(c, t.locStart), t.locStart(l, t.locStart)), rangeEnd: Math.max(t.locEnd(c, t.locEnd), t.locEnd(l, t.locEnd)) } } var rangeUtil = { calculateRange: calculateRange, findNodeAtOffset: findNodeAtOffset }, normalizeOptions = options.normalize, _printDocToString = doc.printer.printDocToString, printDocToDebug = doc.debug.printDocToDebug, UTF8BOM = 65279, CURSOR = Symbol("cursor"); function guessLineEnding(e) { var t = e.indexOf("\n"); return 0 <= t && "\r" === e.charAt(t - 1) ? "\r\n" : "\n" } function ensureAllCommentsPrinted(e) { if (e) { for (var t = 0; t < e.length; ++t)if ("prettier-ignore" === e[t].value.trim()) return; e.forEach(function (e) { if (!e.printed) throw new Error('Comment "' + e.value.trim() + '" was not printed. Please report this error!'); delete e.printed }) } } function attachComments(e, t, n) { var r = t.comments; return r && (delete t.comments, comments.attach(r, t, e, n)), t.tokens = [], n.originalText = e.trimRight(), r } function coreFormat(e, t, n) { n = n || 0; var r = parser.parse(e, t), a = r.ast; if (e = r.text, 0 <= t.cursorOffset) { var u = rangeUtil.findNodeAtOffset(a, t.cursorOffset, t); u && u.node && (t.cursorNode = u.node) } var o = attachComments(e, a, t), i = astToDoc(a, t, n); t.newLine = guessLineEnding(e); var s = _printDocToString(i, t); if (ensureAllCommentsPrinted(o), 0 < n) { var c = s.formatted.trim(); void 0 !== s.cursorNodeStart && (s.cursorNodeStart -= s.formatted.indexOf(c)), s.formatted = c + t.newLine } if (0 <= t.cursorOffset) { var l, p, d, m, f; if (f = t.cursorNode && s.cursorNodeText ? (l = t.locStart(t.cursorNode), p = e.slice(l, t.locEnd(t.cursorNode)), d = t.cursorOffset - l, m = s.cursorNodeStart, s.cursorNodeText) : (l = 0, p = e, d = t.cursorOffset, m = 0, s.formatted), p === f) return { formatted: s.formatted, cursorOffset: m + d }; var D = p.split(""); D.splice(d, 0, CURSOR); var g = f.split(""), h = lib.diffArrays(D, g), y = m, C = !0, $ = !1, E = void 0; try { for (var A, v = h[Symbol.iterator](); !(C = (A = v.next()).done); C = !0) { var F = A.value; if (F.removed) { if (-1 < F.value.indexOf(CURSOR)) break } else y += F.count } } catch (e) { $ = !0, E = e } finally { try { C || null == v.return || v.return() } finally { if ($) throw E } } return { formatted: s.formatted, cursorOffset: y } } return { formatted: s.formatted } } function formatRange(e, t) { var n = parser.parse(e, t), r = n.ast; e = n.text; var a = rangeUtil.calculateRange(e, t, r), u = a.rangeStart, o = a.rangeEnd, i = e.slice(u, o), s = Math.min(u, e.lastIndexOf("\n", u) + 1), c = e.slice(s, u), l = util.getAlignmentSize(c, t.tabWidth), p = coreFormat(i, Object.assign({}, t, { rangeStart: 0, rangeEnd: 1 / 0, printWidth: t.printWidth - l, cursorOffset: t.cursorOffset >= u && t.cursorOffset < o ? t.cursorOffset - u : -1 }), l), d = p.formatted.trimRight(), m = e.slice(0, u) + d + e.slice(o), f = t.cursorOffset; return t.cursorOffset >= o ? f = t.cursorOffset - o + (u + d.length) : void 0 !== p.cursorOffset && (f = p.cursorOffset + u), { formatted: m, cursorOffset: f } } function format(e, t) { var n = parser.resolveParser(t), r = !n.hasPragma || n.hasPragma(e); if (t.requirePragma && !r) return { formatted: e }; if (0 < t.rangeStart || t.rangeEnd < e.length) return formatRange(e, t); var a = e.charCodeAt(0) === UTF8BOM; a && (e = e.substring(1)), t.insertPragma && t.printer.insertPragma && !r && (e = t.printer.insertPragma(e)); var u = coreFormat(e, t); return a && (u.formatted = String.fromCharCode(UTF8BOM) + u.formatted), u } var core = { formatWithCursor: function (e, t) { return t = normalizeOptions(t), format(e, normalizeOptions(t)) }, parse: function (e, t, n) { t = normalizeOptions(t); var r = parser.parse(e, t); return n && (r.ast = massageAst(r.ast, t)), r }, formatAST: function (e, t) { t = normalizeOptions(t); var n = astToDoc(e, t); return _printDocToString(n, t) }, formatDoc: function (e, t) { return format(printDocToDebug(e), t = normalizeOptions(Object.assign({}, t, { parser: "babylon" }))).formatted }, printToDoc: function (e, t) { t = normalizeOptions(t); var n = parser.parse(e, t), r = n.ast; return attachComments(e = n.text, r, t), astToDoc(r, t) }, printDocToString: function (e, t) { return _printDocToString(e, normalizeOptions(t)) } }, _require$$0$builders$1 = doc.builders, indent$3 = _require$$0$builders$1.indent, join$3 = _require$$0$builders$1.join, hardline$4 = _require$$0$builders$1.hardline, softline$2 = _require$$0$builders$1.softline, literalline$2 = _require$$0$builders$1.literalline, concat$5 = _require$$0$builders$1.concat, dedentToRoot$1 = _require$$0$builders$1.dedentToRoot, _require$$0$utils = doc.utils, mapDoc$2 = _require$$0$utils.mapDoc, stripTrailingHardline$1 = _require$$0$utils.stripTrailingHardline; function embed(t, e, n) { var r = t.getValue(), a = t.getParentNode(), u = t.getParentNode(1); switch (r.type) { case "TemplateLiteral": if ([isStyledJsx, isStyledComponents, isCssProp, isAngularComponentStyles].some(function (e) { return e(t) })) { var o = r.quasis.map(function (e) { return e.value.raw }), i = 0, s = o.reduce(function (e, t, n) { return 0 == n ? t : e + "@prettier-placeholder-" + i++ + "-id" + t }, ""); return transformCssDoc(n(s, { parser: "css" }), t, e) } if (isGraphQL(t)) { var c = r.expressions ? t.map(e, "expressions") : [], l = r.quasis.length; if (1 === l && "" === r.quasis[0].value.raw.trim()) return "``"; for (var p = [], d = 0; d < l; d++) { var m = 0 === d, f = d === l - 1, D = r.quasis[d].value.cooked; if ("string" != typeof D) return null; var g = D.split("\n"), h = g.length, y = c[d], C = 2 < h && "" === g[0].trim() && "" === g[1].trim(), $ = 2 < h && "" === g[h - 1].trim() && "" === g[h - 2].trim(), E = g.every(function (e) { return /^\s*(?:#[^\r\n]*)?$/.test(e) }); if (!f && /#[^\r\n]*$/.test(g[h - 1])) return null; var A = null; (A = E ? printGraphqlComments(g) : stripTrailingHardline$1(n(D, { parser: "graphql" }))) ? (A = escapeBackticks(A), !m && C && p.push(""), p.push(A), !f && $ && p.push("")) : m || f || !C || p.push(""), y && p.push(concat$5(["${", y, "}"])) } return concat$5(["`", indent$3(concat$5([hardline$4, join$3(hardline$4, p)])), hardline$4, "`"]) } break; case "TemplateElement": if (!u || "TaggedTemplateExpression" !== u.type || 1 !== a.quasis.length || "Identifier" !== u.tag.type || "md" !== u.tag.name && "markdown" !== u.tag.name) break; var v = a.quasis[0].value.raw.replace(/((?:\\\\)*)\\`/g, function (e, t) { return "\\".repeat(t.length / 2) + "`" }), F = getIndentation(v); return concat$5(["" !== F ? indent$3(concat$5([softline$2, b(v.replace(new RegExp("^".concat(F), "gm"), ""))])) : concat$5([literalline$2, dedentToRoot$1(b(v))]), softline$2]) }function b(e) { var t = n(e, { parser: "markdown", __inJsTemplate: !0 }); return stripTrailingHardline$1(escapeBackticks(t)) } } function isPropertyWithinAngularComponentDecorator(e, t) { var n = e.getParentNode(t); return !!(n && "Decorator" === n.type && n.expression && "CallExpression" === n.expression.type && n.expression.callee && "Component" === n.expression.callee.name) } function getIndentation(e) { var t = e.match(/^([^\S\n]*)\S/m); return null === t ? "" : t[1] } function escapeBackticks(e) { return mapDoc$2(e, function (e) { if (!e.parts) return e; var t = []; return e.parts.forEach(function (e) { "string" == typeof e ? t.push(e.replace(/(\\*)`/g, "$1$1\\`")) : t.push(e) }), Object.assign({}, e, { parts: t }) }) } function transformCssDoc(e, t, n) { var r = t.getValue(); if (1 === r.quasis.length && !r.quasis[0].value.raw.trim()) return "``"; var a = replacePlaceholders(e, r.expressions ? t.map(n, "expressions") : []); if (!a) throw new Error("Couldn't insert all the expressions"); return concat$5(["`", indent$3(concat$5([hardline$4, stripTrailingHardline$1(a)])), softline$2, "`"]) } function replacePlaceholders(e, t) { if (!t || !t.length) return e; var f = t.slice(), D = 0, n = mapDoc$2(e, function (e) { if (!e || !e.parts || !e.parts.length) return e; var t = e.parts, n = t.indexOf("@"), r = n + 1; if (-1 < n && "string" == typeof t[r] && t[r].startsWith("prettier-placeholder")) { var a = t[n], u = t[r], o = t.slice(r + 1); t = t.slice(0, n).concat([a + u]).concat(o) } var i = t.findIndex(function (e) { return "string" == typeof e && e.startsWith("@prettier-placeholder") }); if (-1 < i) { var s = t[i], c = t.slice(i + 1), l = s.match(/@prettier-placeholder-(.+)-id([\s\S]*)/), p = l[1], d = l[2], m = f[p]; D++ , t = t.slice(0, i).concat(["${", m, "}" + d]).concat(c) } return Object.assign({}, e, { parts: t }) }); return f.length === D ? n : null } function printGraphqlComments(e) { var r = [], a = !1; return e.map(function (e) { return e.trim() }).forEach(function (e, t, n) { "" !== e && ("" === n[t - 1] && a ? r.push(concat$5([hardline$4, e])) : r.push(e), a = !0) }), 0 === r.length ? null : join$3(hardline$4, r) } function isStyledJsx(e) { var t = e.getValue(), n = e.getParentNode(), r = e.getParentNode(1); return r && t.quasis && "JSXExpressionContainer" === n.type && "JSXElement" === r.type && "style" === r.openingElement.name.name && r.openingElement.attributes.some(function (e) { return "jsx" === e.name.name }) } function isAngularComponentStyles(e) { var t = e.getParentNode(), n = e.getParentNode(1); return !(!t || "ArrayExpression" !== t.type || "Property" !== n.type || !isPropertyWithinAngularComponentDecorator(e, 4) || !n.key || "styles" !== n.key.name) } function isStyledComponents(e) { var t = e.getParentNode(); if (!t || "TaggedTemplateExpression" !== t.type) return !1; var n = t.tag; switch (n.type) { case "MemberExpression": return isStyledIdentifier(n.object) || isStyledExtend(n); case "CallExpression": return isStyledIdentifier(n.callee) || "MemberExpression" === n.callee.type && ("MemberExpression" === n.callee.object.type && (isStyledIdentifier(n.callee.object.object) || isStyledExtend(n.callee.object)) || "CallExpression" === n.callee.object.type && isStyledIdentifier(n.callee.object.callee)); case "Identifier": return "css" === n.name; default: return !1 } } function isCssProp(e) { var t = e.getParentNode(), n = e.getParentNode(1); return n && "JSXExpressionContainer" === t.type && "JSXAttribute" === n.type && "JSXIdentifier" === n.name.type && "css" === n.name.name } function isStyledIdentifier(e) { return "Identifier" === e.type && "styled" === e.name } function isStyledExtend(e) { return /^[A-Z]/.test(e.object.name) && "extend" === e.property.name } function isGraphQL(e) { var t = e.getValue(), n = e.getParentNode(); return t.leadingComments && t.leadingComments.some(function (e) { return "CommentBlock" === e.type && " GraphQL " === e.value }) || n && ("TaggedTemplateExpression" === n.type && ("MemberExpression" === n.tag.type && "graphql" === n.tag.object.name && "experimental" === n.tag.property.name || "Identifier" === n.tag.type && ("gql" === n.tag.name || "graphql" === n.tag.name)) || "CallExpression" === n.type && "Identifier" === n.callee.type && "graphql" === n.callee.name) } var embed_1 = embed; function clean(e, t, n) { if (["range", "raw", "comments", "leadingComments", "trailingComments", "extra", "start", "end", "flags"].forEach(function (e) { delete t[e] }), "EmptyStatement" === e.type) return null; if ("JSXText" === e.type) return null; if ("JSXExpressionContainer" === e.type && "Literal" === e.expression.type && " " === e.expression.value) return null; if ("TSParameterProperty" === e.type && null === e.accessibility && !e.readonly) return { type: "Identifier", name: e.parameter.name, typeAnnotation: t.parameter.typeAnnotation, decorators: t.decorators }; if ("TSNamespaceExportDeclaration" === e.type && e.specifiers && 0 === e.specifiers.length && delete t.specifiers, "TSParenthesizedType" === e.type && "TSTypeAnnotation" === e.typeAnnotation.type) return t.typeAnnotation.typeAnnotation; "JSXOpeningElement" === e.type && delete t.selfClosing, "JSXElement" === e.type && delete t.closingElement, "Property" !== e.type && "ObjectProperty" !== e.type && "MethodDefinition" !== e.type && "ClassProperty" !== e.type && "TSPropertySignature" !== e.type && "ObjectTypeProperty" !== e.type || "object" !== _typeof(e.key) || !e.key || "Literal" !== e.key.type && "StringLiteral" !== e.key.type && "Identifier" !== e.key.type || delete t.key, "OptionalMemberExpression" === e.type && !1 === e.optional && (t.type = "MemberExpression", delete t.optional), "JSXElement" === e.type && "style" === e.openingElement.name.name && e.openingElement.attributes.some(function (e) { return "jsx" === e.name.name }) && t.children.filter(function (e) { return "JSXExpressionContainer" === e.type && "TemplateLiteral" === e.expression.type }).map(function (e) { return e.expression }).reduce(function (e, t) { return e.concat(t.quasis) }, []).forEach(function (e) { return delete e.value }); "JSXAttribute" === e.type && "css" === e.name.name && "JSXExpressionContainer" === e.value.type && "TemplateLiteral" === e.value.expression.type && t.value.expression.quasis.forEach(function (e) { return delete e.value }); var r = e.expression || e.callee; "Decorator" === e.type && "CallExpression" === r.type && "Component" === r.callee.name && 1 === r.arguments.length && r.arguments[0].properties.some(function (e) { return "styles" === e.key.name && "ArrayExpression" === e.value.type }) && t.expression.arguments[0].properties.forEach(function (e) { "ArrayExpression" === e.value.type && e.value.elements[0].quasis.forEach(function (e) { return delete e.value }) }), "TaggedTemplateExpression" !== e.type || "MemberExpression" !== e.tag.type && ("Identifier" !== e.tag.type || "gql" !== e.tag.name && "graphql" !== e.tag.name && "css" !== e.tag.name && "md" !== e.tag.name && "markdown" !== e.tag.name) && "CallExpression" !== e.tag.type || t.quasi.quasis.forEach(function (e) { return delete e.value }), "TemplateLiteral" !== e.type || (e.leadingComments && e.leadingComments.some(function (e) { return "CommentBlock" === e.type && " GraphQL " === e.value }) || "CallExpression" === n.type && "graphql" === n.callee.name) && t.quasis.forEach(function (e) { return delete e.value }) } var clean_1 = clean, detectNewline = createCommonjsModule(function (t) { t.exports = function (e) { if ("string" != typeof e) throw new TypeError("Expected a string"); var t = e.match(/(?:\r?\n)/g) || []; if (0 === t.length) return null; var n = t.filter(function (e) { return "\r\n" === e }).length; return t.length - n < n ? "\r\n" : "\n" }, t.exports.graceful = function (e) { return t.exports(e) || "\n" } }), os$8 = {}, os$10 = Object.freeze({ default: os$8, __moduleExports: os$8 }), require$$1$4 = os$10 && os$8 || os$10, build = createCommonjsModule(function (e, t) { var l, p; function d() { return l = function (e) { return e && e.__esModule ? e : { default: e } }(detectNewline) } function m() { return p = require$$1$4 } Object.defineProperty(t, "__esModule", { value: !0 }), t.extract = function (e) { var t = e.match(n); return t && t[0].replace(r, "") || "" }, t.strip = function (e) { var t = e.match(n); return t && t[0] ? e.substring(t[0].length) : e }, t.parse = function (e) { return a(e).pragmas }, t.parseWithComments = a, t.print = function (e) { var t = e.comments, n = void 0 === t ? "" : t, r = e.pragmas, a = void 0 === r ? {} : r, u = (0, (l || d()).default)(n) || (p || m()).EOL, o = Object.keys(a), i = o.map(function (e) { return C(e, a[e]) }).reduce(function (e, t) { return e.concat(t) }, []).map(function (e) { return " * " + e + u }).join(""); if (!n) { if (0 === o.length) return ""; if (1 === o.length && !Array.isArray(a[o[0]])) { var s = a[o[0]]; return "".concat("/**", " ").concat(C(o[0], s)[0]).concat(" */") } } var c = n.split(u).map(function (e) { return "".concat(" *", " ").concat(e) }).join(u) + u; return "/**" + u + (n ? c : "") + (n && o.length ? " *" + u : "") + i + " */" }; var i = /\*\/$/, s = /^\/\*\*/, n = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, c = /(^|\s+)\/\/([^\r\n]*)/g, r = /^\s*/, f = /\s*$/, D = /^(\r?\n)+/, g = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, h = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, y = /(\r?\n|^) *\* ?/g; function a(e) { var t = (0, (l || d()).default)(e) || (p || m()).EOL; e = e.replace(s, "").replace(i, "").replace(y, "$1"); for (var n = ""; n !== e;)e = (n = e).replace(g, "".concat(t, "$1 $2").concat(t)); e = e.replace(D, "").replace(f, ""); for (var r, a = Object.create(null), u = e.replace(h, "").replace(D, "").replace(f, ""); r = h.exec(e);) { var o = r[2].replace(c, ""); "string" == typeof a[r[1]] || Array.isArray(a[r[1]]) ? a[r[1]] = [].concat(a[r[1]], o) : a[r[1]] = o } return { comments: u, pragmas: a } } function C(t, e) { return [].concat(e).map(function (e) { return "@".concat(t, " ").concat(e).trim() }) } }); function hasPragma(e) { var t = Object.keys(build.parse(build.extract(e))); return -1 !== t.indexOf("prettier") || -1 !== t.indexOf("format") } function insertPragma$1(e) { var t = build.parseWithComments(build.extract(e)), n = Object.assign({ format: "" }, t.pragmas), r = build.print({ pragmas: n, comments: t.comments.replace(/^(\s+?\r?\n)+/, "") }), a = build.strip(e); return r + (a.startsWith("\n") ? "\n" : "\n\n") + a } unwrapExports(build); var pragma = { hasPragma: hasPragma, insertPragma: insertPragma$1 }, addLeadingComment$2 = utilShared.addLeadingComment, addTrailingComment$2 = utilShared.addTrailingComment, addDanglingComment$2 = utilShared.addDanglingComment; function handleOwnLineComment(e, t, n, r, a) { var u = e.precedingNode, o = e.enclosingNode, i = e.followingNode; return !!(handleLastFunctionArgComments(t, u, o, i, e, n) || handleMemberExpressionComments(o, i, e) || handleIfStatementComments(t, u, o, i, e, n) || handleTryStatementComments(o, i, e) || handleClassComments(o, u, i, e) || handleImportSpecifierComments(o, e) || handleForComments(o, u, e) || handleUnionTypeComments(u, o, i, e) || handleOnlyComments(o, r, e, a) || handleImportDeclarationComments(t, o, u, e, n) || handleAssignmentPatternComments(o, e) || handleMethodNameComments(t, o, u, e, n)) } function handleEndOfLineComment(e, t, n, r, a) { var u = e.precedingNode, o = e.enclosingNode, i = e.followingNode; return !!(handleLastFunctionArgComments(t, u, o, i, e, n) || handleConditionalExpressionComments(o, u, i, e, t, n) || handleImportSpecifierComments(o, e) || handleIfStatementComments(t, u, o, i, e, n) || handleClassComments(o, u, i, e) || handleLabeledStatementComments(o, e) || handleCallExpressionComments(u, o, e) || handlePropertyComments(o, e) || handleOnlyComments(o, r, e, a) || handleTypeAliasComments(o, i, e) || handleVariableDeclaratorComments(o, i, e)) } function handleRemainingComment(e, t, n, r, a) { var u = e.precedingNode, o = e.enclosingNode, i = e.followingNode; return !!(handleIfStatementComments(t, u, o, i, e, n) || handleObjectPropertyAssignment(o, u, e) || handleCommentInEmptyParens(t, o, e, n) || handleMethodNameComments(t, o, u, e, n) || handleOnlyComments(o, r, e, a) || handleCommentAfterArrowParams(t, o, e, n) || handleFunctionNameComments(t, o, u, e, n) || handleTSMappedTypeComments(t, o, u, i, e) || handleBreakAndContinueStatementComments(o, e)) } function addBlockStatementFirstComment(e, t) { var n = e.body.filter(function (e) { return "EmptyStatement" !== e.type }); 0 === n.length ? addDanglingComment$2(e, t) : addLeadingComment$2(n[0], t) } function addBlockOrNotComment(e, t) { "BlockStatement" === e.type ? addBlockStatementFirstComment(e, t) : addLeadingComment$2(e, t) } function handleIfStatementComments(e, t, n, r, a, u) { if (!n || "IfStatement" !== n.type || !r) return !1; var o = util.getNextNonSpaceNonCommentCharacter(e, a, u.locEnd); return ")" === o ? (addTrailingComment$2(t, a), !0) : t === n.consequent && r === n.alternate ? ("BlockStatement" === t.type ? addTrailingComment$2(t, a) : addDanglingComment$2(n, a), !0) : "BlockStatement" === r.type ? (addBlockStatementFirstComment(r, a), !0) : "IfStatement" === r.type ? (addBlockOrNotComment(r.consequent, a), !0) : ("{" === o || n.consequent === r) && (addLeadingComment$2(r, a), !0) } function handleTryStatementComments(e, t, n) { return !(!e || "TryStatement" !== e.type || !t) && ("BlockStatement" === t.type ? (addBlockStatementFirstComment(t, n), !0) : "TryStatement" === t.type ? (addBlockOrNotComment(t.finalizer, n), !0) : "CatchClause" === t.type && (addBlockOrNotComment(t.body, n), !0)) } function handleMemberExpressionComments(e, t, n) { return !(!e || "MemberExpression" !== e.type || !t || "Identifier" !== t.type) && (addLeadingComment$2(e, n), !0) } function handleConditionalExpressionComments(e, t, n, r, a, u) { var o = t && !util.hasNewlineInRange(a, u.locEnd(t), u.locStart(r)); return !(t && o || !e || "ConditionalExpression" !== e.type || !n) && (addLeadingComment$2(n, r), !0) } function handleObjectPropertyAssignment(e, t, n) { return !(!e || "ObjectProperty" !== e.type && "Property" !== e.type || !e.shorthand || e.key !== t || "AssignmentPattern" !== e.value.type) && (addTrailingComment$2(e.value.left, n), !0) } function handleClassComments(e, t, n, r) { return !(!(e && ("ClassDeclaration" === e.type || "ClassExpression" === e.type) && e.decorators && 0 < e.decorators.length) || n && "Decorator" === n.type) && (e.decorators && 0 !== e.decorators.length ? addTrailingComment$2(e.decorators[e.decorators.length - 1], r) : addLeadingComment$2(e, r), !0) } function handleMethodNameComments(e, t, n, r, a) { return t && n && ("Property" === t.type || "MethodDefinition" === t.type) && "Identifier" === n.type && t.key === n && ":" !== util.getNextNonSpaceNonCommentCharacter(e, n, a.locEnd) ? (addTrailingComment$2(n, r), !0) : !(!n || !t || "Decorator" !== n.type || "ClassMethod" !== t.type && "ClassProperty" !== t.type && "TSAbstractClassProperty" !== t.type && "TSAbstractMethodDefinition" !== t.type && "MethodDefinition" !== t.type) && (addTrailingComment$2(n, r), !0) } function handleFunctionNameComments(e, t, n, r, a) { return "(" === util.getNextNonSpaceNonCommentCharacter(e, r, a.locEnd) && (!(!n || !t || "FunctionDeclaration" !== t.type && "FunctionExpression" !== t.type && "ClassMethod" !== t.type && "MethodDefinition" !== t.type && "ObjectMethod" !== t.type) && (addTrailingComment$2(n, r), !0)) } function handleCommentAfterArrowParams(e, t, n, r) { if (!t || "ArrowFunctionExpression" !== t.type) return !1; var a = utilShared.getNextNonSpaceNonCommentCharacterIndex(e, n, r); return "=>" === e.substr(a, 2) && (addDanglingComment$2(t, n), !0) } function handleCommentInEmptyParens(e, t, n, r) { return ")" === util.getNextNonSpaceNonCommentCharacter(e, n, r.locEnd) && (t && (("FunctionDeclaration" === t.type || "FunctionExpression" === t.type || "ArrowFunctionExpression" === t.type && ("CallExpression" !== t.body.type || 0 === t.body.arguments.length) || "ClassMethod" === t.type || "ObjectMethod" === t.type) && 0 === t.params.length || "CallExpression" === t.type && 0 === t.arguments.length) ? (addDanglingComment$2(t, n), !0) : !(!t || "MethodDefinition" !== t.type || 0 !== t.value.params.length) && (addDanglingComment$2(t.value, n), !0)) } function handleLastFunctionArgComments(e, t, n, r, a, u) { return t && "FunctionTypeParam" === t.type && n && "FunctionTypeAnnotation" === n.type && r && "FunctionTypeParam" !== r.type ? (addTrailingComment$2(t, a), !0) : !(!t || "Identifier" !== t.type && "AssignmentPattern" !== t.type || !n || "ArrowFunctionExpression" !== n.type && "FunctionExpression" !== n.type && "FunctionDeclaration" !== n.type && "ObjectMethod" !== n.type && "ClassMethod" !== n.type || ")" !== util.getNextNonSpaceNonCommentCharacter(e, a, u.locEnd)) && (addTrailingComment$2(t, a), !0) } function handleImportSpecifierComments(e, t) { return !(!e || "ImportSpecifier" !== e.type) && (addLeadingComment$2(e, t), !0) } function handleLabeledStatementComments(e, t) { return !(!e || "LabeledStatement" !== e.type) && (addLeadingComment$2(e, t), !0) } function handleBreakAndContinueStatementComments(e, t) { return !(!e || "ContinueStatement" !== e.type && "BreakStatement" !== e.type || e.label) && (addTrailingComment$2(e, t), !0) } function handleCallExpressionComments(e, t, n) { return !!(t && "CallExpression" === t.type && e && t.callee === e && 0 < t.arguments.length) && (addLeadingComment$2(t.arguments[0], n), !0) } function handleUnionTypeComments(e, t, n, r) { return !(!t || "UnionTypeAnnotation" !== t.type && "TSUnionType" !== t.type) && (addTrailingComment$2(e, r), !0) } function handlePropertyComments(e, t) { return !(!e || "Property" !== e.type && "ObjectProperty" !== e.type) && (addLeadingComment$2(e, t), !0) } function handleOnlyComments(e, t, n, r) { return t && t.body && 0 === t.body.length ? (r ? addDanglingComment$2(t, n) : addLeadingComment$2(t, n), !0) : !(!e || "Program" !== e.type || 0 !== e.body.length || !e.directives || 0 !== e.directives.length) && (r ? addDanglingComment$2(e, n) : addLeadingComment$2(e, n), !0) } function handleForComments(e, t, n) { return !(!e || "ForInStatement" !== e.type && "ForOfStatement" !== e.type) && (addLeadingComment$2(e, n), !0) } function handleImportDeclarationComments(e, t, n, r, a) { return !!(n && t && "ImportDeclaration" === t.type && util.hasNewline(e, a.locEnd(r))) && (addTrailingComment$2(n, r), !0) } function handleAssignmentPatternComments(e, t) { return !(!e || "AssignmentPattern" !== e.type) && (addLeadingComment$2(e, t), !0) } function handleTypeAliasComments(e, t, n) { return !(!e || "TypeAlias" !== e.type) && (addLeadingComment$2(e, n), !0) } function handleVariableDeclaratorComments(e, t, n) { return !(!e || "VariableDeclarator" !== e.type || !t || "ObjectExpression" !== t.type && "ArrayExpression" !== t.type) && (addLeadingComment$2(t, n), !0) } function handleTSMappedTypeComments(e, t, n, r, a) { return !(!t || "TSMappedType" !== t.type) && (r && "TSTypeParameter" === r.type && r.name ? (addLeadingComment$2(r.name, a), !0) : !(!n || "TSTypeParameter" !== n.type || !n.constraint) && (addTrailingComment$2(n.constraint, a), !0)) } function isBlockComment(e) { return "Block" === e.type || "CommentBlock" === e.type } var comments$3 = { handleOwnLineComment: handleOwnLineComment, handleEndOfLineComment: handleEndOfLineComment, handleRemainingComment: handleRemainingComment, isBlockComment: isBlockComment }; function hasClosureCompilerTypeCastComment(t, e, n) { return e.comments && e.comments.some(function (e) { return e.leading && comments$3.isBlockComment(e) && e.value.match(/^\*\s*@type\s*{[^}]+}\s*$/) && "(" === util.getNextNonSpaceNonCommentCharacter(t, e, n) }) } function needsParens(r, e) { var t = r.getParentNode(); if (!t) return !1; var n = r.getName(), a = r.getNode(); if (r.getValue() !== a) return !1; if (isStatement(a)) return !1; if (hasClosureCompilerTypeCastComment(e.originalText, a, e.locEnd)) return !0; if ("Identifier" === a.type) return !1; if ("ParenthesizedExpression" === t.type) return !1; if (!("ClassDeclaration" !== t.type && "ClassExpression" !== t.type || t.superClass !== a || "ArrowFunctionExpression" !== a.type && "AssignmentExpression" !== a.type && "AwaitExpression" !== a.type && "BinaryExpression" !== a.type && "ConditionalExpression" !== a.type && "LogicalExpression" !== a.type && "NewExpression" !== a.type && "ObjectExpression" !== a.type && "ParenthesizedExpression" !== a.type && "SequenceExpression" !== a.type && "TaggedTemplateExpression" !== a.type && "UnaryExpression" !== a.type && "UpdateExpression" !== a.type && "YieldExpression" !== a.type)) return !0; if ("ArrowFunctionExpression" === t.type && t.body === a && "SequenceExpression" !== a.type && util.startsWithNoLookaheadToken(a, !1) || "ExpressionStatement" === t.type && util.startsWithNoLookaheadToken(a, !0)) return !0; switch (a.type) { case "CallExpression": for (var u = t, o = 0; u && "MemberExpression" === u.type;)u = r.getParentNode(++o); return "NewExpression" === u.type && u.callee === r.getParentNode(o - 1); case "SpreadElement": case "SpreadProperty": return "MemberExpression" === t.type && "object" === n && t.object === a; case "UpdateExpression": if ("UnaryExpression" === t.type) return a.prefix && ("++" === a.operator && "+" === t.operator || "--" === a.operator && "-" === t.operator); case "UnaryExpression": switch (t.type) { case "UnaryExpression": return a.operator === t.operator && ("+" === a.operator || "-" === a.operator); case "MemberExpression": return "object" === n && t.object === a; case "TaggedTemplateExpression": return !0; case "NewExpression": case "CallExpression": return "callee" === n && t.callee === a; case "BinaryExpression": return "**" === t.operator && "left" === n; case "TSNonNullExpression": return !0; default: return !1 }case "BinaryExpression": if ("UpdateExpression" === t.type) return !0; if ("in" === a.operator && function (e) { for (var t = 0; e;) { var n = r.getParentNode(t++); if (!n) return !1; if ("ForStatement" === n.type && n.init === e) return !0; e = n } return !1 }(a)) return !0; case "TSTypeAssertionExpression": case "TSAsExpression": case "LogicalExpression": switch (t.type) { case "ConditionalExpression": return "TSAsExpression" === a.type; case "CallExpression": case "NewExpression": return "callee" === n && t.callee === a; case "ClassDeclaration": case "TSAbstractClassDeclaration": return "superClass" === n && t.superClass === a; case "TSTypeAssertionExpression": case "TaggedTemplateExpression": case "UnaryExpression": case "SpreadElement": case "SpreadProperty": case "ExperimentalSpreadProperty": case "BindExpression": case "AwaitExpression": case "TSAsExpression": case "TSNonNullExpression": case "UpdateExpression": return !0; case "MemberExpression": return "object" === n && t.object === a; case "AssignmentExpression": return t.left === a && ("TSTypeAssertionExpression" === a.type || "TSAsExpression" === a.type); case "Decorator": return t.expression === a && ("TSTypeAssertionExpression" === a.type || "TSAsExpression" === a.type); case "BinaryExpression": case "LogicalExpression": if (!a.operator && "TSTypeAssertionExpression" !== a.type) return !0; var i = t.operator, s = util.getPrecedence(i), c = a.operator, l = util.getPrecedence(c); return l < s || (("||" === i || "??" === i) && "&&" === c || (s === l && "right" === n ? (assert.strictEqual(t.right, a), !0) : s === l && !util.shouldFlatten(i, c) || (s < l && "%" === c ? !util.shouldFlatten(i, c) : !!util.isBitwiseOperator(i)))); default: return !1 }case "TSParenthesizedType": var p = r.getParentNode(1); return ("TSTypeParameter" !== t.type && "TypeParameter" !== t.type && "VariableDeclarator" !== t.type && "TSTypeAnnotation" !== t.type && "GenericTypeAnnotation" !== t.type && "TSTypeReference" !== t.type || "TSTypeAnnotation" !== a.typeAnnotation.type || "TSFunctionType" === a.typeAnnotation.typeAnnotation.type || "TSTypeOperator" === p.type) && "TSParenthesizedType" !== a.typeAnnotation.type; case "SequenceExpression": switch (t.type) { case "ReturnStatement": case "ForStatement": return !1; case "ExpressionStatement": return "expression" !== n; case "ArrowFunctionExpression": return "body" !== n; default: return !0 }case "YieldExpression": if ("UnaryExpression" === t.type || "AwaitExpression" === t.type || "TSAsExpression" === t.type || "TSNonNullExpression" === t.type) return !0; case "AwaitExpression": switch (t.type) { case "TaggedTemplateExpression": case "UnaryExpression": case "BinaryExpression": case "LogicalExpression": case "SpreadElement": case "SpreadProperty": case "ExperimentalSpreadProperty": case "TSAsExpression": case "TSNonNullExpression": return !0; case "MemberExpression": return t.object === a; case "NewExpression": case "CallExpression": return t.callee === a; case "ConditionalExpression": return t.test === a; default: return !1 }case "ArrayTypeAnnotation": return "NullableTypeAnnotation" === t.type; case "IntersectionTypeAnnotation": case "UnionTypeAnnotation": return "ArrayTypeAnnotation" === t.type || "NullableTypeAnnotation" === t.type || "IntersectionTypeAnnotation" === t.type || "UnionTypeAnnotation" === t.type; case "NullableTypeAnnotation": return "ArrayTypeAnnotation" === t.type; case "FunctionTypeAnnotation": var d = "NullableTypeAnnotation" === t.type ? r.getParentNode(1) : t; return "UnionTypeAnnotation" === d.type || "IntersectionTypeAnnotation" === d.type || "ArrayTypeAnnotation" === d.type || "NullableTypeAnnotation" === d.type; case "StringLiteral": case "NumericLiteral": case "Literal": if ("string" == typeof a.value && "ExpressionStatement" === t.type && ("typescript" !== e.parser && !t.directive || "typescript" === e.parser && "(" === e.originalText.substr(e.locStart(a) - 1, 1))) { var m = r.getParentNode(1); return "Program" === m.type || "BlockStatement" === m.type } return "MemberExpression" === t.type && "number" == typeof a.value && "object" === n && t.object === a; case "AssignmentExpression": var f = r.getParentNode(1); return "ArrowFunctionExpression" === t.type && t.body === a || ("ClassProperty" !== t.type || t.key !== a || !t.computed) && (("TSPropertySignature" !== t.type || t.name !== a) && (("ForStatement" !== t.type || t.init !== a && t.update !== a) && ("ExpressionStatement" === t.type ? "ObjectPattern" === a.left.type : ("TSPropertySignature" !== t.type || t.key !== a) && ("AssignmentExpression" !== t.type && ("SequenceExpression" !== t.type || !f || "ForStatement" !== f.type || f.init !== t && f.update !== t))))); case "ConditionalExpression": switch (t.type) { case "TaggedTemplateExpression": case "UnaryExpression": case "SpreadElement": case "SpreadProperty": case "ExperimentalSpreadProperty": case "BinaryExpression": case "LogicalExpression": case "ExportDefaultDeclaration": case "AwaitExpression": case "JSXSpreadAttribute": case "TSTypeAssertionExpression": case "TypeCastExpression": case "TSAsExpression": case "TSNonNullExpression": return !0; case "NewExpression": case "CallExpression": return "callee" === n && t.callee === a; case "ConditionalExpression": return "test" === n && t.test === a; case "MemberExpression": return "object" === n && t.object === a; default: return !1 }case "FunctionExpression": switch (t.type) { case "CallExpression": return "callee" === n; case "TaggedTemplateExpression": case "ExportDefaultDeclaration": return !0; default: return !1 }case "ArrowFunctionExpression": switch (t.type) { case "CallExpression": case "NewExpression": return "callee" === n; case "MemberExpression": return "object" === n; case "TSAsExpression": case "BindExpression": case "TaggedTemplateExpression": case "UnaryExpression": case "LogicalExpression": case "BinaryExpression": case "AwaitExpression": case "TSTypeAssertionExpression": return !0; case "ConditionalExpression": return "test" === n; default: return !1 }case "ClassExpression": return "ExportDefaultDeclaration" === t.type; case "OptionalMemberExpression": return "MemberExpression" === t.type }return !1 } function isStatement(e) { return "BlockStatement" === e.type || "BreakStatement" === e.type || "ClassBody" === e.type || "ClassDeclaration" === e.type || "ClassMethod" === e.type || "ClassProperty" === e.type || "ClassPrivateProperty" === e.type || "ContinueStatement" === e.type || "DebuggerStatement" === e.type || "DeclareClass" === e.type || "DeclareExportAllDeclaration" === e.type || "DeclareExportDeclaration" === e.type || "DeclareFunction" === e.type || "DeclareInterface" === e.type || "DeclareModule" === e.type || "DeclareModuleExports" === e.type || "DeclareVariable" === e.type || "DoWhileStatement" === e.type || "ExportAllDeclaration" === e.type || "ExportDefaultDeclaration" === e.type || "ExportNamedDeclaration" === e.type || "ExpressionStatement" === e.type || "ForAwaitStatement" === e.type || "ForInStatement" === e.type || "ForOfStatement" === e.type || "ForStatement" === e.type || "FunctionDeclaration" === e.type || "IfStatement" === e.type || "ImportDeclaration" === e.type || "InterfaceDeclaration" === e.type || "LabeledStatement" === e.type || "MethodDefinition" === e.type || "ReturnStatement" === e.type || "SwitchStatement" === e.type || "ThrowStatement" === e.type || "TryStatement" === e.type || "TSAbstractClassDeclaration" === e.type || "TSEnumDeclaration" === e.type || "TSImportEqualsDeclaration" === e.type || "TSInterfaceDeclaration" === e.type || "TSModuleDeclaration" === e.type || "TSNamespaceExportDeclaration" === e.type || "TypeAlias" === e.type || "VariableDeclaration" === e.type || "WhileStatement" === e.type || "WithStatement" === e.type } var needsParens_1 = needsParens, getParentExportDeclaration$1 = util.getParentExportDeclaration, isExportDeclaration$1 = util.isExportDeclaration, shouldFlatten$1 = util.shouldFlatten, getNextNonSpaceNonCommentCharacter$1 = util.getNextNonSpaceNonCommentCharacter, hasNewline$2 = util.hasNewline, hasNewlineInRange$1 = util.hasNewlineInRange, getLast$4 = util.getLast, getStringWidth$1 = util.getStringWidth, printString$1 = util.printString, printNumber$1 = util.printNumber, hasIgnoreComment$1 = util.hasIgnoreComment, skipWhitespace$1 = util.skipWhitespace, hasNodeIgnoreComment$1 = util.hasNodeIgnoreComment, getPenultimate$1 = util.getPenultimate, startsWithNoLookaheadToken$1 = util.startsWithNoLookaheadToken, getIndentSize$1 = util.getIndentSize, isNextLineEmpty$2 = utilShared.isNextLineEmpty, isNextLineEmptyAfterIndex$1 = utilShared.isNextLineEmptyAfterIndex, getNextNonSpaceNonCommentCharacterIndex$2 = utilShared.getNextNonSpaceNonCommentCharacterIndex, isIdentifierName = utils.keyword.isIdentifierNameES6, insertPragma = pragma.insertPragma, _require$$4$builders = doc.builders, concat$4 = _require$$4$builders.concat, join$2 = _require$$4$builders.join, line$3 = _require$$4$builders.line, hardline$3 = _require$$4$builders.hardline, softline$1 = _require$$4$builders.softline, literalline$1 = _require$$4$builders.literalline, group$1 = _require$$4$builders.group, indent$2 = _require$$4$builders.indent, align$1 = _require$$4$builders.align, conditionalGroup$1 = _require$$4$builders.conditionalGroup, fill$2 = _require$$4$builders.fill, ifBreak$1 = _require$$4$builders.ifBreak, breakParent$2 = _require$$4$builders.breakParent, lineSuffixBoundary$1 = _require$$4$builders.lineSuffixBoundary, addAlignmentToDoc$2 = _require$$4$builders.addAlignmentToDoc, dedent$2 = _require$$4$builders.dedent, _require$$4$utils = doc.utils, willBreak$1 = _require$$4$utils.willBreak, isLineNext$1 = _require$$4$utils.isLineNext, isEmpty$1 = _require$$4$utils.isEmpty, removeLines$1 = _require$$4$utils.removeLines, printDocToString$1 = doc.printer.printDocToString; function shouldPrintComma(e, t) { switch (t = t || "es5", e.trailingComma) { case "all": if ("all" === t) return !0; case "es5": if ("es5" === t) return !0; case "none": default: return !1 } } function genericPrint$1(e, t, n, r) { var a = e.getValue(), u = !1, o = printPathNoParens(e, t, n, r); if (!a || isEmpty$1(o)) return o; var i = []; if (a.decorators && 0 < a.decorators.length && !getParentExportDeclaration$1(e)) { var s = hardline$3; e.each(function (e) { var t = e.getValue(); t = t.expression ? t.expression : t.callee, 1 !== a.decorators.length || "ClassDeclaration" === a.type || "MethodDefinition" === a.type || "ClassMethod" === a.type || "Identifier" !== t.type && "MemberExpression" !== t.type && "OptionalMemberExpression" !== t.type && ("CallExpression" !== t.type && "OptionalCallExpression" !== t.type || 0 !== t.arguments.length && (1 !== t.arguments.length || !isStringLiteral(t.arguments[0]) && "Identifier" !== t.arguments[0].type && "MemberExpression" !== t.arguments[0].type && "OptionalMemberExpression" !== t.arguments[0].type)) || (s = line$3), i.push(n(e), s) }, "decorators") } else isExportDeclaration$1(a) && a.declaration && a.declaration.decorators ? e.each(function (e) { var t = "Decorator" === e.getValue().type ? "" : "@"; i.push(t, n(e), hardline$3) }, "declaration", "decorators") : u = needsParens_1(e, t); var c = []; return u && c.unshift("("), c.push(o), u && c.push(")"), 0 < i.length ? group$1(concat$4(i.concat(c))) : concat$4(c) } function hasPrettierIgnore(e) { return hasIgnoreComment$1(e) || hasJsxIgnoreComment(e) } function hasJsxIgnoreComment(e) { var t = e.getValue(), n = e.getParentNode(); if (!(n && t && isJSXNode(t) && isJSXNode(n))) return !1; for (var r = null, a = n.children.indexOf(t); 0 < a; a--) { var u = n.children[a - 1]; if ("JSXText" !== u.type || isMeaningfulJSXText(u)) { r = u; break } } return r && "JSXExpressionContainer" === r.type && "JSXEmptyExpression" === r.expression.type && r.expression.comments && r.expression.comments.find(function (e) { return "prettier-ignore" === e.value.trim() }) } function formatTernaryOperator(e, t, n, r) { for (var a, u, o = e.getValue(), i = [], s = Object.assign({ beforeParts: function () { return [""] }, afterParts: function () { return [""] }, shouldCheckJsx: !0, operatorName: "ConditionalExpression", consequentNode: "consequent", alternateNode: "alternate", testNode: "test", breakNested: !0 }, r || {}), c = !1, l = e.getParentNode(), p = l.type === s.operatorName, d = 0; u = a || o, a = e.getParentNode(d), d++ , a && a.type === s.operatorName;); var m = a || l, f = u; if (s.shouldCheckJsx && isJSXNode(o[s.testNode]) || isJSXNode(o[s.consequentNode]) || isJSXNode(o[s.alternateNode]) || conditionalExpressionChainContainsJSX(f)) { p = c = !0; var D = function (e) { return concat$4([ifBreak$1("(", ""), indent$2(concat$4([softline$1, e])), softline$1, ifBreak$1(")", "")]) }, g = function (e) { return "NullLiteral" === e.type || "Literal" === e.type && null === e.value }; i.push(" ? ", g(o[s.consequentNode]) ? e.call(n, s.consequentNode) : D(e.call(n, s.consequentNode)), " : ", o[s.alternateNode].type === s.operatorName || g(o[s.alternateNode]) ? e.call(n, s.alternateNode) : D(e.call(n, s.alternateNode))) } else { var h = concat$4([line$3, "? ", o[s.consequentNode].type === s.operatorName ? ifBreak$1("", "(") : "", align$1(2, e.call(n, s.consequentNode)), o[s.consequentNode].type === s.operatorName ? ifBreak$1("", ")") : "", line$3, ": ", align$1(2, e.call(n, s.alternateNode))]); i.push(l.type === s.operatorName ? t.useTabs ? dedent$2(indent$2(h)) : align$1(Math.max(0, t.tabWidth - 2), h) : h) } var y, C = !(c || "MemberExpression" !== l.type && "OptionalMemberExpression" !== l.type || l.computed); return y = concat$4([].concat(s.beforeParts(), p ? concat$4(i) : indent$2(concat$4(i)), s.afterParts(C))), s.breakNested ? l === m ? group$1(y) : y : group$1(y) } function getTypeScriptMappedTypeModifier(e, t) { return "TSPlusToken" === e.type ? "+" + t : "TSMinusToken" === e.type ? "-" + t : t } function printPathNoParens(t, o, i, n) { var s = t.getValue(), r = o.semi ? ";" : ""; if (!s) return ""; if ("string" == typeof s) return s; var c = []; switch (s.type) { case "File": return s.program && s.program.interpreter && c.push(t.call(function (e) { return e.call(i, "interpreter") }, "program")), c.push(t.call(i, "program")), concat$4(c); case "Program": return s.directives && t.each(function (e) { c.push(i(e), r, hardline$3), isNextLineEmpty$2(o.originalText, e.getValue(), o) && c.push(hardline$3) }, "directives"), c.push(t.call(function (e) { return printStatementSequence(e, o, i) }, "body")), c.push(comments.printDanglingComments(t, o, !0)), (s.body.length || s.comments) && c.push(hardline$3), concat$4(c); case "EmptyStatement": return ""; case "ExpressionStatement": return s.directive ? concat$4([nodeStr(s.expression, o, !0), r]) : concat$4([t.call(i, "expression"), isTheOnlyJSXElementInMarkdown(o, t) ? "" : r]); case "ParenthesizedExpression": return concat$4(["(", t.call(i, "expression"), ")"]); case "AssignmentExpression": return printAssignment(s.left, t.call(i, "left"), concat$4([" ", s.operator]), s.right, t.call(i, "right"), o); case "BinaryExpression": case "LogicalExpression": var e = t.getParentNode(), a = t.getParentNode(1), u = s !== e.body && ("IfStatement" === e.type || "WhileStatement" === e.type || "DoWhileStatement" === e.type), l = printBinaryishExpressions(t, i, o, !1, u); if (u) return concat$4(l); if ("UnaryExpression" === e.type || ("MemberExpression" === e.type || "OptionalMemberExpression" === e.type) && !e.computed) return group$1(concat$4([indent$2(concat$4([softline$1, concat$4(l)])), softline$1])); var p = "ReturnStatement" === e.type || "JSXExpressionContainer" === e.type && "JSXAttribute" === a.type || s === e.body && "ArrowFunctionExpression" === e.type || s !== e.body && "ForStatement" === e.type || "ConditionalExpression" === e.type && "ReturnStatement" !== a.type, d = "AssignmentExpression" === e.type || "VariableDeclarator" === e.type || "ClassProperty" === e.type || "TSAbstractClassProperty" === e.type || "ClassPrivateProperty" === e.type || "ObjectProperty" === e.type || "Property" === e.type, m = isBinaryish(s.left) && shouldFlatten$1(s.operator, s.left.operator); if (p || shouldInlineLogicalExpression(s) && !m || !shouldInlineLogicalExpression(s) && d) return group$1(concat$4(l)); var f = concat$4(l.slice(1)); return group$1(concat$4([0 < l.length ? l[0] : "", indent$2(f)])); case "AssignmentPattern": return concat$4([t.call(i, "left"), " = ", t.call(i, "right")]); case "TSTypeAssertionExpression": var D = !("ArrayExpression" === s.expression.type || "ObjectExpression" === s.expression.type), g = group$1(concat$4(["<", indent$2(concat$4([softline$1, t.call(i, "typeAnnotation")])), softline$1, ">"])), h = concat$4([ifBreak$1("("), indent$2(concat$4([softline$1, t.call(i, "expression")])), softline$1, ifBreak$1(")")]); return D ? conditionalGroup$1([concat$4([g, t.call(i, "expression")]), concat$4([g, group$1(h, { shouldBreak: !0 })]), concat$4([g, t.call(i, "expression")])]) : group$1(concat$4([g, t.call(i, "expression")])); case "OptionalMemberExpression": case "MemberExpression": for (var y, C = t.getParentNode(), $ = 0; y = t.getParentNode($), $++ , y && ("MemberExpression" === y.type || "OptionalMemberExpression" === y.type || "TSNonNullExpression" === y.type);); var E = y && ("NewExpression" === y.type || "BindExpression" === y.type || "VariableDeclarator" === y.type && "Identifier" !== y.id.type || "AssignmentExpression" === y.type && "Identifier" !== y.left.type) || s.computed || "Identifier" === s.object.type && "Identifier" === s.property.type && "MemberExpression" !== C.type && "OptionalMemberExpression" !== C.type; return concat$4([t.call(i, "object"), E ? printMemberLookup(t, o, i) : group$1(indent$2(concat$4([softline$1, printMemberLookup(t, o, i)])))]); case "MetaProperty": return concat$4([t.call(i, "meta"), ".", t.call(i, "property")]); case "BindExpression": return s.object && c.push(t.call(i, "object")), c.push(group$1(indent$2(concat$4([softline$1, printBindExpressionCallee(t, o, i)])))), concat$4(c); case "Identifier": return concat$4([s.name, printOptionalToken(t), printTypeAnnotation(t, o, i)]); case "SpreadElement": case "SpreadElementPattern": case "RestProperty": case "ExperimentalRestProperty": case "ExperimentalSpreadProperty": case "SpreadProperty": case "SpreadPropertyPattern": case "RestElement": case "ObjectTypeSpreadProperty": return concat$4(["...", t.call(i, "argument"), printTypeAnnotation(t, o, i)]); case "FunctionDeclaration": case "FunctionExpression": return isNodeStartingWithDeclare(s, o) && c.push("declare "), c.push(printFunctionDeclaration(t, i, o)), s.body || c.push(r), concat$4(c); case "ArrowFunctionExpression": s.async && c.push("async "), shouldPrintParamsWithoutParens(t, o) ? c.push(t.call(i, "params", 0)) : c.push(group$1(concat$4([printFunctionParams(t, i, o, n && (n.expandLastArg || n.expandFirstArg), !0), printReturnType(t, i, o)]))); var A = comments.printDanglingComments(t, o, !0, function (e) { var t = getNextNonSpaceNonCommentCharacterIndex$2(o.originalText, e, o); return "=>" === o.originalText.substr(t, 2) }); A && c.push(" ", A), c.push(" =>"); var v = t.call(function (e) { return i(e, n) }, "body"); if (!hasLeadingOwnLineComment(o.originalText, s.body, o) && ("ArrayExpression" === s.body.type || "ObjectExpression" === s.body.type || "BlockStatement" === s.body.type || isJSXNode(s.body) || isTemplateOnItsOwnLine(s.body, o.originalText, o) || "ArrowFunctionExpression" === s.body.type || "DoExpression" === s.body.type)) return group$1(concat$4([concat$4(c), " ", v])); if ("SequenceExpression" === s.body.type) return group$1(concat$4([concat$4(c), group$1(concat$4([" (", indent$2(concat$4([softline$1, v])), softline$1, ")"]))])); var F = (n && n.expandLastArg || "JSXExpressionContainer" === t.getParentNode().type) && !(s.comments && s.comments.length), b = n && n.expandLastArg && shouldPrintComma(o, "all"), x = "ConditionalExpression" === s.body.type && !startsWithNoLookaheadToken$1(s.body, !1); return group$1(concat$4([concat$4(c), group$1(concat$4([indent$2(concat$4([line$3, x ? ifBreak$1("", "(") : "", v, x ? ifBreak$1("", ")") : ""])), F ? concat$4([ifBreak$1(b ? "," : ""), softline$1]) : ""]))])); case "MethodDefinition": case "TSAbstractMethodDefinition": return s.accessibility && c.push(s.accessibility + " "), s.static && c.push("static "), "TSAbstractMethodDefinition" === s.type && c.push("abstract "), c.push(printMethod(t, o, i)), concat$4(c); case "YieldExpression": return c.push("yield"), s.delegate && c.push("*"), s.argument && c.push(" ", t.call(i, "argument")), concat$4(c); case "AwaitExpression": return concat$4(["await ", t.call(i, "argument")]); case "ImportSpecifier": return s.importKind && c.push(t.call(i, "importKind"), " "), c.push(t.call(i, "imported")), s.local && s.local.name !== s.imported.name && c.push(" as ", t.call(i, "local")), concat$4(c); case "ExportSpecifier": return c.push(t.call(i, "local")), s.exported && s.exported.name !== s.local.name && c.push(" as ", t.call(i, "exported")), concat$4(c); case "ImportNamespaceSpecifier": return c.push("* as "), s.local ? c.push(t.call(i, "local")) : s.id && c.push(t.call(i, "id")), concat$4(c); case "ImportDefaultSpecifier": return s.local ? t.call(i, "local") : t.call(i, "id"); case "TSExportAssignment": return concat$4(["export = ", t.call(i, "expression"), r]); case "ExportDefaultDeclaration": case "ExportNamedDeclaration": return printExportDeclaration(t, o, i); case "ExportAllDeclaration": return c.push("export "), "type" === s.exportKind && c.push("type "), c.push("* from ", t.call(i, "source"), r), concat$4(c); case "ExportNamespaceSpecifier": case "ExportDefaultSpecifier": return t.call(i, "exported"); case "ImportDeclaration": c.push("import "), s.importKind && "value" !== s.importKind && c.push(s.importKind + " "); var S = [], B = []; return s.specifiers && 0 < s.specifiers.length ? (t.each(function (e) { var t = e.getValue(); "ImportDefaultSpecifier" === t.type || "ImportNamespaceSpecifier" === t.type ? S.push(i(e)) : B.push(i(e)) }, "specifiers"), 0 < S.length && c.push(join$2(", ", S)), 0 < S.length && 0 < B.length && c.push(", "), 1 === B.length && 0 === S.length && s.specifiers && !s.specifiers.some(function (e) { return e.comments }) ? c.push(concat$4(["{", o.bracketSpacing ? " " : "", concat$4(B), o.bracketSpacing ? " " : "", "}"])) : 1 <= B.length && c.push(group$1(concat$4(["{", indent$2(concat$4([o.bracketSpacing ? line$3 : softline$1, join$2(concat$4([",", line$3]), B)])), ifBreak$1(shouldPrintComma(o) ? "," : ""), o.bracketSpacing ? line$3 : softline$1, "}"]))), c.push(" from ")) : (s.importKind && "type" === s.importKind || /{\s*}/.test(o.originalText.slice(o.locStart(s), o.locStart(s.source)))) && c.push("{} from "), c.push(t.call(i, "source"), r), concat$4(c); case "Import": return "import"; case "BlockStatement": var T = t.call(function (e) { return printStatementSequence(e, o, i) }, "body"), N = s.body.find(function (e) { return "EmptyStatement" !== e.type }), w = s.directives && 0 < s.directives.length, P = t.getParentNode(), k = t.getParentNode(1); return N || w || hasDanglingComments(s) || "ArrowFunctionExpression" !== P.type && "FunctionExpression" !== P.type && "FunctionDeclaration" !== P.type && "ObjectMethod" !== P.type && "ClassMethod" !== P.type && "ForStatement" !== P.type && "WhileStatement" !== P.type && "DoWhileStatement" !== P.type && "DoExpression" !== P.type && ("CatchClause" !== P.type || k.finalizer) ? (c.push("{"), w && t.each(function (e) { c.push(indent$2(concat$4([hardline$3, i(e), r]))), isNextLineEmpty$2(o.originalText, e.getValue(), o) && c.push(hardline$3) }, "directives"), N && c.push(indent$2(concat$4([hardline$3, T]))), c.push(comments.printDanglingComments(t, o)), c.push(hardline$3, "}"), concat$4(c)) : "{}"; case "ReturnStatement": return c.push("return"), s.argument && (returnArgumentHasLeadingComment(o, s.argument) ? c.push(concat$4([" (", indent$2(concat$4([hardline$3, t.call(i, "argument")])), hardline$3, ")"])) : "LogicalExpression" === s.argument.type || "BinaryExpression" === s.argument.type || "SequenceExpression" === s.argument.type ? c.push(group$1(concat$4([ifBreak$1(" (", " "), indent$2(concat$4([softline$1, t.call(i, "argument")])), softline$1, ifBreak$1(")")]))) : c.push(" ", t.call(i, "argument"))), hasDanglingComments(s) && c.push(" ", comments.printDanglingComments(t, o, !0)), c.push(r), concat$4(c); case "NewExpression": case "OptionalCallExpression": case "CallExpression": var O = "NewExpression" === s.type, j = printOptionalToken(t); return !O && "Identifier" === s.callee.type && ("require" === s.callee.name || "define" === s.callee.name) || "Import" === s.callee.type || 1 === s.arguments.length && isTemplateOnItsOwnLine(s.arguments[0], o.originalText, o) || !O && isTestCall(s, t.getParentNode()) ? concat$4([O ? "new " : "", t.call(i, "callee"), j, printFunctionTypeParameters(t, o, i), concat$4(["(", join$2(", ", t.map(i, "arguments")), ")"])]) : !O && isMemberish(s.callee) ? printMemberChain(t, o, i) : concat$4([O ? "new " : "", t.call(i, "callee"), j, printFunctionTypeParameters(t, o, i), printArgumentsList(t, o, i)]); case "TSInterfaceDeclaration": return isNodeStartingWithDeclare(s, o) && c.push("declare "), c.push(s.abstract ? "abstract " : "", printTypeScriptModifiers(t, o, i), "interface ", t.call(i, "id"), s.typeParameters ? t.call(i, "typeParameters") : "", " "), s.heritage.length && c.push(group$1(indent$2(concat$4([softline$1, "extends ", indent$2(join$2(concat$4([",", line$3]), t.map(i, "heritage"))), " "])))), c.push(t.call(i, "body")), concat$4(c); case "ObjectExpression": case "ObjectPattern": case "ObjectTypeAnnotation": case "TSInterfaceBody": case "TSTypeLiteral": var L, _ = "ObjectTypeAnnotation" === s.type, M = t.getParentNode(0), I = "TSInterfaceBody" === s.type || "ObjectPattern" === s.type && "FunctionDeclaration" !== M.type && "FunctionExpression" !== M.type && "ArrowFunctionExpression" !== M.type && "AssignmentPattern" !== M.type && "CatchClause" !== M.type && s.properties.some(function (e) { return e.value && ("ObjectPattern" === e.value.type || "ArrayPattern" === e.value.type) }) || "ObjectPattern" !== s.type && hasNewlineInRange$1(o.originalText, o.locStart(s), o.locEnd(s)), R = _ && M && ("InterfaceDeclaration" === M.type || "DeclareInterface" === M.type || "DeclareClass" === M.type) && "body" === t.getName() ? ";" : "TSInterfaceBody" === s.type || "TSTypeLiteral" === s.type ? ifBreak$1(r, ";") : ",", q = [], V = s.exact ? "{|" : "{", W = s.exact ? "|}" : "}"; L = "TSTypeLiteral" === s.type ? "members" : "TSInterfaceBody" === s.type ? "body" : "properties", _ && q.push("indexers", "callProperties"), q.push(L); var J = []; q.forEach(function (e) { t.each(function (e) { var t = e.getValue(); J.push({ node: t, printed: i(e), loc: o.locStart(t) }) }, e) }); var G, U = [], K = J.sort(function (e, t) { return e.loc - t.loc }).map(function (e) { var t = concat$4(U.concat(group$1(e.printed))); return U = [R, line$3], "TSPropertySignature" === e.node.type && hasNodeIgnoreComment$1(e.node) && U.shift(), isNextLineEmpty$2(o.originalText, e.node, o) && U.push(hardline$3), t }), X = getLast$4(s[L]), z = !(X && ("RestProperty" === X.type || "RestElement" === X.type || "ExperimentalRestProperty" === X.type || hasNodeIgnoreComment$1(X))); if (0 !== K.length || s.typeAnnotation) G = concat$4([V, indent$2(concat$4([o.bracketSpacing ? line$3 : softline$1, concat$4(K)])), ifBreak$1(z && ("," !== R || shouldPrintComma(o)) ? R : ""), concat$4([o.bracketSpacing ? line$3 : softline$1, W]), printOptionalToken(t), printTypeAnnotation(t, o, i)]); else { if (!hasDanglingComments(s)) return concat$4([V, W]); G = group$1(concat$4([V, comments.printDanglingComments(t, o), softline$1, W, printOptionalToken(t)])) } var H = t.getParentNode(2); return "ObjectPattern" === s.type && M && shouldHugArguments(M) && M.params[0] === s || shouldHugType(s) && H && shouldHugArguments(H) && H.params[0].typeAnnotation && H.params[0].typeAnnotation.typeAnnotation === s ? G : group$1(G, { shouldBreak: I }); case "ObjectProperty": case "Property": if (s.method || "get" === s.kind || "set" === s.kind) return printMethod(t, o, i); var Y; if (s.shorthand) c.push(t.call(i, "value")); else Y = s.computed ? concat$4(["[", t.call(i, "key"), "]"]) : printPropertyKey(t, o, i), c.push(printAssignment(s.key, Y, ":", s.value, t.call(i, "value"), o)); return concat$4(c); case "ClassMethod": return s.static && c.push("static "), c = c.concat(printObjectMethod(t, o, i)), concat$4(c); case "ObjectMethod": return printObjectMethod(t, o, i); case "Decorator": return concat$4(["@", t.call(i, "expression"), t.call(i, "callee")]); case "ArrayExpression": case "ArrayPattern": if (0 === s.elements.length) hasDanglingComments(s) ? c.push(group$1(concat$4(["[", comments.printDanglingComments(t, o), softline$1, "]"]))) : c.push("[]"); else { var Q = getLast$4(s.elements), Z = !(Q && "RestElement" === Q.type), ee = Z && null === Q; c.push(group$1(concat$4(["[", indent$2(concat$4([softline$1, printArrayItems(t, o, "elements", i)])), ee ? "," : "", ifBreak$1(Z && !ee && shouldPrintComma(o) ? "," : ""), comments.printDanglingComments(t, o, !0), softline$1, "]"]))) } return c.push(printOptionalToken(t), printTypeAnnotation(t, o, i)), concat$4(c); case "SequenceExpression": var te = t.getParentNode(0); if ("ExpressionStatement" !== te.type && "ForStatement" !== te.type) return group$1(concat$4([join$2(concat$4([",", line$3]), t.map(i, "expressions"))])); var ne = []; return t.each(function (e) { 0 === e.getName() ? ne.push(i(e)) : ne.push(",", indent$2(concat$4([line$3, i(e)]))) }, "expressions"), group$1(concat$4(ne)); case "ThisExpression": return "this"; case "Super": return "super"; case "NullLiteral": return "null"; case "RegExpLiteral": return printRegex(s); case "NumericLiteral": return printNumber$1(s.extra.raw); case "BooleanLiteral": case "StringLiteral": case "Literal": if (s.regex) return printRegex(s.regex); if ("number" == typeof s.value) return printNumber$1(s.raw); if ("string" != typeof s.value) return "" + s.value; var re = t.getParentNode(1), ae = "typescript" === o.parser && "string" == typeof s.value && re && ("Program" === re.type || "BlockStatement" === re.type); return nodeStr(s, o, ae); case "Directive": return t.call(i, "value"); case "DirectiveLiteral": return nodeStr(s, o); case "UnaryExpression": return c.push(s.operator), /[a-z]$/.test(s.operator) && c.push(" "), c.push(t.call(i, "argument")), concat$4(c); case "UpdateExpression": return c.push(t.call(i, "argument"), s.operator), s.prefix && c.reverse(), concat$4(c); case "ConditionalExpression": return formatTernaryOperator(t, o, i, { beforeParts: function () { return [t.call(i, "test")] }, afterParts: function (e) { return [e ? softline$1 : ""] } }); case "VariableDeclaration": var ue, oe = t.map(function (e) { return i(e) }, "declarations"), ie = t.getParentNode(), se = "ForStatement" === ie.type || "ForInStatement" === ie.type || "ForOfStatement" === ie.type || "ForAwaitStatement" === ie.type, ce = s.declarations.some(function (e) { return e.init }); return 1 === oe.length ? ue = oe[0] : 1 < oe.length && (ue = indent$2(oe[0])), c = [isNodeStartingWithDeclare(s, o) ? "declare " : "", s.kind, ue ? concat$4([" ", ue]) : "", indent$2(concat$4(oe.slice(1).map(function (e) { return concat$4([",", ce && !se ? hardline$3 : line$3, e]) })))], se && ie.body !== s || c.push(r), group$1(concat$4(c)); case "VariableDeclarator": return printAssignment(s.id, concat$4([t.call(i, "id"), t.call(i, "typeParameters")]), " =", s.init, s.init && t.call(i, "init"), o); case "WithStatement": return group$1(concat$4(["with (", t.call(i, "object"), ")", adjustClause(s.body, t.call(i, "body"))])); case "IfStatement": var le = adjustClause(s.consequent, t.call(i, "consequent")), pe = group$1(concat$4(["if (", group$1(concat$4([indent$2(concat$4([softline$1, t.call(i, "test")])), softline$1])), ")", le])); if (c.push(pe), s.alternate) { var de = hasTrailingComment(s.consequent) && s.consequent.comments.some(function (e) { return e.trailing && !comments$3.isBlockComment(e) }) || needsHardlineAfterDanglingComment(s), me = "BlockStatement" === s.consequent.type && !de; c.push(me ? " " : hardline$3), hasDanglingComments(s) && c.push(comments.printDanglingComments(t, o, !0), de ? hardline$3 : " "), c.push("else", group$1(adjustClause(s.alternate, t.call(i, "alternate"), "IfStatement" === s.alternate.type))) } return concat$4(c); case "ForStatement": var fe = adjustClause(s.body, t.call(i, "body")), De = comments.printDanglingComments(t, o, !0), ge = De ? concat$4([De, softline$1]) : ""; return s.init || s.test || s.update ? concat$4([ge, group$1(concat$4(["for (", group$1(concat$4([indent$2(concat$4([softline$1, t.call(i, "init"), ";", line$3, t.call(i, "test"), ";", line$3, t.call(i, "update")])), softline$1])), ")", fe]))]) : concat$4([ge, group$1(concat$4(["for (;;)", fe]))]); case "WhileStatement": return group$1(concat$4(["while (", group$1(concat$4([indent$2(concat$4([softline$1, t.call(i, "test")])), softline$1])), ")", adjustClause(s.body, t.call(i, "body"))])); case "ForInStatement": return group$1(concat$4([s.each ? "for each (" : "for (", t.call(i, "left"), " in ", t.call(i, "right"), ")", adjustClause(s.body, t.call(i, "body"))])); case "ForOfStatement": case "ForAwaitStatement": var he = "ForAwaitStatement" === s.type || s.await; return group$1(concat$4(["for", he ? " await" : "", " (", t.call(i, "left"), " of ", t.call(i, "right"), ")", adjustClause(s.body, t.call(i, "body"))])); case "DoWhileStatement": var ye = adjustClause(s.body, t.call(i, "body")), Ce = group$1(concat$4(["do", ye])); return c = [Ce], "BlockStatement" === s.body.type ? c.push(" ") : c.push(hardline$3), c.push("while ("), c.push(group$1(concat$4([indent$2(concat$4([softline$1, t.call(i, "test")])), softline$1])), ")", r), concat$4(c); case "DoExpression": return concat$4(["do ", t.call(i, "body")]); case "BreakStatement": return c.push("break"), s.label && c.push(" ", t.call(i, "label")), c.push(r), concat$4(c); case "ContinueStatement": return c.push("continue"), s.label && c.push(" ", t.call(i, "label")), c.push(r), concat$4(c); case "LabeledStatement": return "EmptyStatement" === s.body.type ? concat$4([t.call(i, "label"), ":;"]) : concat$4([t.call(i, "label"), ": ", t.call(i, "body")]); case "TryStatement": return concat$4(["try ", t.call(i, "block"), s.handler ? concat$4([" ", t.call(i, "handler")]) : "", s.finalizer ? concat$4([" finally ", t.call(i, "finalizer")]) : ""]); case "CatchClause": return concat$4(["catch ", s.param ? concat$4(["(", t.call(i, "param"), ") "]) : "", t.call(i, "body")]); case "ThrowStatement": return concat$4(["throw ", t.call(i, "argument"), r]); case "SwitchStatement": return concat$4([group$1(concat$4(["switch (", indent$2(concat$4([softline$1, t.call(i, "discriminant")])), softline$1, ")"])), " {", 0 < s.cases.length ? indent$2(concat$4([hardline$3, join$2(hardline$3, t.map(function (e) { var t = e.getValue(); return concat$4([e.call(i), s.cases.indexOf(t) !== s.cases.length - 1 && isNextLineEmpty$2(o.originalText, t, o) ? hardline$3 : ""]) }, "cases"))])) : "", hardline$3, "}"]); case "SwitchCase": s.test ? c.push("case ", t.call(i, "test"), ":") : c.push("default:"); var $e = s.consequent.filter(function (e) { return "EmptyStatement" !== e.type }); if (0 < $e.length) { var Ee = t.call(function (e) { return printStatementSequence(e, o, i) }, "consequent"); c.push(1 === $e.length && "BlockStatement" === $e[0].type ? concat$4([" ", Ee]) : indent$2(concat$4([hardline$3, Ee]))) } return concat$4(c); case "DebuggerStatement": return concat$4(["debugger", r]); case "JSXAttribute": if (c.push(t.call(i, "name")), s.value) { var Ae; if (isStringLiteral(s.value)) Ae = '"' + rawText(s.value).slice(1, -1).replace(/"/g, "&quot;") + '"'; else Ae = t.call(i, "value"); c.push("=", Ae) } return concat$4(c); case "JSXIdentifier": return s.name ? "" + s.name : "this"; case "JSXNamespacedName": return join$2(":", [t.call(i, "namespace"), t.call(i, "name")]); case "JSXMemberExpression": return join$2(".", [t.call(i, "object"), t.call(i, "property")]); case "TSQualifiedName": return join$2(".", [t.call(i, "left"), t.call(i, "right")]); case "JSXSpreadAttribute": case "JSXSpreadChild": return concat$4(["{", t.call(function (e) { var t = concat$4(["...", i(e)]), n = e.getValue(); return n.comments && n.comments.length ? concat$4([indent$2(concat$4([softline$1, comments.printComments(e, function () { return t }, o)])), softline$1]) : t }, "JSXSpreadAttribute" === s.type ? "argument" : "expression"), "}"]); case "JSXExpressionContainer": var ve = t.getParentNode(0), Fe = !("JSXAttribute" === ve.type && s.expression.comments && 0 < s.expression.comments.length) && ("ArrayExpression" === s.expression.type || "ObjectExpression" === s.expression.type || "ArrowFunctionExpression" === s.expression.type || "CallExpression" === s.expression.type || "OptionalCallExpression" === s.expression.type || "FunctionExpression" === s.expression.type || "JSXEmptyExpression" === s.expression.type || "TemplateLiteral" === s.expression.type || "TaggedTemplateExpression" === s.expression.type || "DoExpression" === s.expression.type || isJSXNode(ve) && ("ConditionalExpression" === s.expression.type || isBinaryish(s.expression))); return group$1(Fe ? concat$4(["{", t.call(i, "expression"), lineSuffixBoundary$1, "}"]) : concat$4(["{", indent$2(concat$4([softline$1, t.call(i, "expression")])), softline$1, lineSuffixBoundary$1, "}"])); case "JSXFragment": case "TSJsxFragment": case "JSXElement": var be = comments.printComments(t, function () { return printJSXElement(t, o, i) }, o); return maybeWrapJSXElementInParens(t, be); case "JSXOpeningElement": var xe = t.getValue(), Se = xe.name && xe.name.comments && 0 < xe.name.comments.length; if (xe.selfClosing && !xe.attributes.length && !Se) return concat$4(["<", t.call(i, "name"), t.call(i, "typeParameters"), " />"]); if (xe.attributes && 1 === xe.attributes.length && xe.attributes[0].value && isStringLiteral(xe.attributes[0].value) && !xe.attributes[0].value.value.includes("\n") && !Se && (!xe.attributes[0].comments || !xe.attributes[0].comments.length)) return group$1(concat$4(["<", t.call(i, "name"), t.call(i, "typeParameters"), " ", concat$4(t.map(i, "attributes")), xe.selfClosing ? " />" : ">"])); var Be = xe.attributes.length && hasTrailingComment(getLast$4(xe.attributes)), Te = o.jsxBracketSameLine && (!Se || xe.attributes.length) && !Be, Ne = xe.attributes && xe.attributes.some(function (e) { return e.value && isStringLiteral(e.value) && e.value.value.includes("\n") }); return group$1(concat$4(["<", t.call(i, "name"), t.call(i, "typeParameters"), concat$4([indent$2(concat$4(t.map(function (e) { return concat$4([line$3, i(e)]) }, "attributes"))), xe.selfClosing ? line$3 : Te ? ">" : softline$1]), xe.selfClosing ? "/>" : Te ? "" : ">"]), { shouldBreak: Ne }); case "JSXClosingElement": return concat$4(["</", t.call(i, "name"), ">"]); case "JSXOpeningFragment": case "JSXClosingFragment": case "TSJsxOpeningFragment": case "TSJsxClosingFragment": var we = s.comments && s.comments.length, Pe = we && !s.comments.every(comments$3.isBlockComment), ke = "JSXOpeningFragment" === s.type || "TSJsxOpeningFragment" === s.type; return concat$4([ke ? "<" : "</", indent$2(concat$4([Pe ? hardline$3 : we && !ke ? " " : "", comments.printDanglingComments(t, o, !0)])), Pe ? hardline$3 : "", ">"]); case "JSXText": throw new Error("JSXTest should be handled by JSXElement"); case "JSXEmptyExpression": var Oe = s.comments && !s.comments.every(comments$3.isBlockComment); return concat$4([comments.printDanglingComments(t, o, !Oe), Oe ? hardline$3 : ""]); case "ClassBody": return s.comments || 0 !== s.body.length ? concat$4(["{", 0 < s.body.length ? indent$2(concat$4([hardline$3, t.call(function (e) { return printStatementSequence(e, o, i) }, "body")])) : comments.printDanglingComments(t, o), hardline$3, "}"]) : "{}"; case "ClassProperty": case "TSAbstractClassProperty": case "ClassPrivateProperty": s.accessibility && c.push(s.accessibility + " "), s.static && c.push("static "), "TSAbstractClassProperty" === s.type && c.push("abstract "), s.readonly && c.push("readonly "); var je = getFlowVariance(s); return je && c.push(je), s.computed ? c.push("[", t.call(i, "key"), "]") : c.push(printPropertyKey(t, o, i)), c.push(printTypeAnnotation(t, o, i)), s.value && c.push(" =", printAssignmentRight(s.key, s.value, t.call(i, "value"), o)), c.push(r), group$1(concat$4(c)); case "ClassDeclaration": case "ClassExpression": case "TSAbstractClassDeclaration": return isNodeStartingWithDeclare(s, o) && c.push("declare "), c.push(concat$4(printClass(t, o, i))), concat$4(c); case "TSInterfaceHeritage": return c.push(t.call(i, "id")), s.typeParameters && c.push(t.call(i, "typeParameters")), concat$4(c); case "TemplateElement": return join$2(literalline$1, s.value.raw.split(/\r?\n/g)); case "TemplateLiteral": var Le = t.map(i, "expressions"), _e = t.getParentNode(), Me = /^[xf]?(describe|it|test)$/; if ("TaggedTemplateExpression" === _e.type && _e.quasi === s && "MemberExpression" === _e.tag.type && "Identifier" === _e.tag.property.type && "each" === _e.tag.property.name && ("Identifier" === _e.tag.object.type && Me.test(_e.tag.object.name) || "MemberExpression" === _e.tag.object.type && "Identifier" === _e.tag.object.property.type && ("only" === _e.tag.object.property.name || "skip" === _e.tag.object.property.name) && "Identifier" === _e.tag.object.object.type && Me.test(_e.tag.object.object.name))) { var Ie = s.quasis[0].value.raw.trim().split(/\s*\|\s*/); if (1 < Ie.length || Ie.some(function (e) { return 0 !== e.length })) { for (var Re = Le.map(function (e) { return "${" + printDocToString$1(e, Object.assign({}, o, { printWidth: 1 / 0 })).formatted + "}" }), qe = [{ hasLineBreak: !1, cells: [] }], Ve = 1; Ve < s.quasis.length; Ve++) { var We = qe[qe.length - 1], Je = Re[Ve - 1]; We.cells.push(Je), -1 !== Je.indexOf("\n") && (We.hasLineBreak = !0), -1 !== s.quasis[Ve].value.raw.indexOf("\n") && qe.push({ hasLineBreak: !1, cells: [] }) } var Ge = qe.reduce(function (e, t) { return Math.max(e, t.cells.length) }, Ie.length), Ue = Array.from(new Array(Ge), function () { return 0 }), Ke = [{ cells: Ie }].concat(qe.filter(function (e) { return 0 !== e.cells.length })); return Ke.filter(function (e) { return !e.hasLineBreak }).forEach(function (e) { e.cells.forEach(function (e, t) { Ue[t] = Math.max(Ue[t], getStringWidth$1(e)) }) }), c.push("`", indent$2(concat$4([hardline$3, join$2(hardline$3, Ke.map(function (n) { return join$2(" | ", n.cells.map(function (e, t) { return n.hasLineBreak ? e : e + " ".repeat(Ue[t] - getStringWidth$1(e)) })) }))])), hardline$3, "`"), concat$4(c) } } return c.push("`"), t.each(function (e) { var t = e.getName(); if (c.push(i(e)), t < Le.length) { var n = o.tabWidth, r = getIndentSize$1(e.getValue().value.raw, n), a = Le[t]; (s.expressions[t].comments && s.expressions[t].comments.length || "MemberExpression" === s.expressions[t].type || "OptionalMemberExpression" === s.expressions[t].type || "ConditionalExpression" === s.expressions[t].type) && (a = concat$4([indent$2(concat$4([softline$1, a])), softline$1])); var u = addAlignmentToDoc$2(a, r, n); c.push(group$1(concat$4(["${", u, lineSuffixBoundary$1, "}"]))) } }, "quasis"), c.push("`"), concat$4(c); case "TaggedTemplateExpression": return concat$4([t.call(i, "tag"), t.call(i, "typeParameters"), t.call(i, "quasi")]); case "Node": case "Printable": case "SourceLocation": case "Position": case "Statement": case "Function": case "Pattern": case "Expression": case "Declaration": case "Specifier": case "NamedSpecifier": case "Comment": case "MemberTypeAnnotation": case "Type": throw new Error("unprintable type: " + JSON.stringify(s.type)); case "TypeAnnotation": case "TSTypeAnnotation": return s.typeAnnotation ? t.call(i, "typeAnnotation") : ""; case "TSTupleType": case "TupleTypeAnnotation": var Xe = "TSTupleType" === s.type ? "elementTypes" : "types"; return group$1(concat$4(["[", indent$2(concat$4([softline$1, printArrayItems(t, o, Xe, i)])), "TSTupleType" === s.type ? "" : ifBreak$1(shouldPrintComma(o) ? "," : ""), comments.printDanglingComments(t, o, !0), softline$1, "]"])); case "ExistsTypeAnnotation": return "*"; case "EmptyTypeAnnotation": return "empty"; case "AnyTypeAnnotation": return "any"; case "MixedTypeAnnotation": return "mixed"; case "ArrayTypeAnnotation": return concat$4([t.call(i, "elementType"), "[]"]); case "BooleanTypeAnnotation": return "boolean"; case "BooleanLiteralTypeAnnotation": return "" + s.value; case "DeclareClass": return printFlowDeclaration(t, printClass(t, o, i)); case "DeclareFunction": return s.params ? concat$4(["declare ", printFunctionDeclaration(t, i, o), r]) : printFlowDeclaration(t, ["function ", t.call(i, "id"), s.predicate ? " " : "", t.call(i, "predicate"), r]); case "DeclareModule": return printFlowDeclaration(t, ["module ", t.call(i, "id"), " ", t.call(i, "body")]); case "DeclareModuleExports": return printFlowDeclaration(t, ["module.exports", ": ", t.call(i, "typeAnnotation"), r]); case "DeclareVariable": return printFlowDeclaration(t, ["var ", t.call(i, "id"), r]); case "DeclareExportAllDeclaration": return concat$4(["declare export * from ", t.call(i, "source")]); case "DeclareExportDeclaration": return concat$4(["declare ", printExportDeclaration(t, o, i)]); case "DeclareOpaqueType": case "OpaqueType": return c.push("opaque type ", t.call(i, "id"), t.call(i, "typeParameters")), s.supertype && c.push(": ", t.call(i, "supertype")), s.impltype && c.push(" = ", t.call(i, "impltype")), c.push(r), "DeclareOpaqueType" === s.type ? printFlowDeclaration(t, c) : concat$4(c); case "FunctionTypeAnnotation": case "TSFunctionType": var ze = t.getParentNode(0), He = t.getParentNode(1), Ye = t.getParentNode(2), Qe = "TSFunctionType" === s.type || !("ObjectTypeProperty" === ze.type && !getFlowVariance(ze) && !ze.optional && o.locStart(ze) === o.locStart(s) || "ObjectTypeCallProperty" === ze.type || Ye && "DeclareFunction" === Ye.type), Ze = Qe && ("TypeAnnotation" === ze.type || "TSTypeAnnotation" === ze.type), et = Ze && Qe && ("TypeAnnotation" === ze.type || "TSTypeAnnotation" === ze.type) && "ArrowFunctionExpression" === He.type; return isObjectTypePropertyAFunction(ze, o) && (Ze = Qe = !0), et && c.push("("), c.push(printFunctionParams(t, i, o, !1, !0)), (s.returnType || s.predicate || s.typeAnnotation) && c.push(Qe ? " => " : ": ", t.call(i, "returnType"), t.call(i, "predicate"), t.call(i, "typeAnnotation")), et && c.push(")"), group$1(concat$4(c)); case "FunctionTypeParam": return concat$4([t.call(i, "name"), printOptionalToken(t), s.name ? ": " : "", t.call(i, "typeAnnotation")]); case "GenericTypeAnnotation": return concat$4([t.call(i, "id"), t.call(i, "typeParameters")]); case "DeclareInterface": case "InterfaceDeclaration": case "InterfaceType": case "InterfaceTypeAnnotation": return "DeclareInterface" !== s.type && !isNodeStartingWithDeclare(s, o) || c.push("declare "), c.push("interface"), "DeclareInterface" !== s.type && "InterfaceDeclaration" !== s.type || c.push(" ", t.call(i, "id"), t.call(i, "typeParameters")), 0 < s.extends.length && c.push(group$1(indent$2(concat$4([line$3, "extends ", join$2(", ", t.map(i, "extends"))])))), c.push(" ", t.call(i, "body")), group$1(concat$4(c)); case "ClassImplements": case "InterfaceExtends": return concat$4([t.call(i, "id"), t.call(i, "typeParameters")]); case "TSIntersectionType": case "IntersectionTypeAnnotation": for (var tt = t.map(i, "types"), nt = [], rt = !1, at = 0; at < tt.length; ++at)0 === at ? nt.push(tt[at]) : isObjectType(s.types[at - 1]) && isObjectType(s.types[at]) ? nt.push(concat$4([" & ", rt ? indent$2(tt[at]) : tt[at]])) : isObjectType(s.types[at - 1]) || isObjectType(s.types[at]) ? (1 < at && (rt = !0), nt.push(" & ", 1 < at ? indent$2(tt[at]) : tt[at])) : nt.push(indent$2(concat$4([" &", line$3, tt[at]]))); return group$1(concat$4(nt)); case "TSUnionType": case "UnionTypeAnnotation": var ut = t.getParentNode(), ot = t.getParentNode(1), it = !("TypeParameterInstantiation" === ut.type || "TSTypeParameterInstantiation" === ut.type || "GenericTypeAnnotation" === ut.type || "TSTypeReference" === ut.type || "FunctionTypeParam" === ut.type && !ut.name || "TSTypeAssertionExpression" === ot.type || ("TypeAlias" === ut.type || "VariableDeclarator" === ut.type) && hasLeadingOwnLineComment(o.originalText, s, o)), st = shouldHugType(s), ct = t.map(function (e) { var t = e.call(i); return st || (t = align$1(2, t)), comments.printComments(e, function () { return t }, o) }, "types"); if (st) return join$2(" | ", ct); var lt, pt = concat$4([ifBreak$1(concat$4([it ? line$3 : "", "| "])), join$2(concat$4([line$3, "| "]), ct)]); if ("TSUnionType" === s.type) { var dt = t.getParentNode(2), mt = t.getParentNode(3); lt = dt && "TSParenthesizedType" === dt.type && mt && ("TSUnionType" === mt.type || "TSIntersectionType" === mt.type) } else lt = needsParens_1(t, o); return group$1(lt ? concat$4([indent$2(pt), softline$1]) : it ? indent$2(pt) : pt); case "NullableTypeAnnotation": return concat$4(["?", t.call(i, "typeAnnotation")]); case "TSNullKeyword": case "NullLiteralTypeAnnotation": return "null"; case "ThisTypeAnnotation": return "this"; case "NumberTypeAnnotation": return "number"; case "ObjectTypeCallProperty": return s.static && c.push("static "), c.push(t.call(i, "value")), concat$4(c); case "ObjectTypeIndexer": var ft = getFlowVariance(s); return concat$4([ft || "", "[", t.call(i, "id"), s.id ? ": " : "", t.call(i, "key"), "]: ", t.call(i, "value")]); case "ObjectTypeProperty": var Dt = getFlowVariance(s), gt = ""; return s.proto ? gt = "proto " : s.static && (gt = "static "), concat$4([gt, isGetterOrSetter(s) ? s.kind + " " : "", Dt || "", printPropertyKey(t, o, i), printOptionalToken(t), isFunctionNotation(s, o) ? "" : ": ", t.call(i, "value")]); case "QualifiedTypeIdentifier": return concat$4([t.call(i, "qualification"), ".", t.call(i, "id")]); case "StringLiteralTypeAnnotation": return nodeStr(s, o); case "NumberLiteralTypeAnnotation": return assert.strictEqual(_typeof(s.value), "number"), null != s.extra ? printNumber$1(s.extra.raw) : printNumber$1(s.raw); case "StringTypeAnnotation": return "string"; case "DeclareTypeAlias": case "TypeAlias": "DeclareTypeAlias" !== s.type && !isNodeStartingWithDeclare(s, o) || c.push("declare "); var ht = printAssignmentRight(s.id, s.right, t.call(i, "right"), o); return c.push("type ", t.call(i, "id"), t.call(i, "typeParameters"), " =", ht, r), group$1(concat$4(c)); case "TypeCastExpression": return concat$4(["(", t.call(i, "expression"), ": ", t.call(i, "typeAnnotation"), ")"]); case "TypeParameterDeclaration": case "TypeParameterInstantiation": case "TSTypeParameterDeclaration": case "TSTypeParameterInstantiation": return printTypeParameters(t, o, i, "params"); case "TSTypeParameter": case "TypeParameter": if ("TSMappedType" === t.getParentNode().type) return c.push("[", t.call(i, "name")), s.constraint && c.push(" in ", t.call(i, "constraint")), c.push("]"), concat$4(c); var yt = getFlowVariance(s); return yt && c.push(yt), c.push(t.call(i, "name")), s.bound && (c.push(": "), c.push(t.call(i, "bound"))), s.constraint && c.push(" extends ", t.call(i, "constraint")), s.default && c.push(" = ", t.call(i, "default")), concat$4(c); case "TypeofTypeAnnotation": return concat$4(["typeof ", t.call(i, "argument")]); case "VoidTypeAnnotation": return "void"; case "InferredPredicate": return "%checks"; case "DeclaredPredicate": return concat$4(["%checks(", t.call(i, "value"), ")"]); case "TSAbstractKeyword": return "abstract"; case "TSAnyKeyword": return "any"; case "TSAsyncKeyword": return "async"; case "TSBooleanKeyword": return "boolean"; case "TSConstKeyword": return "const"; case "TSDeclareKeyword": return "declare"; case "TSExportKeyword": return "export"; case "TSNeverKeyword": return "never"; case "TSNumberKeyword": return "number"; case "TSObjectKeyword": return "object"; case "TSProtectedKeyword": return "protected"; case "TSPrivateKeyword": return "private"; case "TSPublicKeyword": return "public"; case "TSReadonlyKeyword": return "readonly"; case "TSSymbolKeyword": return "symbol"; case "TSStaticKeyword": return "static"; case "TSStringKeyword": return "string"; case "TSUndefinedKeyword": return "undefined"; case "TSVoidKeyword": return "void"; case "TSAsExpression": return concat$4([t.call(i, "expression"), " as ", t.call(i, "typeAnnotation")]); case "TSArrayType": return concat$4([t.call(i, "elementType"), "[]"]); case "TSPropertySignature": return s.export && c.push("export "), s.accessibility && c.push(s.accessibility + " "), s.static && c.push("static "), s.readonly && c.push("readonly "), s.computed && c.push("["), c.push(printPropertyKey(t, o, i)), s.computed && c.push("]"), c.push(printOptionalToken(t)), s.typeAnnotation && (c.push(": "), c.push(t.call(i, "typeAnnotation"))), s.initializer && c.push(" = ", t.call(i, "initializer")), concat$4(c); case "TSParameterProperty": return s.accessibility && c.push(s.accessibility + " "), s.export && c.push("export "), s.static && c.push("static "), s.readonly && c.push("readonly "), c.push(t.call(i, "parameter")), concat$4(c); case "TSTypeReference": return concat$4([t.call(i, "typeName"), printTypeParameters(t, o, i, "typeParameters")]); case "TSTypeQuery": return concat$4(["typeof ", t.call(i, "exprName")]); case "TSParenthesizedType": return t.call(i, "typeAnnotation"); case "TSIndexSignature": var Ct = t.getParentNode(); return concat$4([s.export ? "export " : "", s.accessibility ? concat$4([s.accessibility, " "]) : "", s.static ? "static " : "", s.readonly ? "readonly " : "", "[", t.call(i, "index"), "]: ", t.call(i, "typeAnnotation"), "ClassBody" === Ct.type ? r : ""]); case "TSTypePredicate": return concat$4([t.call(i, "parameterName"), " is ", t.call(i, "typeAnnotation")]); case "TSNonNullExpression": return concat$4([t.call(i, "expression"), "!"]); case "TSThisType": return "this"; case "TSLastTypeNode": return concat$4([s.isTypeOf ? "typeof " : "", "import(", t.call(i, "argument"), ")", s.qualifier ? concat$4([".", t.call(i, "qualifier")]) : ""]); case "TSLiteralType": return t.call(i, "literal"); case "TSIndexedAccessType": return concat$4([t.call(i, "objectType"), "[", t.call(i, "indexType"), "]"]); case "TSConstructSignature": case "TSConstructorType": case "TSCallSignature": if ("TSCallSignature" !== s.type && c.push("new "), c.push(group$1(printFunctionParams(t, i, o, !1, !0))), s.typeAnnotation) { var $t = "TSConstructorType" === s.type; c.push($t ? " => " : ": ", t.call(i, "typeAnnotation")) } return concat$4(c); case "TSTypeOperator": return concat$4([s.operator, " ", t.call(i, "typeAnnotation")]); case "TSMappedType": return group$1(concat$4(["{", indent$2(concat$4([o.bracketSpacing ? line$3 : softline$1, s.readonlyToken ? concat$4([getTypeScriptMappedTypeModifier(s.readonlyToken, "readonly"), " "]) : "", printTypeScriptModifiers(t, o, i), t.call(i, "typeParameter"), s.questionToken ? getTypeScriptMappedTypeModifier(s.questionToken, "?") : "", ": ", t.call(i, "typeAnnotation")])), comments.printDanglingComments(t, o, !0), o.bracketSpacing ? line$3 : softline$1, "}"])); case "TSMethodSignature": return c.push(s.accessibility ? concat$4([s.accessibility, " "]) : "", s.export ? "export " : "", s.static ? "static " : "", s.readonly ? "readonly " : "", s.computed ? "[" : "", t.call(i, "key"), s.computed ? "]" : "", printOptionalToken(t), printFunctionParams(t, i, o, !1, !0)), s.typeAnnotation && c.push(": ", t.call(i, "typeAnnotation")), group$1(concat$4(c)); case "TSNamespaceExportDeclaration": return c.push("export as namespace ", t.call(i, "name")), o.semi && c.push(";"), group$1(concat$4(c)); case "TSEnumDeclaration": return isNodeStartingWithDeclare(s, o) && c.push("declare "), s.modifiers && c.push(printTypeScriptModifiers(t, o, i)), s.const && c.push("const "), c.push("enum ", t.call(i, "id"), " "), 0 === s.members.length ? c.push(group$1(concat$4(["{", comments.printDanglingComments(t, o), softline$1, "}"]))) : c.push(group$1(concat$4(["{", indent$2(concat$4([hardline$3, printArrayItems(t, o, "members", i), shouldPrintComma(o, "es5") ? "," : ""])), comments.printDanglingComments(t, o, !0), hardline$3, "}"]))), concat$4(c); case "TSEnumMember": return c.push(t.call(i, "id")), s.initializer && c.push(" = ", t.call(i, "initializer")), concat$4(c); case "TSImportEqualsDeclaration": return c.push(printTypeScriptModifiers(t, o, i), "import ", t.call(i, "name"), " = ", t.call(i, "moduleReference")), o.semi && c.push(";"), group$1(concat$4(c)); case "TSExternalModuleReference": return concat$4(["require(", t.call(i, "expression"), ")"]); case "TSModuleDeclaration": var Et = t.getParentNode(), At = isLiteral(s.id), vt = "TSModuleDeclaration" === Et.type, Ft = s.body && "TSModuleDeclaration" === s.body.type; if (vt) c.push("."); else !0 === s.declare && c.push("declare "), c.push(printTypeScriptModifiers(t, o, i)), "Identifier" === s.id.type && "global" === s.id.name && !/namespace|module/.test(o.originalText.slice(o.locStart(s), o.locStart(s.id))) || c.push(At ? "module " : "namespace "); return c.push(t.call(i, "id")), Ft ? c.push(t.call(i, "body")) : s.body ? c.push(" {", indent$2(concat$4([line$3, t.call(function (e) { return comments.printDanglingComments(e, o, !0) }, "body"), group$1(t.call(i, "body"))])), line$3, "}") : c.push(r), concat$4(c); case "TSModuleBlock": return t.call(function (e) { return printStatementSequence(e, o, i) }, "body"); case "PrivateName": return concat$4(["#", t.call(i, "id")]); case "TSConditionalType": return formatTernaryOperator(t, o, i, { beforeParts: function () { return [t.call(i, "checkType"), " ", "extends", " ", t.call(i, "extendsType")] }, shouldCheckJsx: !1, operatorName: "TSConditionalType", consequentNode: "trueType", alternateNode: "falseType", testNode: "checkType", breakNested: !1 }); case "TSInferType": return concat$4(["infer", " ", t.call(i, "typeParameter")]); case "InterpreterDirective": return c.push("#!", s.value, hardline$3), isNextLineEmpty$2(o.originalText, s, o) && c.push(hardline$3), concat$4(c); default: throw new Error("unknown type: " + JSON.stringify(s.type)) } } function printStatementSequence(e, o, i) { var s = [], c = e.getNode(), l = "ClassBody" === c.type; return e.map(function (e, t) { var n = e.getValue(); if (n && "EmptyStatement" !== n.type) { var r = i(e), a = o.originalText, u = []; if (o.semi || l || isTheOnlyJSXElementInMarkdown(o, e) || !stmtNeedsASIProtection(e, o) ? u.push(r) : n.comments && n.comments.some(function (e) { return e.leading }) ? u.push(i(e, { needsSemi: !0 })) : u.push(";", r), !o.semi && l) if (classPropMayCauseASIProblems(e)) u.push(";"); else if ("ClassProperty" === n.type) { classChildNeedsASIProtection(c.body[t + 1]) && u.push(";") } isNextLineEmpty$2(a, n, o) && !isLastStatement(e) && u.push(hardline$3), s.push(concat$4(u)) } }), join$2(hardline$3, s) } function printPropertyKey(e, t, n) { var r = e.getNode(), a = r.key; return "Identifier" !== a.type || r.computed || "json" !== t.parser ? !isStringLiteral(a) || !isIdentifierName(a.value) || r.computed || "json" === t.parser || "typescript" === t.parser && "ClassProperty" === r.type ? e.call(n, "key") : e.call(function (e) { return comments.printComments(e, function () { return a.value }, t) }, "key") : e.call(function (e) { return comments.printComments(e, function () { return JSON.stringify(a.name) }, t) }, "key") } function printMethod(e, t, n) { var r = e.getNode(), a = t.semi ? ";" : "", u = r.kind, o = []; "ObjectMethod" !== r.type && "ClassMethod" !== r.type || (r.value = r), r.value.async && o.push("async "), u && "init" !== u && "method" !== u && "constructor" !== u ? (assert.ok("get" === u || "set" === u), o.push(u, " ")) : r.value.generator && o.push("*"); var i = printPropertyKey(e, t, n); return r.computed && (i = concat$4(["[", i, "]"])), o.push(i, concat$4(e.call(function (e) { return [printFunctionTypeParameters(e, t, n), group$1(concat$4([printFunctionParams(e, n, t), printReturnType(e, n, t)]))] }, "value"))), r.value.body && 0 !== r.value.body.length ? o.push(" ", e.call(n, "value", "body")) : o.push(a), concat$4(o) } function couldGroupArg(e) { return "ObjectExpression" === e.type && (0 < e.properties.length || e.comments) || "ArrayExpression" === e.type && (0 < e.elements.length || e.comments) || "TSTypeAssertionExpression" === e.type || "TSAsExpression" === e.type || "FunctionExpression" === e.type || "ArrowFunctionExpression" === e.type && ("BlockStatement" === e.body.type || "ArrowFunctionExpression" === e.body.type || "ObjectExpression" === e.body.type || "ArrayExpression" === e.body.type || "CallExpression" === e.body.type || "OptionalCallExpression" === e.body.type || isJSXNode(e.body)) } function shouldGroupLastArg(e) { var t = getLast$4(e), n = getPenultimate$1(e); return !hasLeadingComment(t) && !hasTrailingComment(t) && couldGroupArg(t) && (!n || n.type !== t.type) } function shouldGroupFirstArg(e) { if (2 !== e.length) return !1; var t = e[0], n = e[1]; return !(t.comments && t.comments.length || "FunctionExpression" !== t.type && ("ArrowFunctionExpression" !== t.type || "BlockStatement" !== t.body.type) || couldGroupArg(n)) } var functionCompositionFunctionNames = { pipe: !0, pipeP: !0, pipeK: !0, compose: !0, composeFlipped: !0, composeP: !0, composeK: !0, flow: !0, flowRight: !0, connect: !0 }; function isFunctionCompositionFunction(e) { switch (e.type) { case "OptionalMemberExpression": case "MemberExpression": return isFunctionCompositionFunction(e.property); case "Identifier": return functionCompositionFunctionNames[e.name]; case "StringLiteral": case "Literal": return functionCompositionFunctionNames[e.value] } } function printArgumentsList(e, a, u) { var t = e.getValue(), n = t.arguments; if (0 === n.length) return concat$4(["(", comments.printDanglingComments(e, a, !0), ")"]); var o = !1, i = !1, s = n.length - 1, r = e.map(function (e, t) { var n = e.getNode(), r = [u(e)]; return t === s || (isNextLineEmpty$2(a.originalText, n, a) ? (0 === t && (i = !0), o = !0, r.push(",", hardline$3, hardline$3)) : r.push(",", line$3)), concat$4(r) }, "arguments"), c = shouldPrintComma(a, "all") ? "," : ""; function l() { return group$1(concat$4(["(", indent$2(concat$4([line$3, concat$4(r)])), c, line$3, ")"]), { shouldBreak: !0 }) } if (isFunctionCompositionFunction(t.callee) && 1 < n.length) return l(); var p = shouldGroupFirstArg(n), d = shouldGroupLastArg(n); if (p || d) { var m, f = (p ? r.slice(1).some(willBreak$1) : r.slice(0, -1).some(willBreak$1)) || o, D = 0; e.each(function (e) { p && 0 === D && (m = [concat$4([e.call(function (e) { return u(e, { expandFirstArg: !0 }) }), 1 < r.length ? "," : "", i ? hardline$3 : line$3, i ? hardline$3 : ""])].concat(r.slice(1))), d && D === n.length - 1 && (m = r.slice(0, -1).concat(e.call(function (e) { return u(e, { expandLastArg: !0 }) }))), D++ }, "arguments"); var g = r.some(willBreak$1); return concat$4([g ? breakParent$2 : "", conditionalGroup$1([concat$4([ifBreak$1(indent$2(concat$4(["(", softline$1, concat$4(m)])), concat$4(["(", concat$4(m)])), g ? concat$4([ifBreak$1(c), softline$1]) : "", ")"]), concat$4(p ? ["(", group$1(m[0], { shouldBreak: !0 }), concat$4(m.slice(1)), ")"] : ["(", concat$4(r.slice(0, -1)), group$1(getLast$4(m), { shouldBreak: !0 }), ")"]), l()], { shouldBreak: f })]) } return group$1(concat$4(["(", indent$2(concat$4([softline$1, concat$4(r)])), ifBreak$1(shouldPrintComma(a, "all") ? "," : ""), softline$1, ")"]), { shouldBreak: r.some(willBreak$1) || o }) } function printTypeAnnotation(e, t, n) { var r = e.getValue(); if (!r.typeAnnotation) return ""; var a = e.getParentNode(), u = r.definite || a && "VariableDeclarator" === a.type && a.definite, o = "DeclareFunction" === a.type && a.id === r; return isFlowAnnotationComment(t.originalText, r.typeAnnotation, t) ? concat$4([" /*: ", e.call(n, "typeAnnotation"), " */"]) : concat$4([o ? "" : u ? "!: " : ": ", e.call(n, "typeAnnotation")]) } function printFunctionTypeParameters(e, t, n) { var r = e.getValue(); return r.typeArguments ? e.call(n, "typeArguments") : r.typeParameters ? e.call(n, "typeParameters") : "" } function printFunctionParams(e, t, n, r, a) { var u = e.getValue(), o = u.parameters ? "parameters" : "params", i = a ? printFunctionTypeParameters(e, n, t) : "", s = []; if (u[o] && (s = e.map(t, o)), u.rest && s.push(concat$4(["...", e.call(t, "rest")])), 0 === s.length) return concat$4([i, "(", comments.printDanglingComments(e, n, !0, function (e) { return ")" === getNextNonSpaceNonCommentCharacter$1(n.originalText, e, n.locEnd) }), ")"]); var c = getLast$4(u[o]); if (r && (!u[o] || !u[o].some(function (e) { return e.comments }))) return group$1(concat$4([removeLines$1(i), "(", join$2(", ", s.map(removeLines$1)), ")"])); if (shouldHugArguments(u)) return concat$4([i, "(", join$2(", ", s), ")"]); var l = e.getParentNode(); if (isTestCall(l)) return concat$4([i, "(", join$2(", ", s), ")"]); if ((isObjectTypePropertyAFunction(l, n) || isTypeAnnotationAFunction(l, n) || "TypeAlias" === l.type || "UnionTypeAnnotation" === l.type || "TSUnionType" === l.type || "IntersectionTypeAnnotation" === l.type || "FunctionTypeAnnotation" === l.type && l.returnType === u) && 1 === u[o].length && null === u[o][0].name && u[o][0].typeAnnotation && null === u.typeParameters && -1 !== ["AnyTypeAnnotation", "NullLiteralTypeAnnotation", "GenericTypeAnnotation", "ThisTypeAnnotation", "NumberTypeAnnotation", "VoidTypeAnnotation", "EmptyTypeAnnotation", "MixedTypeAnnotation", "BooleanTypeAnnotation", "BooleanLiteralTypeAnnotation", "StringTypeAnnotation"].indexOf(u[o][0].typeAnnotation.type) && !("GenericTypeAnnotation" === u[o][0].typeAnnotation.type && u[o][0].typeAnnotation.typeParameters) && !u.rest) return "always" === n.arrowParens ? concat$4(["(", concat$4(s), ")"]) : concat$4(s); var p = !(c && "RestElement" === c.type || u.rest); return concat$4([i, "(", indent$2(concat$4([softline$1, join$2(concat$4([",", line$3]), s)])), ifBreak$1(p && shouldPrintComma(n, "all") ? "," : ""), softline$1, ")"]) } function shouldPrintParamsWithoutParens(e, t) { return "always" !== t.arrowParens && ("avoid" === t.arrowParens && canPrintParamsWithoutParens(e.getValue())) } function canPrintParamsWithoutParens(e) { return !(1 !== e.params.length || e.rest || e.typeParameters || hasDanglingComments(e) || "Identifier" !== e.params[0].type || e.params[0].typeAnnotation || e.params[0].comments || e.params[0].optional || e.predicate || e.returnType) } function printFunctionDeclaration(e, t, n) { var r = e.getValue(), a = []; return r.async && a.push("async "), a.push("function"), r.generator && a.push("*"), r.id && a.push(" ", e.call(t, "id")), a.push(printFunctionTypeParameters(e, n, t), group$1(concat$4([printFunctionParams(e, t, n), printReturnType(e, t, n)])), r.body ? " " : "", e.call(t, "body")), concat$4(a) } function printObjectMethod(e, t, n) { var r = e.getValue(), a = []; if (r.async && a.push("async "), r.generator && a.push("*"), r.method || "get" === r.kind || "set" === r.kind) return printMethod(e, t, n); var u = printPropertyKey(e, t, n); return r.computed ? a.push("[", u, "]") : a.push(u), a.push(printFunctionTypeParameters(e, t, n), group$1(concat$4([printFunctionParams(e, n, t), printReturnType(e, n, t)])), " ", e.call(n, "body")), concat$4(a) } function printReturnType(e, t, n) { var r = e.getValue(), a = e.call(t, "returnType"); if (r.returnType && isFlowAnnotationComment(n.originalText, r.returnType, n)) return concat$4([" /*: ", a, " */"]); var u = [a]; return r.returnType && r.returnType.typeAnnotation && u.unshift(": "), r.predicate && u.push(r.returnType ? " " : ": ", e.call(t, "predicate")), concat$4(u) } function printExportDeclaration(n, e, r) { var t = n.getValue(), a = e.semi ? ";" : "", u = ["export "], o = t.default || "ExportDefaultDeclaration" === t.type; if (o && u.push("default "), u.push(comments.printDanglingComments(n, e, !0)), needsHardlineAfterDanglingComment(t) && u.push(hardline$3), t.declaration) u.push(n.call(r, "declaration")), o && "ClassDeclaration" !== t.declaration.type && "FunctionDeclaration" !== t.declaration.type && "TSAbstractClassDeclaration" !== t.declaration.type && "TSInterfaceDeclaration" !== t.declaration.type && "DeclareClass" !== t.declaration.type && "DeclareFunction" !== t.declaration.type && u.push(a); else { if (t.specifiers && 0 < t.specifiers.length) { var i = [], s = [], c = []; n.each(function (e) { var t = n.getValue().type; "ExportSpecifier" === t ? i.push(r(e)) : "ExportDefaultSpecifier" === t ? s.push(r(e)) : "ExportNamespaceSpecifier" === t && c.push(concat$4(["* as ", r(e)])) }, "specifiers"); var l = 0 !== c.length && 0 !== i.length, p = 0 !== s.length && (0 !== c.length || 0 !== i.length); u.push("type" === t.exportKind ? "type " : "", concat$4(s), concat$4([p ? ", " : ""]), concat$4(c), concat$4([l ? ", " : ""]), 0 !== i.length ? group$1(concat$4(["{", indent$2(concat$4([e.bracketSpacing ? line$3 : softline$1, join$2(concat$4([",", line$3]), i)])), ifBreak$1(shouldPrintComma(e) ? "," : ""), e.bracketSpacing ? line$3 : softline$1, "}"])) : "") } else u.push("{}"); t.source && u.push(" from ", n.call(r, "source")), u.push(a) } return concat$4(u) } function printFlowDeclaration(e, t) { var n = getParentExportDeclaration$1(e); return n ? assert.strictEqual(n.type, "DeclareExportDeclaration") : t.unshift("declare "), concat$4(t) } function getFlowVariance(e) { if (!e.variance) return null; var t = e.variance.kind || e.variance; switch (t) { case "plus": return "+"; case "minus": return "-"; default: return t } } function printTypeScriptModifiers(e, t, n) { var r = e.getValue(); return r.modifiers && r.modifiers.length ? concat$4([join$2(" ", e.map(n, "modifiers")), " "]) : "" } function printTypeParameters(e, t, n, r) { var a = e.getValue(); if (!a[r]) return ""; if (!Array.isArray(a[r])) return e.call(n, r); var u = e.getNode(2); return null != u && isTestCall(u) || 0 === a[r].length || 1 === a[r].length && (shouldHugType(a[r][0]) || "GenericTypeAnnotation" === a[r][0].type && shouldHugType(a[r][0].id) || "TSTypeReference" === a[r][0].type && shouldHugType(a[r][0].typeName) || "NullableTypeAnnotation" === a[r][0].type) ? concat$4(["<", join$2(", ", e.map(n, r)), ">"]) : group$1(concat$4(["<", indent$2(concat$4([softline$1, join$2(concat$4([",", line$3]), e.map(n, r))])), ifBreak$1("typescript" !== t.parser && shouldPrintComma(t, "all") ? "," : ""), softline$1, ">"])) } function printClass(e, t, n) { var r = e.getValue(), a = []; "TSAbstractClassDeclaration" === r.type && a.push("abstract "), a.push("class"), r.id && a.push(" ", e.call(n, "id")), a.push(e.call(n, "typeParameters")); var u = []; if (r.superClass) { var o = concat$4(["extends ", e.call(n, "superClass"), e.call(n, "superTypeParameters")]); r.implements && 0 !== r.implements.length || r.superClass.comments && 0 !== r.superClass.comments.length ? u.push(group$1(concat$4([line$3, e.call(function (e) { return comments.printComments(e, function () { return o }, t) }, "superClass")]))) : a.push(concat$4([" ", e.call(function (e) { return comments.printComments(e, function () { return o }, t) }, "superClass")])) } else r.extends && 0 < r.extends.length && a.push(" extends ", join$2(", ", e.map(n, "extends"))); return r.mixins && 0 < r.mixins.length && u.push(line$3, "mixins ", group$1(indent$2(join$2(concat$4([",", line$3]), e.map(n, "mixins"))))), r.implements && 0 < r.implements.length && u.push(line$3, "implements", group$1(indent$2(concat$4([line$3, join$2(concat$4([",", line$3]), e.map(n, "implements"))])))), 0 < u.length && a.push(group$1(indent$2(concat$4(u)))), r.body && r.body.comments && hasLeadingOwnLineComment(t.originalText, r.body, t) ? a.push(hardline$3) : a.push(" "), a.push(e.call(n, "body")), a } function printOptionalToken(e) { var t = e.getValue(); return t.optional ? "OptionalCallExpression" === t.type || "OptionalMemberExpression" === t.type && t.computed ? "?." : "?" : "" } function printMemberLookup(e, t, n) { var r = e.call(n, "property"), a = e.getValue(), u = printOptionalToken(e); return a.computed ? !a.property || isNumericLiteral(a.property) ? concat$4([u, "[", r, "]"]) : group$1(concat$4([u, "[", indent$2(concat$4([softline$1, r])), softline$1, "]"])) : concat$4([u, ".", r]) } function printBindExpressionCallee(e, t, n) { return concat$4(["::", e.call(n, "callee")]) } function printMemberChain(o, r, a) { var u = []; function i(e) { var t = r.originalText, n = getNextNonSpaceNonCommentCharacterIndex$2(t, e, r); return ")" == t.charAt(n) ? isNextLineEmptyAfterIndex$1(t, n + 1, r) : isNextLineEmpty$2(t, e, r) } var e = o.getValue(); u.unshift({ node: e, printed: concat$4([printOptionalToken(o), printFunctionTypeParameters(o, r, a), printArgumentsList(o, r, a)]) }), o.call(function (e) { return function t(e) { var n = e.getValue(); "CallExpression" !== n.type && "OptionalCallExpression" !== n.type || !isMemberish(n.callee) && "CallExpression" !== n.callee.type && "OptionalCallExpression" !== n.callee.type ? isMemberish(n) ? (u.unshift({ node: n, needsParens: needsParens_1(e, r), printed: comments.printComments(e, function () { return "OptionalMemberExpression" === n.type || "MemberExpression" === n.type ? printMemberLookup(e, r, a) : printBindExpressionCallee(e, r, a) }, r) }), e.call(function (e) { return t(e) }, "object")) : "TSNonNullExpression" === n.type ? (u.unshift({ node: n, printed: comments.printComments(e, function () { return "!" }, r) }), e.call(function (e) { return t(e) }, "expression")) : u.unshift({ node: n, printed: e.call(a) }) : (u.unshift({ node: n, printed: concat$4([comments.printComments(e, function () { return concat$4([printOptionalToken(e), printFunctionTypeParameters(e, r, a), printArgumentsList(e, r, a)]) }, r), i(n) ? hardline$3 : ""]) }), e.call(function (e) { return t(e) }, "callee")) }(e) }, "callee"); for (var t = [], n = [u[0]], s = 1; s < u.length && ("TSNonNullExpression" === u[s].node.type || "OptionalCallExpression" === u[s].node.type || "CallExpression" === u[s].node.type || ("MemberExpression" === u[s].node.type || "OptionalMemberExpression" === u[s].node.type) && u[s].node.computed && isNumericLiteral(u[s].node.property)); ++s)n.push(u[s]); if ("CallExpression" !== u[0].node.type && "OptionalCallExpression" !== u[0].node.type) for (; s + 1 < u.length && (isMemberish(u[s].node) && isMemberish(u[s + 1].node)); ++s)n.push(u[s]); t.push(n); for (var c = !(n = []); s < u.length; ++s) { if (c && isMemberish(u[s].node)) { if (u[s].node.computed && isNumericLiteral(u[s].node.property)) { n.push(u[s]); continue } t.push(n), c = !(n = []) } "CallExpression" !== u[s].node.type && "OptionalCallExpression" !== u[s].node.type || (c = !0), n.push(u[s]), u[s].node.comments && u[s].node.comments.some(function (e) { return e.trailing }) && (t.push(n), c = !(n = [])) } function l(e) { return /^[A-Z]/.test(e) } function p(e) { return e.length <= r.tabWidth } 0 < n.length && t.push(n); var d = 2 <= t.length && !t[1][0].node.comments && function (e) { var t = o.getParentNode(), n = t && "ExpressionStatement" === t.type, r = e[1].length && e[1][0].node.computed; if (1 === e[0].length) { var a = e[0][0].node; return "ThisExpression" === a.type || "Identifier" === a.type && (l(a.name) || n && p(a.name) || r) } var u = getLast$4(e[0]).node; return ("MemberExpression" === u.type || "OptionalMemberExpression" === u.type) && "Identifier" === u.property.type && (l(u.property.name) || n && p(u.property.name) || r) }(t); function m(e) { for (var t = [], n = 0; n < e.length; n++)e[n + 1] && e[n + 1].needsParens ? (t.push("(", e[n].printed, e[n + 1].printed, ")"), n++) : t.push(e[n].printed); return concat$4(t) } var f = t.map(m), D = concat$4(f), g = d ? 3 : 2, h = t.slice(0, g).reduce(function (e, t) { return e.concat(t) }, []), y = h.slice(1, -1).some(function (e) { return hasLeadingComment(e.node) }) || h.slice(0, -1).some(function (e) { return hasTrailingComment(e.node) }) || t[g] && hasLeadingComment(t[g][0].node); if (t.length <= g && !y) return group$1(D); var C, $ = getLast$4(d ? t.slice(1, 2)[0] : t[0]).node, E = "CallExpression" !== $.type && "OptionalCallExpression" !== $.type && i($), A = concat$4([m(t[0]), d ? concat$4(t.slice(1, 2).map(m)) : "", E ? hardline$3 : "", (C = t.slice(d ? 2 : 1), 0 === C.length ? "" : indent$2(group$1(concat$4([hardline$3, join$2(hardline$3, C.map(m))]))))]), v = u.filter(function (e) { return "CallExpression" === e.node.type || "OptionalCallExpression" === e.node.type }).length; return y || 3 <= v || f.slice(0, -1).some(willBreak$1) ? group$1(A) : concat$4([willBreak$1(D) || E ? breakParent$2 : "", conditionalGroup$1([D, A])]) } function isJSXNode(e) { return "JSXElement" === e.type || "JSXFragment" === e.type || "TSJsxFragment" === e.type } function isEmptyJSXElement(e) { if (0 === e.children.length) return !0; if (1 < e.children.length) return !1; var t = e.children[0]; return isLiteral(t) && !isMeaningfulJSXText(t) } var jsxWhitespaceChars = " \n\r\t", containsNonJsxWhitespaceRegex = new RegExp("[^" + jsxWhitespaceChars + "]"), matchJsxWhitespaceRegex = new RegExp("([" + jsxWhitespaceChars + "]+)"); function isMeaningfulJSXText(e) { return isLiteral(e) && (containsNonJsxWhitespaceRegex.test(rawText(e)) || !/\n/.test(rawText(e))) } function conditionalExpressionChainContainsJSX(e) { return Boolean(getConditionalChainContents(e).find(isJSXNode)) } function getConditionalChainContents(e) { var n = []; return function e(t) { "ConditionalExpression" === t.type ? (e(t.test), e(t.consequent), e(t.alternate)) : n.push(t) }(e), n } function isJSXWhitespaceExpression(e) { return "JSXExpressionContainer" === e.type && isLiteral(e.expression) && " " === e.expression.value && !e.expression.comments } function printJSXChildren(e, t, s, c) { var l = e.getValue(), p = []; return e.map(function (e, t) { var n = e.getValue(); if (isLiteral(n)) { var r = rawText(n); if (isMeaningfulJSXText(n)) { var a, u = r.split(matchJsxWhitespaceRegex); if ("" === u[0] && (p.push(""), u.shift(), /\n/.test(u[0]) ? p.push(hardline$3) : p.push(c), u.shift()), "" === getLast$4(u) && (u.pop(), a = u.pop()), 0 === u.length) return; u.forEach(function (e, t) { t % 2 == 1 ? p.push(line$3) : p.push(e) }), void 0 !== a ? /\n/.test(a) ? p.push(hardline$3) : p.push(c) : p.push("") } else /\n/.test(r) ? 1 < r.match(/\n/g).length && (p.push(""), p.push(hardline$3)) : (p.push(""), p.push(c)) } else { var o = s(e); p.push(o); var i = l.children[t + 1]; i && isMeaningfulJSXText(i) && !/^[ \n\r\t]/.test(rawText(i)) ? p.push("") : p.push(hardline$3) } }, "children"), p } function printJSXElement(e, t, n) { var r = e.getValue(); if ("JSXElement" === r.type && isEmptyJSXElement(r)) return r.openingElement.selfClosing = !0, e.call(n, "openingElement"); var a = "JSXElement" === r.type ? e.call(n, "openingElement") : e.call(n, "openingFragment"), u = "JSXElement" === r.type ? e.call(n, "closingElement") : e.call(n, "closingFragment"); if (1 === r.children.length && "JSXExpressionContainer" === r.children[0].type && ("TemplateLiteral" === r.children[0].expression.type || "TaggedTemplateExpression" === r.children[0].expression.type)) return concat$4([a, concat$4(e.map(n, "children")), u]); r.children = r.children.map(function (e) { return isJSXWhitespaceExpression(e) ? { type: "JSXText", value: " ", raw: " " } : e }); for (var o = 0 < r.children.filter(isJSXNode).length, i = 1 < r.children.filter(function (e) { return "JSXExpressionContainer" === e.type }).length, s = "JSXElement" === r.type && 1 < r.openingElement.attributes.length, c = willBreak$1(a) || o || s || i, l = t.singleQuote ? "{' '}" : '{" "}', p = ifBreak$1(concat$4([l, softline$1]), " "), d = printJSXChildren(e, t, n, p), m = 0 < r.children.filter(function (e) { return isMeaningfulJSXText(e) }).length, f = d.length - 2; 0 <= f; f--) { var D = "" === d[f] && "" === d[f + 1], g = d[f] === hardline$3 && "" === d[f + 1] && d[f + 2] === hardline$3, h = (d[f] === softline$1 || d[f] === hardline$3) && "" === d[f + 1] && d[f + 2] === p, y = d[f] === p && "" === d[f + 1] && (d[f + 2] === softline$1 || d[f + 2] === hardline$3), C = d[f] === p && "" === d[f + 1] && d[f + 2] === p; g && m || D || h || C ? d.splice(f, 2) : y && d.splice(f + 1, 2) } for (; d.length && (isLineNext$1(getLast$4(d)) || isEmpty$1(getLast$4(d)));)d.pop(); for (; d.length && (isLineNext$1(d[0]) || isEmpty$1(d[0])) && (isLineNext$1(d[1]) || isEmpty$1(d[1]));)d.shift(), d.shift(); var $ = []; d.forEach(function (e, t) { if (e === p) { if (1 === t && "" === d[t - 1]) return 2 === d.length ? void $.push(l) : void $.push(concat$4([l, hardline$3])); if (t === d.length - 1) return void $.push(l); if ("" === d[t - 1] && d[t - 2] === hardline$3) return void $.push(l) } $.push(e), willBreak$1(e) && (c = !0) }); var E = m ? fill$2($) : group$1(concat$4($), { shouldBreak: !0 }), A = group$1(concat$4([a, indent$2(concat$4([hardline$3, E])), hardline$3, u])); return c ? A : conditionalGroup$1([group$1(concat$4([a, concat$4(d), u])), A]) } function maybeWrapJSXElementInParens(e, t) { var n = e.getParentNode(); if (!n) return t; return { ArrayExpression: !0, JSXAttribute: !0, JSXElement: !0, JSXExpressionContainer: !0, JSXFragment: !0, TSJsxFragment: !0, ExpressionStatement: !0, CallExpression: !0, OptionalCallExpression: !0, ConditionalExpression: !0 }[n.type] ? t : group$1(concat$4([ifBreak$1("("), indent$2(concat$4([softline$1, t])), softline$1, ifBreak$1(")")])) } function isBinaryish(e) { return "BinaryExpression" === e.type || "LogicalExpression" === e.type } function isMemberish(e) { return "MemberExpression" === e.type || "OptionalMemberExpression" === e.type || "BindExpression" === e.type && e.object } function shouldInlineLogicalExpression(e) { return "LogicalExpression" === e.type && ("ObjectExpression" === e.right.type && 0 !== e.right.properties.length || ("ArrayExpression" === e.right.type && 0 !== e.right.elements.length || !!isJSXNode(e.right))) } function printBinaryishExpressions(e, t, n, r, a) { var u = [], o = e.getValue(); if (isBinaryish(o)) { shouldFlatten$1(o.operator, o.left.operator) ? u = u.concat(e.call(function (e) { return printBinaryishExpressions(e, t, n, !0, a) }, "left")) : u.push(e.call(t, "left")); var i = shouldInlineLogicalExpression(o), s = "|>" === o.operator, c = concat$4(i ? [o.operator, " ", e.call(t, "right")] : [s ? softline$1 : "", o.operator, s ? " " : line$3, e.call(t, "right")]), l = e.getParentNode(), p = !(a && "LogicalExpression" === o.type) && l.type !== o.type && o.left.type !== o.type && o.right.type !== o.type; u.push(" ", p ? group$1(c) : c), r && o.comments && (u = comments.printComments(e, function () { return concat$4(u) }, n)) } else u.push(e.call(t)); return u } function printAssignmentRight(e, t, n, r) { return hasLeadingOwnLineComment(r.originalText, t, r) ? indent$2(concat$4([hardline$3, n])) : isBinaryish(t) && !shouldInlineLogicalExpression(t) || "ConditionalExpression" === t.type && isBinaryish(t.test) && !shouldInlineLogicalExpression(t.test) || "StringLiteralTypeAnnotation" === t.type || ("Identifier" === e.type || isStringLiteral(e) || "MemberExpression" === e.type) && (isStringLiteral(t) || isMemberExpressionChain(t)) ? indent$2(concat$4([line$3, n])) : concat$4([" ", n]) } function printAssignment(e, t, n, r, a, u) { if (!r) return t; var o = printAssignmentRight(e, r, a, u); return group$1(concat$4([t, n, o])) } function adjustClause(e, t, n) { return "EmptyStatement" === e.type ? ";" : "BlockStatement" === e.type || n ? concat$4([" ", t]) : indent$2(concat$4([line$3, t])) } function nodeStr(e, t, n) { var r = rawText(e), a = n || "DirectiveLiteral" === e.type; return printString$1(r, t, a) } function printRegex(e) { var t = e.flags.split("").sort().join(""); return "/".concat(e.pattern, "/").concat(t) } function isLastStatement(e) { var t = e.getParentNode(); if (!t) return !0; var n = e.getValue(), r = (t.body || t.consequent).filter(function (e) { return "EmptyStatement" !== e.type }); return r && r[r.length - 1] === n } function hasLeadingComment(e) { return e.comments && e.comments.some(function (e) { return e.leading }) } function hasTrailingComment(e) { return e.comments && e.comments.some(function (e) { return e.trailing }) } function hasLeadingOwnLineComment(t, e, n) { return isJSXNode(e) ? hasNodeIgnoreComment$1(e) : e.comments && e.comments.some(function (e) { return e.leading && hasNewline$2(t, n.locEnd(e)) }) } function hasNakedLeftSide(e) { return "AssignmentExpression" === e.type || "BinaryExpression" === e.type || "LogicalExpression" === e.type || "ConditionalExpression" === e.type || "CallExpression" === e.type || "OptionalCallExpression" === e.type || "MemberExpression" === e.type || "OptionalMemberExpression" === e.type || "SequenceExpression" === e.type || "TaggedTemplateExpression" === e.type || "BindExpression" === e.type && !e.object || "UpdateExpression" === e.type && !e.prefix } function isFlowAnnotationComment(e, t, n) { var r = n.locStart(t), a = skipWhitespace$1(e, n.locEnd(t)); return "/*" === e.substr(r, 2) && "*/" === e.substr(a, 2) } function getLeftSide(e) { return e.expressions ? e.expressions[0] : e.left || e.test || e.callee || e.object || e.tag || e.argument || e.expression } function getLeftSidePathName(e, t) { if (t.expressions) return ["expressions", 0]; if (t.left) return ["left"]; if (t.test) return ["test"]; if (t.callee) return ["callee"]; if (t.object) return ["object"]; if (t.tag) return ["tag"]; if (t.argument) return ["argument"]; if (t.expression) return ["expression"]; throw new Error("Unexpected node has no left side", t) } function exprNeedsASIProtection(e, t) { var n = e.getValue(); return !!(needsParens_1(e, t) || "ParenthesizedExpression" === n.type || "TypeCastExpression" === n.type || "ArrowFunctionExpression" === n.type && !shouldPrintParamsWithoutParens(e, t) || "ArrayExpression" === n.type || "ArrayPattern" === n.type || "UnaryExpression" === n.type && n.prefix && ("+" === n.operator || "-" === n.operator) || "TemplateLiteral" === n.type || "TemplateElement" === n.type || isJSXNode(n) || "BindExpression" === n.type || "RegExpLiteral" === n.type || "Literal" === n.type && n.pattern || "Literal" === n.type && n.regex) || !!hasNakedLeftSide(n) && e.call.apply(e, [function (e) { return exprNeedsASIProtection(e, t) }].concat(getLeftSidePathName(e, n))) } function stmtNeedsASIProtection(e, t) { return "ExpressionStatement" === e.getNode().type && e.call(function (e) { return exprNeedsASIProtection(e, t) }, "expression") } function classPropMayCauseASIProblems(e) { var t = e.getNode(); if ("ClassProperty" !== t.type) return !1; var n = t.key && t.key.name; return !("static" !== n && "get" !== n && "set" !== n || t.value || t.typeAnnotation) || void 0 } function classChildNeedsASIProtection(e) { if (e) { if (!e.computed) { var t = e.key && e.key.name; if ("in" === t || "instanceof" === t) return !0 } switch (e.type) { case "ClassProperty": case "TSAbstractClassProperty": return e.computed; case "MethodDefinition": case "TSAbstractMethodDefinition": case "ClassMethod": var n = e.value ? e.value.async : e.async, r = e.value ? e.value.generator : e.generator; return !n && !e.static && "get" !== e.kind && "set" !== e.kind && !(!e.computed && !r); default: return !1 } } } function returnArgumentHasLeadingComment(e, t) { if (hasLeadingOwnLineComment(e.originalText, t, e)) return !0; if (hasNakedLeftSide(t)) for (var n, r = t; n = getLeftSide(r);)if (r = n, hasLeadingOwnLineComment(e.originalText, r, e)) return !0; return !1 } function isMemberExpressionChain(e) { return ("MemberExpression" === e.type || "OptionalMemberExpression" === e.type) && ("Identifier" === e.object.type || isMemberExpressionChain(e.object)) } function isObjectTypePropertyAFunction(e, t) { return "ObjectTypeProperty" === e.type && "FunctionTypeAnnotation" === e.value.type && !e.static && !isFunctionNotation(e, t) } function isFunctionNotation(e, t) { return isGetterOrSetter(e) || sameLocStart(e, e.value, t) } function isGetterOrSetter(e) { return "get" === e.kind || "set" === e.kind } function sameLocStart(e, t, n) { return n.locStart(e) === n.locStart(t) } function isTypeAnnotationAFunction(e, t) { return !("TypeAnnotation" !== e.type && "TSTypeAnnotation" !== e.type || "FunctionTypeAnnotation" !== e.typeAnnotation.type || e.static || sameLocStart(e, e.typeAnnotation, t)) } function isNodeStartingWithDeclare(e, t) { return ("flow" === t.parser || "typescript" === t.parser) && (t.originalText.slice(0, t.locStart(e)).match(/declare[ \t]*$/) || t.originalText.slice(e.range[0], e.range[1]).startsWith("declare ")) } function shouldHugType(e) { if (isObjectType(e)) return !0; if ("UnionTypeAnnotation" === e.type || "TSUnionType" === e.type) { var t = e.types.filter(function (e) { return "VoidTypeAnnotation" === e.type || "TSVoidKeyword" === e.type || "NullLiteralTypeAnnotation" === e.type || "TSNullKeyword" === e.type }).length, n = e.types.filter(function (e) { return "ObjectTypeAnnotation" === e.type || "TSTypeLiteral" === e.type || "GenericTypeAnnotation" === e.type || "TSTypeReference" === e.type }).length; if (e.types.length - 1 === t && 0 < n) return !0 } return !1 } function shouldHugArguments(e) { return e && e.params && 1 === e.params.length && !e.params[0].comments && ("ObjectPattern" === e.params[0].type || "ArrayPattern" === e.params[0].type || "Identifier" === e.params[0].type && e.params[0].typeAnnotation && ("TypeAnnotation" === e.params[0].typeAnnotation.type || "TSTypeAnnotation" === e.params[0].typeAnnotation.type) && isObjectType(e.params[0].typeAnnotation.typeAnnotation) || "FunctionTypeParam" === e.params[0].type && isObjectType(e.params[0].typeAnnotation) || "AssignmentPattern" === e.params[0].type && ("ObjectPattern" === e.params[0].left.type || "ArrayPattern" === e.params[0].left.type) && ("Identifier" === e.params[0].right.type || "ObjectExpression" === e.params[0].right.type && 0 === e.params[0].right.properties.length || "ArrayExpression" === e.params[0].right.type && 0 === e.params[0].right.elements.length)) && !e.rest } function templateLiteralHasNewLines(e) { return e.quasis.some(function (e) { return e.value.raw.includes("\n") }) } function isTemplateOnItsOwnLine(e, t, n) { return ("TemplateLiteral" === e.type && templateLiteralHasNewLines(e) || "TaggedTemplateExpression" === e.type && templateLiteralHasNewLines(e.quasi)) && !hasNewline$2(t, n.locStart(e), { backwards: !0 }) } function printArrayItems(e, t, n, r) { var a = [], u = []; return e.each(function (e) { a.push(concat$4(u)), a.push(group$1(r(e))), u = [",", line$3], e.getValue() && isNextLineEmpty$2(t.originalText, e.getValue(), t) && u.push(softline$1) }, n), concat$4(a) } function hasDanglingComments(e) { return e.comments && e.comments.some(function (e) { return !e.leading && !e.trailing }) } function needsHardlineAfterDanglingComment(e) { if (!e.comments) return !1; var t = getLast$4(e.comments.filter(function (e) { return !e.leading && !e.trailing })); return t && !comments$3.isBlockComment(t) } function isLiteral(e) { return "BooleanLiteral" === e.type || "DirectiveLiteral" === e.type || "Literal" === e.type || "NullLiteral" === e.type || "NumericLiteral" === e.type || "RegExpLiteral" === e.type || "StringLiteral" === e.type || "TemplateLiteral" === e.type || "TSTypeLiteral" === e.type || "JSXText" === e.type } function isNumericLiteral(e) { return "NumericLiteral" === e.type || "Literal" === e.type && "number" == typeof e.value } function isStringLiteral(e) { return "StringLiteral" === e.type || "Literal" === e.type && "string" == typeof e.value } function isObjectType(e) { return "ObjectTypeAnnotation" === e.type || "TSTypeLiteral" === e.type } var unitTestRe = /^(skip|[fx]?(it|describe|test))$/; function isTestCall(e, t) { if ("CallExpression" !== e.type) return !1; if (1 === e.arguments.length) { if (isAngularTestWrapper(e) && t && isTestCall(t)) return isFunctionOrArrowExpression(e.arguments[0].type); if (isUnitTestSetUp(e)) return isFunctionOrArrowExpression(e.arguments[0].type) || isAngularTestWrapper(e.arguments[0]) } else if (2 === e.arguments.length && ("Identifier" === e.callee.type && unitTestRe.test(e.callee.name) || isSkipOrOnlyBlock(e)) && (isTemplateLiteral(e.arguments[0]) || isStringLiteral(e.arguments[0]))) return isFunctionOrArrowExpression(e.arguments[1].type) && e.arguments[1].params.length <= 1 || isAngularTestWrapper(e.arguments[1]); return !1 } function isSkipOrOnlyBlock(e) { return ("MemberExpression" === e.callee.type || "OptionalMemberExpression" === e.callee.type) && "Identifier" === e.callee.object.type && "Identifier" === e.callee.property.type && unitTestRe.test(e.callee.object.name) && ("only" === e.callee.property.name || "skip" === e.callee.property.name) } function isTemplateLiteral(e) { return "TemplateLiteral" === e.type } function isAngularTestWrapper(e) { return !("CallExpression" !== e.type && "OptionalCallExpression" !== e.type || "Identifier" !== e.callee.type || "async" !== e.callee.name && "inject" !== e.callee.name) } function isFunctionOrArrowExpression(e) { return "FunctionExpression" === e || "ArrowFunctionExpression" === e } function isUnitTestSetUp(e) { return "Identifier" === e.callee.type && /^(before|after)(Each|All)$/.test(e.callee.name) && 1 === e.arguments.length } function isTheOnlyJSXElementInMarkdown(e, t) { if ("markdown" !== e.parentParser) return !1; var n = t.getNode(); if (!n.expression || !isJSXNode(n.expression)) return !1; var r = t.getParentNode(); return "Program" === r.type && 1 == r.body.length } function willPrintOwnComments(e) { var t = e.getValue(), n = e.getParentNode(); return (t && isJSXNode(t) || n && ("JSXSpreadAttribute" === n.type || "JSXSpreadChild" === n.type || "UnionTypeAnnotation" === n.type || "TSUnionType" === n.type || ("ClassDeclaration" === n.type || "ClassExpression" === n.type) && n.superClass === t)) && !hasIgnoreComment$1(e) } function canAttachComment(e) { return e.type && "CommentBlock" !== e.type && "CommentLine" !== e.type && "Line" !== e.type && "Block" !== e.type && "EmptyStatement" !== e.type && "TemplateElement" !== e.type && "Import" !== e.type && !(e.callee && "Import" === e.callee.type) } function printComment$1(e, t) { var n = e.getValue(); switch (n.type) { case "CommentBlock": case "Block": if (isJsDocComment(n)) { var r = printJsDocComment(n); return n.trailing && !hasNewline$2(t.originalText, t.locStart(n), { backwards: !0 }) ? concat$4([hardline$3, r]) : r } var a = "*-/" === t.originalText.substr(t.locEnd(n) - 3, 3); return "/*" + n.value + (a ? "*-/" : "*/"); case "CommentLine": case "Line": return t.originalText.slice(t.locStart(n)).startsWith("#!") ? "#!" + n.value.trimRight() : "//" + n.value.trimRight(); default: throw new Error("Not a comment: " + JSON.stringify(n)) } } function isJsDocComment(e) { var t = e.value.split("\n"); return 1 < t.length && t.slice(0, t.length - 1).every(function (e) { return "*" === e.trim()[0] }) } function printJsDocComment(e) { var n = e.value.split("\n"); return concat$4(["/*", join$2(hardline$3, n.map(function (e, t) { return (0 < t ? " " : "") + (t < n.length - 1 ? e.trim() : e.trimLeft()) })), "*/"]) } function rawText(e) { return e.extra ? e.extra.raw : e.raw } var printerEstree = { print: genericPrint$1, embed: embed_1, insertPragma: insertPragma, massageAstNode: clean_1, hasPrettierIgnore: hasPrettierIgnore, willPrintOwnComments: willPrintOwnComments, canAttachComment: canAttachComment, printComment: printComment$1, isBlockComment: comments$3.isBlockComment, handleComments: { ownLine: comments$3.handleOwnLineComment, endOfLine: comments$3.handleEndOfLineComment, remaining: comments$3.handleRemainingComment } }, _require$$0$builders$2 = doc.builders, concat$6 = _require$$0$builders$2.concat, hardline$5 = _require$$0$builders$2.hardline, indent$4 = _require$$0$builders$2.indent, join$4 = _require$$0$builders$2.join; function genericPrint$2(e, t, n) { var r = e.getValue(); switch (r.type) { case "ArrayExpression": return 0 === r.elements.length ? "[]" : concat$6(["[", indent$4(concat$6([hardline$5, join$4(concat$6([",", hardline$5]), e.map(n, "elements"))])), hardline$5, "]"]); case "ObjectExpression": return 0 === r.properties.length ? "{}" : concat$6(["{", indent$4(concat$6([hardline$5, join$4(concat$6([",", hardline$5]), e.map(n, "properties"))])), hardline$5, "}"]); case "ObjectProperty": return concat$6([e.call(n, "key"), ": ", e.call(n, "value")]); case "UnaryExpression": return concat$6(["+" === r.operator ? "" : r.operator, e.call(n, "argument")]); case "NullLiteral": return "null"; case "BooleanLiteral": return r.value ? "true" : "false"; case "StringLiteral": case "NumericLiteral": return JSON.stringify(r.value); case "Identifier": return JSON.stringify(r.name) } } function clean$2(e, t) { return delete t.start, delete t.end, delete t.extra, delete t.loc, delete t.comments, "Identifier" === e.type ? { type: "StringLiteral", value: e.name } : "UnaryExpression" === e.type && "+" === e.operator ? t.argument : void 0 } var printerEstreeJson = { print: genericPrint$2, massageAstNode: clean$2 }, CATEGORY_COMMON = "Common", commonOptions = { bracketSpacing: { since: "0.0.0", category: CATEGORY_COMMON, type: "boolean", default: !0, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." }, singleQuote: { since: "0.0.0", category: CATEGORY_COMMON, type: "boolean", default: !1, description: "Use single quotes instead of double quotes." } }, CATEGORY_JAVASCRIPT = "JavaScript", options$3 = { arrowParens: { since: "1.9.0", category: CATEGORY_JAVASCRIPT, type: "choice", default: "avoid", description: "Include parentheses around a sole arrow function parameter.", choices: [{ value: "avoid", description: "Omit parens when possible. Example: `x => x`" }, { value: "always", description: "Always include parens. Example: `(x) => x`" }] }, bracketSpacing: commonOptions.bracketSpacing, jsxBracketSameLine: { since: "0.17.0", category: CATEGORY_JAVASCRIPT, type: "boolean", default: !1, description: "Put > on the last line instead of at a new line." }, semi: { since: "1.0.0", category: CATEGORY_JAVASCRIPT, type: "boolean", default: !0, description: "Print semicolons.", oppositeDescription: "Do not print semicolons, except at the beginning of lines which may need them." }, singleQuote: commonOptions.singleQuote, trailingComma: { since: "0.0.0", category: CATEGORY_JAVASCRIPT, type: "choice", default: [{ since: "0.0.0", value: !1 }, { since: "0.19.0", value: "none" }], description: "Print trailing commas wherever possible when multi-line.", choices: [{ value: "none", description: "No trailing commas." }, { value: "es5", description: "Trailing commas where valid in ES5 (objects, arrays, etc.)" }, { value: "all", description: "Trailing commas wherever possible (including function arguments)." }, { value: !0, deprecated: "0.19.0", redirect: "es5" }, { value: !1, deprecated: "0.19.0", redirect: "none" }] } }, languages = [{ name: "JavaScript", since: "0.0.0", parsers: ["babylon", "flow"], group: "JavaScript", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", aliases: ["js", "node"], extensions: [".js", "._js", ".bones", ".es", ".es6", ".frag", ".gs", ".jake", ".jsb", ".jscad", ".jsfl", ".jsm", ".jss", ".mjs", ".njs", ".pac", ".sjs", ".ssjs", ".xsjs", ".xsjslib"], filenames: ["Jakefile"], linguistLanguageId: 183, vscodeLanguageIds: ["javascript"] }, { name: "JSX", since: "0.0.0", parsers: ["babylon", "flow"], group: "JavaScript", extensions: [".jsx"], tmScope: "source.js.jsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", liguistLanguageId: 178, vscodeLanguageIds: ["javascriptreact"] }, { name: "TypeScript", since: "1.4.0", parsers: ["typescript-eslint"], group: "JavaScript", aliases: ["ts"], extensions: [".ts", ".tsx"], tmScope: "source.ts", aceMode: "typescript", codemirrorMode: "javascript", codemirrorMimeType: "application/typescript", liguistLanguageId: 378, vscodeLanguageIds: ["typescript", "typescriptreact"] }, { name: "JSON.stringify", since: "1.13.0", parsers: ["json-stringify"], group: "JavaScript", tmScope: "source.json", aceMode: "json", codemirrorMode: "javascript", codemirrorMimeType: "application/json", extensions: [], filenames: ["package.json", "package-lock.json", "composer.json"], linguistLanguageId: 174, vscodeLanguageIds: ["json"] }, { name: "JSON", since: "1.5.0", parsers: ["json"], group: "JavaScript", tmScope: "source.json", aceMode: "json", codemirrorMode: "javascript", codemirrorMimeType: "application/json", extensions: [".json", ".geojson", ".JSON-tmLanguage", ".topojson"], filenames: [".arcconfig", ".jshintrc", ".eslintrc", ".prettierrc", "composer.lock", "mcmod.info"], linguistLanguageId: 174, vscodeLanguageIds: ["json", "jsonc"] }, { name: "JSON5", since: "1.13.0", parsers: ["json5"], group: "JavaScript", tmScope: "source.json", aceMode: "json", codemirrorMode: "javascript", codemirrorMimeType: "application/json", extensions: [".json5"], filenames: [".babelrc"], linguistLanguageId: 175, vscodeLanguageIds: ["json5"] }], printers = { estree: printerEstree, "estree-json": printerEstreeJson }, languageJs = { languages: languages, options: options$3, printers: printers }, index$5 = ["a", "abbr", "acronym", "address", "applet", "area", "article", "aside", "audio", "b", "base", "basefont", "bdi", "bdo", "bgsound", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "command", "content", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "embed", "fieldset", "figcaption", "figure", "font", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "image", "img", "input", "ins", "isindex", "kbd", "keygen", "label", "legend", "li", "link", "listing", "main", "map", "mark", "marquee", "math", "menu", "menuitem", "meta", "meter", "multicol", "nav", "nextid", "nobr", "noembed", "noframes", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "plaintext", "pre", "progress", "q", "rb", "rbc", "rp", "rt", "rtc", "ruby", "s", "samp", "script", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "svg", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "tt", "u", "ul", "var", "video", "wbr", "xmp"], htmlTagNames = Object.freeze({ default: index$5 }), htmlTagNames$1 = htmlTagNames && index$5 || htmlTagNames; function clean$3(e, t) { if (["raws", "sourceIndex", "source", "before", "after", "trailingComma"].forEach(function (e) { delete t[e] }), "media-query" !== e.type && "media-query-list" !== e.type && "media-feature-expression" !== e.type || delete t.value, "css-rule" === e.type && delete t.params, "selector-combinator" === e.type && (t.value = t.value.replace(/\s+/g, " ")), "media-feature" === e.type && (t.value = t.value.replace(/ /g, "")), ("value-word" === e.type && (e.isColor && e.isHex || -1 !== ["initial", "inherit", "unset", "revert"].indexOf(t.value.replace().toLowerCase())) || "media-feature" === e.type || "selector-root-invalid" === e.type || "selector-pseudo" === e.type) && (t.value = t.value.toLowerCase()), "css-decl" === e.type && (t.prop = t.prop.toLowerCase()), "css-atrule" !== e.type && "css-import" !== e.type || (t.name = t.name.toLowerCase()), "value-number" === e.type && (t.unit = t.unit.toLowerCase()), "media-feature" !== e.type && "media-keyword" !== e.type && "media-type" !== e.type && "media-unknown" !== e.type && "media-url" !== e.type && "media-value" !== e.type && "selector-attribute" !== e.type && "selector-string" !== e.type && "selector-class" !== e.type && "selector-combinator" !== e.type && "value-string" !== e.type || !t.value || (t.value = cleanCSSStrings(t.value)), "selector-attribute" === e.type && (t.attribute = t.attribute.trim(), t.namespace && "string" == typeof t.namespace && (t.namespace = t.namespace.trim(), 0 === t.namespace.length && (t.namespace = !0)), t.value && (t.value = t.value.trim().replace(/^['"]|['"]$/g, ""), delete t.quoted)), "media-value" !== e.type && "media-type" !== e.type && "value-number" !== e.type && "selector-root-invalid" !== e.type && "selector-class" !== e.type && "selector-combinator" !== e.type && "selector-tag" !== e.type || !t.value || (t.value = t.value.replace(/([\d.eE+-]+)([a-zA-Z]*)/g, function (e, t, n) { var r = Number(t); return isNaN(r) ? e : r + n.toLowerCase() })), "selector-tag" === e.type) { var n = e.value.toLowerCase(); -1 !== htmlTagNames$1.indexOf(n) && (t.value = n), -1 !== ["from", "to"].indexOf(n) && (t.value = n) } "css-atrule" === e.type && "supports" === e.name.toLowerCase() && delete t.value, "selector-unknown" === e.type && delete t.value } function cleanCSSStrings(e) { return e.replace(/'/g, '"').replace(/\\([^a-fA-F\d])/g, "$1") } var clean_1$2 = clean$3; function getAncestorCounter(e, t) { for (var n, r = [].concat(t), a = -1; n = e.getParentNode(++a);)if (-1 !== r.indexOf(n.type)) return a; return -1 } function getAncestorNode$1(e, t) { var n = getAncestorCounter(e, t); return -1 === n ? null : e.getParentNode(n) } function getPropOfDeclNode$1(e) { var t = getAncestorNode$1(e, "css-decl"); return t && t.prop && t.prop.toLowerCase() } function isSCSS$1(e, t) { return "less" === e || "scss" === e ? "scss" === e : /(\w\s*: [^}:]+|#){|@import[^\n]+(url|,)/.test(t) } function isWideKeywords$1(e) { return -1 !== ["initial", "inherit", "unset", "revert"].indexOf(e.toLowerCase()) } function isKeyframeAtRuleKeywords$1(e, t) { var n = getAncestorNode$1(e, "css-atrule"); return n && n.name && n.name.toLowerCase().endsWith("keyframes") && -1 !== ["from", "to"].indexOf(t.toLowerCase()) } function maybeToLowerCase$1(e) { return e.includes("$") || e.includes("@") || e.includes("#") || e.startsWith("%") || e.startsWith("--") || e.startsWith(":--") || e.includes("(") && e.includes(")") ? e : e.toLowerCase() } function insideValueFunctionNode$1(e, t) { var n = getAncestorNode$1(e, "value-func"); return n && n.value && n.value.toLowerCase() === t } function insideICSSRuleNode$1(e) { var t = getAncestorNode$1(e, "css-rule"); return t && t.raws && t.raws.selector && (t.raws.selector.startsWith(":import") || t.raws.selector.startsWith(":export")) } function insideAtRuleNode$1(e, t) { var n = [].concat(t), r = getAncestorNode$1(e, "css-atrule"); return r && -1 !== n.indexOf(r.name.toLowerCase()) } function insideURLFunctionInImportAtRuleNode$1(e) { var t = e.getValue(), n = getAncestorNode$1(e, "css-atrule"); return n && "import" === n.name && "url" === t.groups[0].value && 2 === t.groups.length } function isURLFunctionNode$1(e) { return "value-func" === e.type && "url" === e.value.toLowerCase() } function isLastNode$1(e, t) { var n = e.getParentNode(); if (!n) return !1; var r = n.nodes; return r && r.indexOf(t) === r.length - 1 } function isHTMLTag$1(e) { return -1 !== htmlTagNames$1.indexOf(e.toLowerCase()) } function isDetachedRulesetDeclarationNode$1(e) { return !!e.selector && ("string" == typeof e.selector && /^@.+:.*$/.test(e.selector) || e.selector.value && /^@.+:.*$/.test(e.selector.value)) } function isForKeywordNode$1(e) { return "value-word" === e.type && -1 !== ["from", "through", "end"].indexOf(e.value) } function isIfElseKeywordNode$1(e) { return "value-word" === e.type && -1 !== ["and", "or", "not"].indexOf(e.value) } function isEachKeywordNode$1(e) { return "value-word" === e.type && "in" === e.value } function isMultiplicationNode$1(e) { return "value-operator" === e.type && "*" === e.value } function isDivisionNode$1(e) { return "value-operator" === e.type && "/" === e.value } function isAdditionNode$1(e) { return "value-operator" === e.type && "+" === e.value } function isSubtractionNode$1(e) { return "value-operator" === e.type && "-" === e.value } function isModuloNode(e) { return "value-operator" === e.type && "%" === e.value } function isMathOperatorNode$1(e) { return isMultiplicationNode$1(e) || isDivisionNode$1(e) || isAdditionNode$1(e) || isSubtractionNode$1(e) || isModuloNode(e) } function isEqualityOperatorNode$1(e) { return "value-word" === e.type && -1 !== ["==", "!="].indexOf(e.value) } function isRelationalOperatorNode$1(e) { return "value-word" === e.type && -1 !== ["<", ">", "<=", ">="].indexOf(e.value) } function isSCSSControlDirectiveNode$1(e) { return "css-atrule" === e.type && -1 !== ["if", "else", "for", "each", "while"].indexOf(e.name) } function isSCSSNestedPropertyNode(e) { return !!e.selector && e.selector.replace(/\/\*.*?\*\//, "").replace(/\/\/.*?\n/, "").trim().endsWith(":") } function isDetachedRulesetCallNode$1(e) { return e.raws && e.raws.params && /^\(\s*\)$/.test(e.raws.params) } function isPostcssSimpleVarNode$1(e, t) { return "$$" === e.value && "value-func" === e.type && t && "value-word" === t.type && !t.raws.before } function hasComposesNode$1(e) { return e.value && "value-root" === e.value.type && e.value.group && "value-value" === e.value.group.type && "composes" === e.prop.toLowerCase() } function hasParensAroundNode$1(e) { return e.value && e.value.group && e.value.group.group && "value-paren_group" === e.value.group.group.type && null !== e.value.group.group.open && null !== e.value.group.group.close } function hasEmptyRawBefore$1(e) { return e.raws && "" === e.raws.before } function isKeyValuePairNode$1(e) { return "value-comma_group" === e.type && e.groups && e.groups[1] && "value-colon" === e.groups[1].type } function isKeyValuePairInParenGroupNode(e) { return "value-paren_group" === e.type && e.groups && e.groups[0] && isKeyValuePairNode$1(e.groups[0]) } function isSCSSMapItemNode$1(e) { var t = e.getValue(); if (0 === t.groups.length) return !1; var n = e.getParentNode(1); if (!(isKeyValuePairInParenGroupNode(t) || n && isKeyValuePairInParenGroupNode(n))) return !1; var r = getAncestorNode$1(e, "css-decl"); return !!(r && r.prop && r.prop.startsWith("$")) || (!!isKeyValuePairInParenGroupNode(n) || "value-func" === n.type) } function isInlineValueCommentNode$1(e) { return "value-comment" === e.type && e.inline } function isHashNode$1(e) { return "value-word" === e.type && "#" === e.value } function isLeftCurlyBraceNode$1(e) { return "value-word" === e.type && "{" === e.value } function isRightCurlyBraceNode$1(e) { return "value-word" === e.type && "}" === e.value } function isWordNode$1(e) { return -1 !== ["value-word", "value-atword"].indexOf(e.type) } function isColonNode$1(e) { return "value-colon" === e.type } function isMediaAndSupportsKeywords$1(e) { return e.value && -1 !== ["not", "and", "or"].indexOf(e.value.toLowerCase()) } var utils$4 = { getAncestorCounter: getAncestorCounter, getAncestorNode: getAncestorNode$1, getPropOfDeclNode: getPropOfDeclNode$1, maybeToLowerCase: maybeToLowerCase$1, insideValueFunctionNode: insideValueFunctionNode$1, insideICSSRuleNode: insideICSSRuleNode$1, insideAtRuleNode: insideAtRuleNode$1, insideURLFunctionInImportAtRuleNode: insideURLFunctionInImportAtRuleNode$1, isKeyframeAtRuleKeywords: isKeyframeAtRuleKeywords$1, isHTMLTag: isHTMLTag$1, isWideKeywords: isWideKeywords$1, isSCSS: isSCSS$1, isLastNode: isLastNode$1, isSCSSControlDirectiveNode: isSCSSControlDirectiveNode$1, isDetachedRulesetDeclarationNode: isDetachedRulesetDeclarationNode$1, isRelationalOperatorNode: isRelationalOperatorNode$1, isEqualityOperatorNode: isEqualityOperatorNode$1, isMultiplicationNode: isMultiplicationNode$1, isDivisionNode: isDivisionNode$1, isAdditionNode: isAdditionNode$1, isSubtractionNode: isSubtractionNode$1, isModuloNode: isModuloNode, isMathOperatorNode: isMathOperatorNode$1, isEachKeywordNode: isEachKeywordNode$1, isForKeywordNode: isForKeywordNode$1, isURLFunctionNode: isURLFunctionNode$1, isIfElseKeywordNode: isIfElseKeywordNode$1, hasComposesNode: hasComposesNode$1, hasParensAroundNode: hasParensAroundNode$1, hasEmptyRawBefore: hasEmptyRawBefore$1, isSCSSNestedPropertyNode: isSCSSNestedPropertyNode, isDetachedRulesetCallNode: isDetachedRulesetCallNode$1, isPostcssSimpleVarNode: isPostcssSimpleVarNode$1, isKeyValuePairNode: isKeyValuePairNode$1, isKeyValuePairInParenGroupNode: isKeyValuePairInParenGroupNode, isSCSSMapItemNode: isSCSSMapItemNode$1, isInlineValueCommentNode: isInlineValueCommentNode$1, isHashNode: isHashNode$1, isLeftCurlyBraceNode: isLeftCurlyBraceNode$1, isRightCurlyBraceNode: isRightCurlyBraceNode$1, isWordNode: isWordNode$1, isColonNode: isColonNode$1, isMediaAndSupportsKeywords: isMediaAndSupportsKeywords$1 }, printNumber$2 = util.printNumber, printString$2 = util.printString, hasIgnoreComment$2 = util.hasIgnoreComment, hasNewline$3 = util.hasNewline, isNextLineEmpty$3 = utilShared.isNextLineEmpty, _require$$2$builders = doc.builders, concat$7 = _require$$2$builders.concat, join$5 = _require$$2$builders.join, line$4 = _require$$2$builders.line, hardline$6 = _require$$2$builders.hardline, softline$3 = _require$$2$builders.softline, group$2 = _require$$2$builders.group, fill$3 = _require$$2$builders.fill, indent$5 = _require$$2$builders.indent, dedent$3 = _require$$2$builders.dedent, ifBreak$2 = _require$$2$builders.ifBreak, removeLines$2 = doc.utils.removeLines, getAncestorNode = utils$4.getAncestorNode, getPropOfDeclNode = utils$4.getPropOfDeclNode, maybeToLowerCase = utils$4.maybeToLowerCase, insideValueFunctionNode = utils$4.insideValueFunctionNode, insideICSSRuleNode = utils$4.insideICSSRuleNode, insideAtRuleNode = utils$4.insideAtRuleNode, insideURLFunctionInImportAtRuleNode = utils$4.insideURLFunctionInImportAtRuleNode, isKeyframeAtRuleKeywords = utils$4.isKeyframeAtRuleKeywords, isHTMLTag = utils$4.isHTMLTag, isWideKeywords = utils$4.isWideKeywords, isSCSS = utils$4.isSCSS, isLastNode = utils$4.isLastNode, isSCSSControlDirectiveNode = utils$4.isSCSSControlDirectiveNode, isDetachedRulesetDeclarationNode = utils$4.isDetachedRulesetDeclarationNode, isRelationalOperatorNode = utils$4.isRelationalOperatorNode, isEqualityOperatorNode = utils$4.isEqualityOperatorNode, isMultiplicationNode = utils$4.isMultiplicationNode, isDivisionNode = utils$4.isDivisionNode, isAdditionNode = utils$4.isAdditionNode, isSubtractionNode = utils$4.isSubtractionNode, isMathOperatorNode = utils$4.isMathOperatorNode, isEachKeywordNode = utils$4.isEachKeywordNode, isForKeywordNode = utils$4.isForKeywordNode, isURLFunctionNode = utils$4.isURLFunctionNode, isIfElseKeywordNode = utils$4.isIfElseKeywordNode, hasComposesNode = utils$4.hasComposesNode, hasParensAroundNode = utils$4.hasParensAroundNode, hasEmptyRawBefore = utils$4.hasEmptyRawBefore, isKeyValuePairNode = utils$4.isKeyValuePairNode, isDetachedRulesetCallNode = utils$4.isDetachedRulesetCallNode, isPostcssSimpleVarNode = utils$4.isPostcssSimpleVarNode, isSCSSMapItemNode = utils$4.isSCSSMapItemNode, isInlineValueCommentNode = utils$4.isInlineValueCommentNode, isHashNode = utils$4.isHashNode, isLeftCurlyBraceNode = utils$4.isLeftCurlyBraceNode, isRightCurlyBraceNode = utils$4.isRightCurlyBraceNode, isWordNode = utils$4.isWordNode, isColonNode = utils$4.isColonNode, isMediaAndSupportsKeywords = utils$4.isMediaAndSupportsKeywords; function shouldPrintComma$1(e) { switch (e.trailingComma) { case "all": case "es5": return !0; case "none": default: return !1 } } function genericPrint$3(e, t, r) { var n = e.getValue(); if (!n) return ""; if ("string" == typeof n) return n; switch (n.type) { case "front-matter": return concat$7([n.value, hardline$6]); case "css-root": var a = printNodeSequence(e, t, r); return a.parts.length ? concat$7([a, hardline$6]) : a; case "css-comment": if (n.raws.content) return n.raws.content; var u = t.originalText.slice(t.locStart(n), t.locEnd(n)), o = n.raws.text || n.text; return -1 === u.indexOf(o) ? n.raws.inline ? concat$7(["// ", o]) : concat$7(["/* ", o, " */"]) : u; case "css-rule": return concat$7([e.call(r, "selector"), n.important ? " !important" : "", n.nodes ? concat$7([" {", 0 < n.nodes.length ? indent$5(concat$7([hardline$6, printNodeSequence(e, t, r)])) : "", hardline$6, "}", isDetachedRulesetDeclarationNode(n) ? ";" : ""]) : ";"]); case "css-decl": return concat$7([n.raws.before.replace(/[\s;]/g, ""), insideICSSRuleNode(e) ? n.prop : maybeToLowerCase(n.prop), ":" === n.raws.between.trim() ? ":" : n.raws.between.trim(), n.extend ? "" : " ", hasComposesNode(n) ? removeLines$2(e.call(r, "value")) : e.call(r, "value"), n.raws.important ? n.raws.important.replace(/\s*!\s*important/i, " !important") : n.important ? " !important" : "", n.raws.scssDefault ? n.raws.scssDefault.replace(/\s*!default/i, " !default") : n.scssDefault ? " !default" : "", n.raws.scssGlobal ? n.raws.scssGlobal.replace(/\s*!global/i, " !global") : n.scssGlobal ? " !global" : "", n.nodes ? concat$7([" {", indent$5(concat$7([softline$3, printNodeSequence(e, t, r)])), softline$3, "}"]) : ";"]); case "css-atrule": return concat$7(["@", isDetachedRulesetCallNode(n) || n.name.endsWith(":") ? n.name : maybeToLowerCase(n.name), n.params ? concat$7([isDetachedRulesetCallNode(n) ? "" : " ", e.call(r, "params")]) : "", n.selector ? indent$5(concat$7([" ", e.call(r, "selector")])) : "", n.value ? group$2(concat$7([" ", e.call(r, "value"), isSCSSControlDirectiveNode(n) ? hasParensAroundNode(n) ? " " : line$4 : ""])) : "else" === n.name ? " " : "", n.nodes ? concat$7([isSCSSControlDirectiveNode(n) ? "" : " ", "{", indent$5(concat$7([0 < n.nodes.length ? softline$3 : "", printNodeSequence(e, t, r)])), softline$3, "}"]) : ";"]); case "media-query-list": var i = []; return e.each(function (e) { var t = e.getValue(); "media-query" === t.type && "" === t.value || i.push(e.call(r)) }, "nodes"), group$2(indent$5(join$5(line$4, i))); case "media-query": return concat$7([join$5(" ", e.map(r, "nodes")), isLastNode(e, n) ? "" : ","]); case "media-type": return adjustNumbers(adjustStrings(n.value, t)); case "media-feature-expression": return n.nodes ? concat$7(["(", concat$7(e.map(r, "nodes")), ")"]) : n.value; case "media-feature": return maybeToLowerCase(adjustStrings(n.value.replace(/ +/g, " "), t)); case "media-colon": return concat$7([n.value, " "]); case "media-value": return adjustNumbers(adjustStrings(n.value, t)); case "media-keyword": return adjustStrings(n.value, t); case "media-url": return adjustStrings(n.value.replace(/^url\(\s+/gi, "url(").replace(/\s+\)$/gi, ")"), t); case "media-unknown": return n.value; case "selector-root": return group$2(concat$7([insideAtRuleNode(e, "custom-selector") ? concat$7([getAncestorNode(e, "css-atrule").customSelector, line$4]) : "", join$5(concat$7([",", insideAtRuleNode(e, ["extend", "custom-selector", "nest"]) ? line$4 : hardline$6]), e.map(r, "nodes"))])); case "selector-selector": return group$2(indent$5(concat$7(e.map(r, "nodes")))); case "selector-comment": return n.value; case "selector-string": return adjustStrings(n.value, t); case "selector-tag": var s = e.getParentNode(), c = s && s.nodes.indexOf(n), l = c && s.nodes[c - 1]; return concat$7([n.namespace ? concat$7([!0 === n.namespace ? "" : n.namespace.trim(), "|"]) : "", "selector-nesting" === l.type ? n.value : adjustNumbers(isHTMLTag(n.value) || isKeyframeAtRuleKeywords(e, n.value) ? n.value.toLowerCase() : n.value)]); case "selector-id": return concat$7(["#", n.value]); case "selector-class": return concat$7([".", adjustNumbers(adjustStrings(n.value, t))]); case "selector-attribute": return concat$7(["[", n.namespace ? concat$7([!0 === n.namespace ? "" : n.namespace.trim(), "|"]) : "", n.attribute.trim(), n.operator ? n.operator : "", n.value ? quoteAttributeValue(adjustStrings(n.value.trim(), t), t) : "", n.insensitive ? " i" : "", "]"]); case "selector-combinator": if ("+" === n.value || ">" === n.value || "~" === n.value || ">>>" === n.value) { var p = e.getParentNode(), d = "selector-selector" === p.type && p.nodes[0] === n ? "" : line$4; return concat$7([d, n.value, isLastNode(e, n) ? "" : " "]) } var m = n.value.trim().startsWith("(") ? line$4 : "", f = adjustNumbers(adjustStrings(n.value.trim(), t)) || line$4; return concat$7([m, f]); case "selector-universal": return concat$7([n.namespace ? concat$7([!0 === n.namespace ? "" : n.namespace.trim(), "|"]) : "", adjustNumbers(n.value)]); case "selector-pseudo": return concat$7([maybeToLowerCase(n.value), n.nodes && 0 < n.nodes.length ? concat$7(["(", join$5(", ", e.map(r, "nodes")), ")"]) : ""]); case "selector-nesting": return n.value; case "selector-unknown": var D = getAncestorNode(e, "css-rule"); return D && D.isSCSSNesterProperty ? adjustNumbers(adjustStrings(maybeToLowerCase(n.value), t)) : n.value; case "value-value": case "value-root": return e.call(r, "group"); case "value-comment": return concat$7([n.inline ? "//" : "/*", n.value, n.inline ? "" : "*/"]); case "value-comma_group": for (var g = e.getParentNode(), h = getPropOfDeclNode(e), y = h && "value-value" === g.type && ("grid" === h || h.startsWith("grid-template")), C = getAncestorNode(e, "css-atrule"), $ = C && isSCSSControlDirectiveNode(C), E = e.map(r, "groups"), A = [], v = insideValueFunctionNode(e, "url"), F = !1, b = !1, x = 0; x < n.groups.length; ++x)if (A.push(E[x]), !v) { var S = n.groups[x - 1], B = n.groups[x], T = n.groups[x + 1], N = n.groups[x + 2]; if (T) { var w = "value-string" === B.type && B.value.startsWith("#{"), P = F && "value-string" === T.type && T.value.endsWith("}"); if (w || P) F = !F; else if (!(F || isColonNode(B) || isColonNode(T) || "value-atword" === B.type && "" === B.value || "~" === B.value || "\\" === B.value || isPostcssSimpleVarNode(B, T) || isHashNode(B) || isLeftCurlyBraceNode(B) || isRightCurlyBraceNode(T) || isLeftCurlyBraceNode(T) && hasEmptyRawBefore(T) || isRightCurlyBraceNode(B) && hasEmptyRawBefore(T) || "--" === B.value && isHashNode(T))) { var k = isMathOperatorNode(B), O = isMathOperatorNode(T); if (!((k && isHashNode(T) || O && isRightCurlyBraceNode(B)) && hasEmptyRawBefore(T) || insideValueFunctionNode(e, "calc") && (isAdditionNode(B) || isAdditionNode(T) || isSubtractionNode(B) || isSubtractionNode(T)) && hasEmptyRawBefore(T))) { var j = N && "value-func" === N.type || N && isWordNode(N) || "value-func" === B.type || isWordNode(B), L = "value-func" === T.type || isWordNode(T) || S && "value-func" === S.type || S && isWordNode(S); if (isMultiplicationNode(T) || isMultiplicationNode(B) || insideValueFunctionNode(e, "calc") || !(isDivisionNode(T) && !j || isDivisionNode(B) && !L || isAdditionNode(T) && !j || isAdditionNode(B) && !L || isSubtractionNode(T) || isSubtractionNode(B)) || !(hasEmptyRawBefore(T) || k && (!S || S && isMathOperatorNode(S)))) { var _ = isInlineValueCommentNode(B); S && isInlineValueCommentNode(S) || _ || isInlineValueCommentNode(T) ? _ && A.push(hardline$6) : $ && (isEqualityOperatorNode(T) || isRelationalOperatorNode(T) || isIfElseKeywordNode(T) || isEachKeywordNode(B) || isForKeywordNode(B)) ? A.push(" ") : C && "namespace" === C.name.toLowerCase() ? A.push(" ") : y ? B.source.start.line !== T.source.start.line ? (A.push(hardline$6), b = !0) : A.push(" ") : O ? A.push(" ") : A.push(line$4) } } } } } return b && A.unshift(hardline$6), $ ? group$2(indent$5(concat$7(A))) : insideURLFunctionInImportAtRuleNode(e) ? group$2(fill$3(A)) : group$2(indent$5(fill$3(A))); case "value-paren_group": var M = e.getParentNode(); if (M && isURLFunctionNode(M) && (1 === n.groups.length || 0 < n.groups.length && "value-comma_group" === n.groups[0].type && 0 < n.groups[0].groups.length && "value-word" === n.groups[0].groups[0].type && n.groups[0].groups[0].value.startsWith("data:"))) return concat$7([n.open ? e.call(r, "open") : "", join$5(",", e.map(r, "groups")), n.close ? e.call(r, "close") : ""]); if (!n.open) { for (var I = e.map(r, "groups"), R = [], q = 0; q < I.length; q++)0 !== q && R.push(concat$7([",", line$4])), R.push(I[q]); return group$2(indent$5(fill$3(R))) } var V = isSCSSMapItemNode(e); return group$2(concat$7([n.open ? e.call(r, "open") : "", indent$5(concat$7([softline$3, join$5(concat$7([",", line$4]), e.map(function (e) { var t = e.getValue(), n = r(e); return isKeyValuePairNode(t) && "value-comma_group" === t.type && t.groups && t.groups[2] && "value-paren_group" === t.groups[2].type ? (n.contents.contents.parts[1] = group$2(n.contents.contents.parts[1]), group$2(dedent$3(n))) : n }, "groups"))])), ifBreak$2(isSCSS(t.parser, t.originalText) && V && shouldPrintComma$1(t) ? "," : ""), softline$3, n.close ? e.call(r, "close") : ""]), { shouldBreak: V }); case "value-func": return concat$7([n.value, insideAtRuleNode(e, "supports") && isMediaAndSupportsKeywords(n) ? " " : "", e.call(r, "group")]); case "value-paren": return n.value; case "value-number": return concat$7([printCssNumber(n.value), maybeToLowerCase(n.unit)]); case "value-operator": return n.value; case "value-word": return n.isColor && n.isHex || isWideKeywords(n.value) ? n.value.toLowerCase() : n.value; case "value-colon": return concat$7([n.value, insideValueFunctionNode(e, "url") ? "" : line$4]); case "value-comma": return concat$7([n.value, " "]); case "value-string": return printString$2(n.raws.quote + n.value + n.raws.quote, t); case "value-atword": return concat$7(["@", n.value]); case "value-unicode-range": case "value-unknown": return n.value; default: throw new Error("Unknown postcss type ".concat(JSON.stringify(n.type))) } } function printNodeSequence(e, r, a) { var u = e.getValue(), o = [], i = 0; return e.map(function (e) { var t = u.nodes[i - 1]; if (t && "css-comment" === t.type && "prettier-ignore" === t.text.trim()) { var n = e.getValue(); o.push(r.originalText.slice(r.locStart(n), r.locEnd(n))) } else o.push(e.call(a)); i !== u.nodes.length - 1 && ("css-comment" === u.nodes[i + 1].type && !hasNewline$3(r.originalText, r.locStart(u.nodes[i + 1]), { backwards: !0 }) || "css-atrule" === u.nodes[i + 1].type && "else" === u.nodes[i + 1].name && "css-comment" !== u.nodes[i].type ? o.push(" ") : (o.push(hardline$6), isNextLineEmpty$3(r.originalText, e.getValue(), r) && o.push(hardline$6))), i++ }, "nodes"), concat$7(o) } var STRING_REGEX = /(['"])(?:(?!\1)[^\\]|\\[\s\S])*\1/g, NUMBER_REGEX = /(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g, STANDARD_UNIT_REGEX = /[a-zA-Z]+/g, WORD_PART_REGEX = /[$@]?[a-zA-Z_\u0080-\uFFFF][\w\-\u0080-\uFFFF]*/g, ADJUST_NUMBERS_REGEX = RegExp(STRING_REGEX.source + "|" + "(".concat(WORD_PART_REGEX.source, ")?") + "(".concat(NUMBER_REGEX.source, ")") + "(".concat(STANDARD_UNIT_REGEX.source, ")?"), "g"); function adjustStrings(e, t) { return e.replace(STRING_REGEX, function (e) { return printString$2(e, t) }) } function quoteAttributeValue(e, t) { var n = t.singleQuote ? "'" : '"'; return e.includes('"') || e.includes("'") ? e : n + e + n } function adjustNumbers(e) { return e.replace(ADJUST_NUMBERS_REGEX, function (e, t, n, r, a) { return !n && r ? (n || "") + printCssNumber(r) + maybeToLowerCase(a || "") : e }) } function printCssNumber(e) { return printNumber$2(e).replace(/\.0(?=$|e)/, "") } var printerPostcss = { print: genericPrint$3, hasPrettierIgnore: hasIgnoreComment$2, massageAstNode: clean_1$2 }, options$6 = { singleQuote: commonOptions.singleQuote }, languages$1 = [{ name: "CSS", since: "1.4.0", parsers: ["css"], group: "CSS", tmScope: "source.css", aceMode: "css", codemirrorMode: "css", codemirrorMimeType: "text/css", extensions: [".css", ".pcss", ".postcss"], liguistLanguageId: 50, vscodeLanguageIds: ["css", "postcss"] }, { name: "Less", since: "1.4.0", parsers: ["less"], group: "CSS", extensions: [".less"], tmScope: "source.css.less", aceMode: "less", codemirrorMode: "css", codemirrorMimeType: "text/css", liguistLanguageId: 198, vscodeLanguageIds: ["less"] }, { name: "SCSS", since: "1.4.0", parsers: ["scss"], group: "CSS", tmScope: "source.scss", aceMode: "scss", codemirrorMode: "css", codemirrorMimeType: "text/x-scss", extensions: [".scss"], liguistLanguageId: 329, vscodeLanguageIds: ["scss"] }], printers$1 = { postcss: printerPostcss }, languageCss = { languages: languages$1, options: options$6, printers: printers$1 }, _require$$0$builders$3 = doc.builders, concat$8 = _require$$0$builders$3.concat, join$6 = _require$$0$builders$3.join, hardline$7 = _require$$0$builders$3.hardline, line$5 = _require$$0$builders$3.line, softline$4 = _require$$0$builders$3.softline, group$3 = _require$$0$builders$3.group, indent$6 = _require$$0$builders$3.indent, ifBreak$3 = _require$$0$builders$3.ifBreak, hasIgnoreComment$3 = util.hasIgnoreComment, isNextLineEmpty$4 = utilShared.isNextLineEmpty; function genericPrint$4(e, n, r) { var a = e.getValue(); if (!a) return ""; if ("string" == typeof a) return a; switch (a.kind) { case "Document": var u = []; return e.map(function (e, t) { u.push(concat$8([e.call(r)])), u.push(hardline$7), t !== a.definitions.length - 1 && isNextLineEmpty$4(n.originalText, e.getValue(), n) && u.push(hardline$7) }, "definitions"), concat$8(u, hardline$7); case "OperationDefinition": var t = "{" !== n.originalText[n.locStart(a)], o = !!a.name; return concat$8([t ? a.operation : "", t && o ? concat$8([" ", e.call(r, "name")]) : "", a.variableDefinitions && a.variableDefinitions.length ? group$3(concat$8(["(", indent$6(concat$8([softline$4, join$6(concat$8([ifBreak$3("", ", "), softline$4]), e.map(r, "variableDefinitions"))])), softline$4, ")"])) : "", printDirectives(e, r, a), a.selectionSet && (t || o) ? " " : "", e.call(r, "selectionSet")]); case "FragmentDefinition": return concat$8(["fragment ", e.call(r, "name"), " on ", e.call(r, "typeCondition"), printDirectives(e, r, a), " ", e.call(r, "selectionSet")]); case "SelectionSet": return concat$8(["{", indent$6(concat$8([hardline$7, join$6(hardline$7, e.call(function (e) { return printSequence(e, n, r) }, "selections"))])), hardline$7, "}"]); case "Field": return group$3(concat$8([a.alias ? concat$8([e.call(r, "alias"), ": "]) : "", e.call(r, "name"), 0 < a.arguments.length ? group$3(concat$8(["(", indent$6(concat$8([softline$4, join$6(concat$8([ifBreak$3("", ", "), softline$4]), e.call(function (e) { return printSequence(e, n, r) }, "arguments"))])), softline$4, ")"])) : "", printDirectives(e, r, a), a.selectionSet ? " " : "", e.call(r, "selectionSet")])); case "Name": return a.value; case "StringValue": return a.block ? concat$8(['"""', hardline$7, join$6(hardline$7, a.value.replace(/"""/g, "\\$&").split("\n")), hardline$7, '"""']) : concat$8(['"', a.value.replace(/["\\]/g, "\\$&"), '"']); case "IntValue": case "FloatValue": case "EnumValue": return a.value; case "BooleanValue": return a.value ? "true" : "false"; case "NullValue": return "null"; case "Variable": return concat$8(["$", e.call(r, "name")]); case "ListValue": return group$3(concat$8(["[", indent$6(concat$8([softline$4, join$6(concat$8([ifBreak$3("", ", "), softline$4]), e.map(r, "values"))])), softline$4, "]"])); case "ObjectValue": return group$3(concat$8(["{", n.bracketSpacing && 0 < a.fields.length ? " " : "", indent$6(concat$8([softline$4, join$6(concat$8([ifBreak$3("", ", "), softline$4]), e.map(r, "fields"))])), softline$4, ifBreak$3("", n.bracketSpacing && 0 < a.fields.length ? " " : ""), "}"])); case "ObjectField": case "Argument": return concat$8([e.call(r, "name"), ": ", e.call(r, "value")]); case "Directive": return concat$8(["@", e.call(r, "name"), 0 < a.arguments.length ? group$3(concat$8(["(", indent$6(concat$8([softline$4, join$6(concat$8([ifBreak$3("", ", "), softline$4]), e.call(function (e) { return printSequence(e, n, r) }, "arguments"))])), softline$4, ")"])) : ""]); case "NamedType": return e.call(r, "name"); case "VariableDefinition": return concat$8([e.call(r, "variable"), ": ", e.call(r, "type"), a.defaultValue ? concat$8([" = ", e.call(r, "defaultValue")]) : ""]); case "TypeExtensionDefinition": return concat$8(["extend ", e.call(r, "definition")]); case "ObjectTypeExtension": case "ObjectTypeDefinition": return concat$8([e.call(r, "description"), a.description ? hardline$7 : "", "ObjectTypeExtension" === a.kind ? "extend " : "", "type ", e.call(r, "name"), 0 < a.interfaces.length ? concat$8([" implements ", join$6(determineInterfaceSeparator(n.originalText.substr(n.locStart(a), n.locEnd(a))), e.map(r, "interfaces"))]) : "", printDirectives(e, r, a), 0 < a.fields.length ? concat$8([" {", indent$6(concat$8([hardline$7, join$6(hardline$7, e.call(function (e) { return printSequence(e, n, r) }, "fields"))])), hardline$7, "}"]) : ""]); case "FieldDefinition": return concat$8([e.call(r, "description"), a.description ? hardline$7 : "", e.call(r, "name"), 0 < a.arguments.length ? group$3(concat$8(["(", indent$6(concat$8([softline$4, join$6(concat$8([ifBreak$3("", ", "), softline$4]), e.call(function (e) { return printSequence(e, n, r) }, "arguments"))])), softline$4, ")"])) : "", ": ", e.call(r, "type"), printDirectives(e, r, a)]); case "DirectiveDefinition": return concat$8([e.call(r, "description"), a.description ? hardline$7 : "", "directive ", "@", e.call(r, "name"), 0 < a.arguments.length ? group$3(concat$8(["(", indent$6(concat$8([softline$4, join$6(concat$8([ifBreak$3("", ", "), softline$4]), e.call(function (e) { return printSequence(e, n, r) }, "arguments"))])), softline$4, ")"])) : "", concat$8([" on ", join$6(" | ", e.map(r, "locations"))])]); case "EnumTypeExtension": case "EnumTypeDefinition": return concat$8([e.call(r, "description"), a.description ? hardline$7 : "", "EnumTypeExtension" === a.kind ? "extend " : "", "enum ", e.call(r, "name"), printDirectives(e, r, a), 0 < a.values.length ? concat$8([" {", indent$6(concat$8([hardline$7, join$6(hardline$7, e.call(function (e) { return printSequence(e, n, r) }, "values"))])), hardline$7, "}"]) : ""]); case "EnumValueDefinition": return concat$8([e.call(r, "description"), a.description ? hardline$7 : "", e.call(r, "name"), printDirectives(e, r, a)]); case "InputValueDefinition": return concat$8([e.call(r, "description"), a.description ? a.description.block ? hardline$7 : line$5 : "", e.call(r, "name"), ": ", e.call(r, "type"), a.defaultValue ? concat$8([" = ", e.call(r, "defaultValue")]) : "", printDirectives(e, r, a)]); case "InputObjectTypeExtension": case "InputObjectTypeDefinition": return concat$8([e.call(r, "description"), a.description ? hardline$7 : "", "InputObjectTypeExtension" === a.kind ? "extend " : "", "input ", e.call(r, "name"), printDirectives(e, r, a), 0 < a.fields.length ? concat$8([" {", indent$6(concat$8([hardline$7, join$6(hardline$7, e.call(function (e) { return printSequence(e, n, r) }, "fields"))])), hardline$7, "}"]) : ""]); case "SchemaDefinition": return concat$8(["schema", printDirectives(e, r, a), " {", 0 < a.operationTypes.length ? indent$6(concat$8([hardline$7, join$6(hardline$7, e.call(function (e) { return printSequence(e, n, r) }, "operationTypes"))])) : "", hardline$7, "}"]); case "OperationTypeDefinition": return concat$8([e.call(r, "operation"), ": ", e.call(r, "type")]); case "InterfaceTypeExtension": case "InterfaceTypeDefinition": return concat$8([e.call(r, "description"), a.description ? hardline$7 : "", "InterfaceTypeExtension" === a.kind ? "extend " : "", "interface ", e.call(r, "name"), printDirectives(e, r, a), 0 < a.fields.length ? concat$8([" {", indent$6(concat$8([hardline$7, join$6(hardline$7, e.call(function (e) { return printSequence(e, n, r) }, "fields"))])), hardline$7, "}"]) : ""]); case "FragmentSpread": return concat$8(["...", e.call(r, "name"), printDirectives(e, r, a)]); case "InlineFragment": return concat$8(["...", a.typeCondition ? concat$8([" on ", e.call(r, "typeCondition")]) : "", printDirectives(e, r, a), " ", e.call(r, "selectionSet")]); case "UnionTypeExtension": case "UnionTypeDefinition": return group$3(concat$8([e.call(r, "description"), a.description ? hardline$7 : "", group$3(concat$8(["UnionTypeExtension" === a.kind ? "extend " : "", "union ", e.call(r, "name"), printDirectives(e, r, a), 0 < a.types.length ? concat$8([" =", ifBreak$3("", " "), indent$6(concat$8([ifBreak$3(concat$8([line$5, "  "])), join$6(concat$8([line$5, "| "]), e.map(r, "types"))]))]) : ""]))])); case "ScalarTypeExtension": case "ScalarTypeDefinition": return concat$8([e.call(r, "description"), a.description ? hardline$7 : "", "ScalarTypeExtension" === a.kind ? "extend " : "", "scalar ", e.call(r, "name"), printDirectives(e, r, a)]); case "NonNullType": return concat$8([e.call(r, "type"), "!"]); case "ListType": return concat$8(["[", e.call(r, "type"), "]"]); default: throw new Error("unknown graphql type: " + JSON.stringify(a.kind)) } } function printDirectives(e, t, n) { return 0 === n.directives.length ? "" : concat$8([" ", group$3(indent$6(concat$8([softline$4, join$6(concat$8([ifBreak$3("", " "), softline$4]), e.map(t, "directives"))])))]) } function printSequence(e, r, a) { var u = e.getValue().length; return e.map(function (e, t) { var n = a(e); return isNextLineEmpty$4(r.originalText, e.getValue(), r) && t < u - 1 ? concat$8([n, hardline$7]) : n }) } function canAttachComment$1(e) { return e.kind && "Comment" !== e.kind } function printComment$2(e) { var t = e.getValue(); switch (t.kind) { case "Comment": return "#" + t.value.trimRight(); default: throw new Error("Not a comment: " + JSON.stringify(t)) } } function determineInterfaceSeparator(e) { var t = e.indexOf("implements"); if (-1 === t) throw new Error("Must implement interfaces: " + e); var n = e.indexOf("{"); return -1 === n && (n = e.length), e.substr(t, n).includes("&") ? " & " : ", " } function clean$5(e, t) { delete t.loc, delete t.comments } var printerGraphql = { print: genericPrint$4, massageAstNode: clean$5, hasPrettierIgnore: hasIgnoreComment$3, printComment: printComment$2, canAttachComment: canAttachComment$1 }, options$9 = { bracketSpacing: commonOptions.bracketSpacing }, languages$2 = [{ name: "GraphQL", since: "1.5.0", parsers: ["graphql"], extensions: [".graphql", ".gql"], tmScope: "source.graphql", aceMode: "text", liguistLanguageId: 139, vscodeLanguageIds: ["graphql"] }], printers$2 = { graphql: printerGraphql }, languageGraphql = { languages: languages$2, options: options$9, printers: printers$2 }, _require$$0$builders$5 = doc.builders, hardline$9 = _require$$0$builders$5.hardline, literalline$3 = _require$$0$builders$5.literalline, concat$10 = _require$$0$builders$5.concat, markAsRoot$1 = _require$$0$builders$5.markAsRoot, mapDoc$4 = doc.utils.mapDoc; function embed$2(e, t, n, r) { var a, u = e.getValue(); if ("code" === u.type && null !== u.lang) { var o = function (t) { var e = support.getSupportInfo(null, { plugins: r.plugins }).languages.find(function (e) { return e.name.toLowerCase() === t || e.extensions && e.extensions.find(function (e) { return e.substring(1) === t }) }); if (e) return e.parsers[0]; return null }(u.lang.split(/\s/, 1)[0]); if (o) { var i = r.__inJsTemplate ? "~" : "`", s = i.repeat(Math.max(3, util.getMaxContinuousCount(u.value, i) + 1)), c = n(u.value, { parser: o }); return markAsRoot$1(concat$10([s, u.lang, hardline$9, (a = c, mapDoc$4(a, function (e) { return "string" == typeof e && e.includes("\n") ? concat$10(e.split(/(\n)/g).map(function (e, t) { return t % 2 == 0 ? e : literalline$3 })) : e })), s])) } } return null } var embed_1$2 = embed$2; function parse$3(e) { var t; 0 === e.indexOf("---") ? t = "---" : 0 === e.indexOf("+++") && (t = "+++"); var n = -1; return t && -1 !== (n = e.indexOf("\n".concat(t), 3)) ? (n += 4, { frontMatter: e.slice(0, n), content: e.slice(n) }) : { frontMatter: null, content: e } } var frontMatter = parse$3, pragma$2 = createCommonjsModule(function (e) { var a = ["format", "prettier"]; function t(e) { var t = "@(".concat(a.join("|"), ")"), n = new RegExp(["\x3c!--\\s*".concat(t, "\\s*--\x3e"), "\x3c!--.*\n[\\s\\S]*(^|\n)[^\\S\n]*".concat(t, "[^\\S\n]*($|\n)[\\s\\S]*\n.*--\x3e")].join("|"), "m"), r = e.match(n); return r && 0 === r.index } e.exports = { startWithPragma: t, hasPragma: function (e) { return t(frontMatter(e).content.trimLeft()) }, insertPragma: function (e) { var t = frontMatter(e), n = "\x3c!-- @".concat(a[0], " --\x3e"); return t.frontMatter ? "".concat(t.frontMatter, "\n\n").concat(n, "\n\n").concat(t.content) : "".concat(n, "\n\n").concat(t.content) } } }), _require$$0$builders$4 = doc.builders, concat$9 = _require$$0$builders$4.concat, join$7 = _require$$0$builders$4.join, line$6 = _require$$0$builders$4.line, hardline$8 = _require$$0$builders$4.hardline, softline$5 = _require$$0$builders$4.softline, fill$4 = _require$$0$builders$4.fill, align$2 = _require$$0$builders$4.align, indent$7 = _require$$0$builders$4.indent, group$4 = _require$$0$builders$4.group, mapDoc$3 = doc.utils.mapDoc, printDocToString$2 = doc.printer.printDocToString, SINGLE_LINE_NODE_TYPES = ["heading", "tableCell", "link"], SIBLING_NODE_TYPES = ["listItem", "definition", "footnoteDefinition"], INLINE_NODE_TYPES = ["liquidNode", "inlineCode", "emphasis", "strong", "delete", "link", "linkReference", "image", "imageReference", "footnote", "footnoteReference", "sentence", "whitespace", "word", "break"], INLINE_NODE_WRAPPER_TYPES = INLINE_NODE_TYPES.concat(["tableCell", "paragraph", "heading"]); function genericPrint$5(t, a, u) { var o = t.getValue(); if (shouldRemainTheSameContent(t)) return concat$9(util.splitText(a.originalText.slice(o.position.start.offset, o.position.end.offset), a).map(function (e) { return "word" === e.type ? e.value : "" === e.value ? "" : printLine(t, e.value, a) })); switch (o.type) { case "root": return 0 === o.children.length ? "" : concat$9([normalizeDoc(printRoot(t, a, u)), hardline$8]); case "paragraph": return printChildren(t, a, u, { postprocessor: fill$4 }); case "sentence": return printChildren(t, a, u); case "word": return o.value.replace(/[*]/g, "\\*").replace(new RegExp(["(^|[".concat(util.punctuationCharRange, "])(_+)"), "(_+)([".concat(util.punctuationCharRange, "]|$)")].join("|"), "g"), function (e, t, n, r, a) { return (n ? "".concat(t).concat(n) : "".concat(r).concat(a)).replace(/_/g, "\\_") }); case "whitespace": var e = t.getParentNode(), n = e.children.indexOf(o), r = e.children[n + 1], i = r && /^>|^([-+*]|#{1,6}|[0-9]+[.)])$/.test(r.value) ? "never" : a.proseWrap; return printLine(t, o.value, { proseWrap: i }); case "emphasis": var s = t.getParentNode(), c = s.children.indexOf(o), l = s.children[c - 1], p = s.children[c + 1], d = l && "sentence" === l.type && 0 < l.children.length && "word" === util.getLast(l.children).type && !util.getLast(l.children).hasTrailingPunctuation || p && "sentence" === p.type && 0 < p.children.length && "word" === p.children[0].type && !p.children[0].hasLeadingPunctuation || getAncestorNode$2(t, "emphasis") ? "*" : "_"; return concat$9([d, printChildren(t, a, u), d]); case "strong": return concat$9(["**", printChildren(t, a, u), "**"]); case "delete": return concat$9(["~~", printChildren(t, a, u), "~~"]); case "inlineCode": var m = util.getMaxContinuousCount(o.value, "`"), f = 1 === m ? "``" : "`", D = m ? " " : ""; return concat$9([f, D, o.value, D, f]); case "link": switch (a.originalText[o.position.start.offset]) { case "<": return concat$9(["<", o.url, ">"]); case "[": return concat$9(["[", printChildren(t, a, u), "](", printUrl(o.url, ")"), printTitle(o.title, a), ")"]); default: return a.originalText.slice(o.position.start.offset, o.position.end.offset) }case "image": return concat$9(["![", o.alt || "", "](", printUrl(o.url, ")"), printTitle(o.title, a), ")"]); case "blockquote": return concat$9(["> ", align$2("> ", printChildren(t, a, u))]); case "heading": return concat$9(["#".repeat(o.depth) + " ", printChildren(t, a, u)]); case "code": if (/^\n?( {4,}|\t)/.test(a.originalText.slice(o.position.start.offset, o.position.end.offset))) { var g = " ".repeat(4); return align$2(g, concat$9([g, join$7(hardline$8, o.value.split("\n"))])) } var h = a.__inJsTemplate ? "~" : "`", y = h.repeat(Math.max(3, util.getMaxContinuousCount(o.value, h) + 1)); return concat$9([y, o.lang || "", hardline$8, join$7(hardline$8, o.value.split("\n")), hardline$8, y]); case "front-matter": return o.value; case "html": var C = t.getParentNode(); return replaceNewlinesWithHardlines("root" === C.type && util.getLast(C.children) === o ? o.value.trimRight() : o.value); case "list": var $ = getNthListSiblingIndex(o, t.getParentNode()), E = o.ordered && 1 < o.children.length && /^\s*1(\.|\))/.test(a.originalText.slice(o.children[1].position.start.offset, o.children[1].position.end.offset)); return printChildren(t, a, u, { processor: function (e, t) { var n, r = (n = o.ordered ? (0 === t ? o.start : E ? 1 : o.start + t) + ($ % 2 == 0 ? ". " : ") ") : $ % 2 == 0 ? "- " : "* ", e.getValue().children.length ? alignListPrefix(n, a) : n); return concat$9([r, align$2(" ".repeat(r.length), printListItem(e, a, u, r))]) } }); case "thematicBreak": var A = getAncestorCounter$1(t, "list"); return -1 === A ? "---" : getNthListSiblingIndex(t.getParentNode(A), t.getParentNode(A + 1)) % 2 == 0 ? "***" : "---"; case "linkReference": return concat$9(["[", printChildren(t, a, u), "]", "full" === o.referenceType ? concat$9(["[", o.identifier, "]"]) : "collapsed" === o.referenceType ? "[]" : ""]); case "imageReference": switch (o.referenceType) { case "full": return concat$9(["![", o.alt || "", "][", o.identifier, "]"]); default: return concat$9(["![", o.alt, "]", "collapsed" === o.referenceType ? "[]" : ""]) }case "definition": var v = "always" === a.proseWrap ? line$6 : " "; return group$4(concat$9([concat$9(["[", o.identifier, "]:"]), indent$7(concat$9([v, printUrl(o.url), null === o.title ? "" : concat$9([v, printTitle(o.title, a, !1)])]))])); case "footnote": return concat$9(["[^", printChildren(t, a, u), "]"]); case "footnoteReference": return concat$9(["[^", o.identifier, "]"]); case "footnoteDefinition": var F = t.getParentNode().children[t.getName() + 1]; return concat$9(["[^", o.identifier, "]: ", group$4(concat$9([align$2(" ".repeat(a.tabWidth), printChildren(t, a, u, { processor: function (e, t) { return 0 === t ? group$4(concat$9([softline$5, softline$5, e.call(u)])) : e.call(u) } })), F && "footnoteDefinition" === F.type ? softline$5 : ""]))]); case "table": return printTable(t, a, u); case "tableCell": return printChildren(t, a, u); case "break": return concat$9([/\s/.test(a.originalText[o.position.start.offset]) ? "  " : "\\", hardline$8]); case "liquidNode": return replaceNewlinesWithHardlines(o.value); case "tableRow": case "listItem": default: throw new Error("Unknown markdown type ".concat(JSON.stringify(o.type))) } } function printListItem(e, r, a, u) { var t = e.getValue(), o = null === t.checked ? "" : t.checked ? "[x] " : "[ ] "; return concat$9([o, printChildren(e, r, a, { processor: function (e, t) { if (0 === t && "list" !== e.getValue().type) return align$2(" ".repeat(o.length), e.call(a)); var n = " ".repeat(clamp(r.tabWidth - u.length, 0, 3)); return concat$9([n, align$2(n, e.call(a))]) } })]) } function alignListPrefix(e, t) { var n, r = 0 == (n = e.length % t.tabWidth) ? 0 : t.tabWidth - n; return e + " ".repeat(4 <= r ? 0 : r) } function getNthListSiblingIndex(t, e) { return getNthSiblingIndex(t, e, function (e) { return e.ordered === t.ordered }) } function replaceNewlinesWithHardlines(e) { return join$7(hardline$8, e.split("\n")) } function getNthSiblingIndex(e, t, n) { n = n || function () { return !0 }; var r = -1, a = !0, u = !1, o = void 0; try { for (var i, s = t.children[Symbol.iterator](); !(a = (i = s.next()).done); a = !0) { var c = i.value; if (c.type === e.type && n(c) ? r++ : r = -1, c === e) return r } } catch (e) { u = !0, o = e } finally { try { a || null == s.return || s.return() } finally { if (u) throw o } } } function getAncestorCounter$1(e, t) { for (var n, r = [].concat(t), a = -1; n = e.getParentNode(++a);)if (-1 !== r.indexOf(n.type)) return a; return -1 } function getAncestorNode$2(e, t) { var n = getAncestorCounter$1(e, t); return -1 === n ? null : e.getParentNode(n) } function printLine(e, t, n) { if ("preserve" === n.proseWrap && "\n" === t) return hardline$8; var r = "always" === n.proseWrap && !getAncestorNode$2(e, SINGLE_LINE_NODE_TYPES); return "" !== t ? r ? line$6 : " " : r ? softline$5 : "" } function printTable(e, n, r) { var a = e.getValue(), u = []; e.map(function (e) { var t = []; e.map(function (e) { t.push(printDocToString$2(e.call(r), n).formatted) }, "children"), u.push(t) }, "children"); var o = u.reduce(function (e, n) { return e.map(function (e, t) { return Math.max(e, util.getStringWidth(n[t])) }) }, u[0].map(function () { return 3 })); return join$7(hardline$8, [t(u[0]), concat$9(["| ", join$7(" | ", o.map(function (e, t) { switch (a.align[t]) { case "left": return ":" + "-".repeat(e - 1); case "right": return "-".repeat(e - 1) + ":"; case "center": return ":" + "-".repeat(e - 2) + ":"; default: return "-".repeat(e) } })), " |"]), join$7(hardline$8, u.slice(1).map(t))]); function t(e) { return concat$9(["| ", join$7(" | ", e.map(function (e, t) { switch (a.align[t]) { case "right": return function (e, t) { return concat$9([" ".repeat(t - util.getStringWidth(e)), e]) }(e, o[t]); case "center": return function (e, t) { var n = t - util.getStringWidth(e), r = Math.floor(n / 2), a = n - r; return concat$9([" ".repeat(r), e, " ".repeat(a)]) }(e, o[t]); default: return function (e, t) { return concat$9([e, " ".repeat(t - util.getStringWidth(e))]) }(e, o[t]) } })), " |"]) } } function printRoot(e, r, a) { var u = [], n = null, o = e.getValue().children; return o.forEach(function (e, t) { switch (isPrettierIgnore(e)) { case "start": null === n && (n = { index: t, offset: e.position.end.offset }); break; case "end": null !== n && (u.push({ start: n, end: { index: t, offset: e.position.start.offset } }), n = null) } }), printChildren(e, r, a, { processor: function (e, t) { if (0 !== u.length) { var n = u[0]; if (t === n.start.index) return concat$9([o[n.start.index].value, r.originalText.slice(n.start.offset, n.end.offset), o[n.end.index].value]); if (n.start.index < t && t < n.end.index) return !1; if (t === n.end.index) return u.shift(), !1 } return e.call(a) } }) } function printChildren(e, u, t, n) { var o, r = (n = n || {}).postprocessor || concat$9, i = n.processor || function (e) { return e.call(t) }, s = e.getValue(), c = []; return e.map(function (e, t) { var n = e.getValue(), r = i(e, t); if (!1 !== r) { var a = { parts: c, prevNode: o, parentNode: s, options: u }; shouldNotPrePrintHardline(n, a) || (c.push(hardline$8), (shouldPrePrintDoubleHardline(n, a) || shouldPrePrintTripleHardline(n, a)) && c.push(hardline$8), shouldPrePrintTripleHardline(n, a) && c.push(hardline$8)), c.push(r), o = n } }, "children"), r(c) } function isPrettierIgnore(e) { if ("html" !== e.type) return !1; var t = e.value.match(/^<!--\s*prettier-ignore(?:-(start|end))?\s*-->$/); return null !== t && (t[1] ? t[1] : "next") } function shouldNotPrePrintHardline(e, t) { var n = 0 === t.parts.length, r = -1 !== INLINE_NODE_TYPES.indexOf(e.type), a = "html" === e.type && -1 !== INLINE_NODE_WRAPPER_TYPES.indexOf(t.parentNode.type); return n || r || a } function shouldPrePrintDoubleHardline(e, t) { var n = (t.prevNode && t.prevNode.type) === e.type && -1 !== SIBLING_NODE_TYPES.indexOf(e.type), r = "listItem" === t.parentNode.type && !t.parentNode.loose, a = t.prevNode && "listItem" === t.prevNode.type && t.prevNode.loose, u = "next" === isPrettierIgnore(t.prevNode); return a || !(n || r || u) } function shouldPrePrintTripleHardline(e, t) { var n = t.prevNode && "list" === t.prevNode.type, r = "code" === e.type && /\s/.test(t.options.originalText[e.position.start.offset]); return n && r } function shouldRemainTheSameContent(e) { var t = getAncestorNode$2(e, ["linkReference", "imageReference"]); return t && ("linkReference" !== t.type || "full" !== t.referenceType) } function normalizeDoc(e) { return mapDoc$3(e, function (e) { if (!e.parts) return e; if ("concat" === e.type && 1 === e.parts.length) return e.parts[0]; var t = []; return e.parts.forEach(function (e) { "concat" === e.type ? t.push.apply(t, e.parts) : "" !== e && t.push(e) }), Object.assign({}, e, { parts: normalizeParts(t) }) }) } function printUrl(e, t) { var n = [" "].concat(t || []); return new RegExp(n.map(function (e) { return "\\".concat(e) }).join("|")).test(e) ? "<".concat(e, ">") : e } function printTitle(e, t, n) { if (null == n && (n = !0), !e) return ""; if (n) return " " + printTitle(e, t, !1); if (e.includes('"') && e.includes("'") && !e.includes(")")) return "(".concat(e, ")"); var r = e.split("'").length - 1, a = e.split('"').length - 1, u = a < r ? '"' : r < a ? "'" : t.singleQuote ? "'" : '"'; return e = e.replace(new RegExp("(".concat(u, ")"), "g"), "\\$1"), "".concat(u).concat(e).concat(u) } function normalizeParts(e) { return e.reduce(function (e, t) { var n = util.getLast(e); return "string" == typeof n && "string" == typeof t ? e.splice(-1, 1, n + t) : e.push(t), e }, []) } function clamp(e, t, n) { return e < t ? t : n < e ? n : e } function clean$6(e, t, n) { if (delete t.position, "code" === e.type && delete t.value, "whitespace" === e.type && "\n" === e.value && (t.value = " "), n && "root" === n.type && 0 < n.children.length && (n.children[0] === e || "front-matter" === n.children[0].type && n.children[1] === e) && "html" === e.type && pragma$2.startWithPragma(e.value)) return null } function hasPrettierIgnore$1(e) { var t = +e.getName(); return 0 != t && "next" === isPrettierIgnore(e.getParentNode().children[t - 1]) } var printerMarkdown = { print: genericPrint$5, embed: embed_1$2, massageAstNode: clean$6, hasPrettierIgnore: hasPrettierIgnore$1, insertPragma: pragma$2.insertPragma }, CATEGORY_MARKDOWN = "Markdown", options$12 = { proseWrap: { since: "1.8.2", category: CATEGORY_MARKDOWN, type: "choice", default: [{ since: "1.8.2", value: !0 }, { since: "1.9.0", value: "preserve" }], description: "How to wrap prose. (markdown)", choices: [{ since: "1.9.0", value: "always", description: "Wrap prose if it exceeds the print width." }, { since: "1.9.0", value: "never", description: "Do not wrap prose." }, { since: "1.9.0", value: "preserve", description: "Wrap prose as-is." }, { value: !1, deprecated: "1.9.0", redirect: "never" }, { value: !0, deprecated: "1.9.0", redirect: "always" }] }, singleQuote: commonOptions.singleQuote }, languages$3 = [{ name: "Markdown", since: "1.8.0", parsers: ["remark"], aliases: ["pandoc"], aceMode: "markdown", codemirrorMode: "gfm", codemirrorMimeType: "text/x-gfm", wrap: !0, extensions: [".md", ".markdown", ".mdown", ".mdwn", ".mkd", ".mkdn", ".mkdown", ".ron", ".workbook"], filenames: ["README"], tmScope: "source.gfm", linguistLanguageId: 222, vscodeLanguageIds: ["markdown"] }], printers$3 = { mdast: printerMarkdown }, languageMarkdown = { languages: languages$3, options: options$12, printers: printers$3 }, _require$$0$builders$7 = doc.builders, concat$12 = _require$$0$builders$7.concat, hardline$11 = _require$$0$builders$7.hardline; function embed$4(e, t, n, r) { var a, u = e.getValue(), o = e.getParentNode(); if (!o || "root" !== o.tag || u.unary) return null; if ("style" === u.tag) { var i = u.attrs.find(function (e) { return "lang" === e.name }); i && "postcss" !== i.value ? "scss" === i.value ? a = "scss" : "less" === i.value && (a = "less") : a = "css" } if ("script" === u.tag) { var s = u.attrs.find(function (e) { return "lang" === e.name }); s ? "ts" !== s.value && "tsx" !== s.value || (a = "typescript") : a = "babylon" } return a ? concat$12([r.originalText.slice(u.start, u.contentStart), hardline$11, n(r.originalText.slice(u.contentStart, u.contentEnd), { parser: a }), r.originalText.slice(u.contentEnd, u.end)]) : null } var embed_1$4 = embed$4, _require$$0$builders$6 = doc.builders, concat$11 = _require$$0$builders$6.concat, hardline$10 = _require$$0$builders$6.hardline; function genericPrint$6(e, n, r) { var t = e.getValue(), a = [], u = t.start; return e.each(function (e) { var t = e.getValue(); a.push(n.originalText.slice(u, t.start)), a.push(e.call(r)), u = t.end }, "children"), a.push(n.originalText.slice(u, t.end)), "root" === t.tag && t.children.length && a.push(hardline$10), concat$11(a) } var clean$7 = function (e, t) { delete t.start, delete t.end, delete t.contentStart, delete t.contentEnd }, printerVue = { print: genericPrint$6, embed: embed_1$4, massageAstNode: clean$7 }, languages$4 = [{ name: "Vue", since: "1.10.0", parsers: ["vue"], group: "HTML", tmScope: "text.html.vue", aceMode: "html", codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", extensions: [".vue"], linguistLanguageId: 146, vscodeLanguageIds: ["vue"] }], printers$4 = { vue: printerVue }, languageVue = { languages: languages$4, printers: printers$4 }, version = require$$0.version, getSupportInfo = support.getSupportInfo, internalPlugins = [languageJs, languageCss, languageGraphql, languageMarkdown, languageVue], isArray = Array.isArray || function (e) { return "[object Array]" === Object.prototype.toString.call(e) }; function withPlugins(n) { return function () { var e = Array.from(arguments), t = e[1] && e[1].plugins || []; return isArray(t) || (t = Object.values(t)), e[1] = Object.assign({}, e[1], { plugins: internalPlugins.concat(t) }), n.apply(null, e) } } var formatWithCursor = withPlugins(core.formatWithCursor), standalone = { formatWithCursor: formatWithCursor, format: function (e, t) { return formatWithCursor(e, t).formatted }, check: function (e, t) { return formatWithCursor(e, t).formatted === e }, doc: doc, getSupportInfo: withPlugins(getSupportInfo), version: version, util: utilShared, __debug: { parse: withPlugins(core.parse), formatAST: withPlugins(core.formatAST), formatDoc: withPlugins(core.formatDoc), printToDoc: withPlugins(core.printToDoc), printDocToString: withPlugins(core.printDocToString) } }; return standalone });
